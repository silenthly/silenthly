{"meta":{"title":"Buyan-Blog","subtitle":"","description":"我见过真正难过的人，但他一滴泪也没流","author":"buyan","url":"https://silenthly.github.io","root":"/"},"pages":[{"title":"分类","date":"2021-07-10T08:53:26.000Z","updated":"2021-07-10T10:54:33.716Z","comments":false,"path":"categories/index.html","permalink":"https://silenthly.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-07-10T08:52:30.000Z","updated":"2021-07-10T10:52:42.242Z","comments":false,"path":"tags/index.html","permalink":"https://silenthly.github.io/tags/index.html","excerpt":"","text":""},{"title":"关于","date":"2021-07-10T08:53:26.000Z","updated":"2021-10-26T11:14:14.695Z","comments":false,"path":"about/index.html","permalink":"https://silenthly.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"文本组件","slug":"java/GUI/文本组件","date":"2021-10-18T14:14:23.000Z","updated":"2021-10-27T04:41:11.703Z","comments":true,"path":"2021/10/18/java/GUI/文本组件/","link":"","permalink":"https://silenthly.github.io/2021/10/18/java/GUI/%E6%96%87%E6%9C%AC%E7%BB%84%E4%BB%B6/","excerpt":"​ 文本组件用于显示和编辑文本。Swing 支持大多数编辑软件常见的一些编辑功能，如光标的各种移动方式，文本字符、文本行或文本块的选择、插入、删除、拷贝、粘贴等。本文将介绍 JTextField 单行文本组件、JPasswordField 密码框组件和 JTextArea 文本区域组件。","text":"​ 文本组件用于显示和编辑文本。Swing 支持大多数编辑软件常见的一些编辑功能，如光标的各种移动方式，文本字符、文本行或文本块的选择、插入、删除、拷贝、粘贴等。本文将介绍 JTextField 单行文本组件、JPasswordField 密码框组件和 JTextArea 文本区域组件。 单行文本组件：JTextField ​ JTextField 单行文本组件允许用户输入一行字符，将需要的字符添加到文本框中。JTextField 类的常用方法如下表所示。 序号 方法 类型 说明 1 JTextField() 构造 构造一个新的TextField 2 JTextField(Document doc,String text,int columns) 构造 构造一个指定文本存储模型，设定初始化字符串并给定列数的JTextField 3 JTextField(int columns) 构造 构造一个具有指定列数的新的空TextField 4 JTextField(String text) 构造 构造一个用指定文本初始化的新TextField 5 JTextField(String text,int columns) 构造 构造一个指定文本和列初始化的新TextField 6 int getColumns() 普通 返回TextField中的列数 7 void setColumns(Document doc) 普通 设置此TextField中的列数 8 public String getText() 普通 返回此TextComponent中包含的文本 9 public void setText(String t) 普通 将此TextComponent文本设置为指定文本 10 public void setEditable(boolean b) 普通 设置文本框是否可编辑 11 void setFont(Font t) 普通 设置当前字体 12 void setDocument(Document doc) 普通 将编辑器与一个文本文档关联 ​ JTextField常用的事件有以下几个。 TextEvent：当文本内容发生改变时触发 ActionEvent：用户按下回车后触发 KeyEvent：在输入框中按下按键时触发 密码框组件：JPasswordField ​ JPasswordField 密码框主要用于输入密码，不同于 JTextField，JPasswordField 将输入的字符回显为其他字符。JPasswordField 类的常用方法如下表所示。 序号 方法 类型 说明 1 JPasswordField() 构造 构造一个空的JPasswordField 2 JPasswordField(Document doc,String txt,int columns) 构造 构造一个指定文本存储模型，设定初始化字符串并给定列数的JPasswordField 3 JPasswordField(int columns) 构造 构造一个具有指定列数的JPasswordField 4 JPasswordField(String txt) 构造 构造一个利用指定文本初始化的JPasswordField 5 JPasswordField(String text,int columns) 构造 构造一个利用指定文本和列初始化的JPasswordField 6 char getEchoChar() 普通 返回用于回显的字符，默认字符为&quot;*&quot; 7 char[] getPassword() 普通 返回此TextComponent中所包含的文本 8 protected String paramString() 普通 返回此JPasswordField的字符串表示形式 9 void setEcho(char c) 普通 设置此JPasswordField的回显字符 ​ 下面使用 JTextField 组件和 JPasswordField 组件完成一个简单的登录界面。 代码示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.awt.Color;import java.awt.Font;import java.awt.GridLayout;import javax.swing.JPanel;import javax.swing.JButton;import javax.swing.JLabel;import javax.swing.JFrame;import java.awt.event.ActionListener;import java.awt.event.ActionEvent;import javax.swing.JTextField;import javax.swing.JPasswordField;/**连接到数据库*/class DatabaseCheck&#123; public static final String DBDRIVER=&quot;com.mysql.cj.jdbc.Driver&quot;; public static final String DBURL=&quot;jdbc:mysql://localhost:3306/javaTest&quot;; public static final String DBPASSWORD=&quot;123456&quot;; public static final String DBUSER=&quot;root&quot;; private String name; private String passwd; public DatabaseCheck()&#123;&#125; public DatabaseCheck(String name,String passwd) &#123; this.name=name; this.passwd=passwd; &#125; public Connection connDatabase() //连接数据库 &#123; Connection conn=null; try &#123; Class.forName(DBDRIVER); conn=DriverManager.getConnection(DBURL,DBUSER,DBPASSWORD); &#125;catch(Exception e) &#123; System.out.println(&quot;MySQL数据库连接失败！！！&quot;); e.printStackTrace(); &#125; return conn; &#125; /** 用户登录 */ public boolean prepared() &#123; Connection conn=null; PreparedStatement perstat=null; ResultSet rs=null; try &#123; conn=connDatabase(); String sql=&quot;SELECT name,password FROM StudentUser WHERE name=? and password=?&quot;; perstat=conn.prepareStatement(sql); //执行sql语句 perstat.setString(1,name); perstat.setString(2,passwd); rs=perstat.executeQuery(); if(rs.next()) &#123; return true; &#125; &#125;catch(Exception e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; conn.close(); &#125;catch(Exception e) &#123; e.printStackTrace(); &#125; &#125; return false; &#125; /** 注册用户 */ public boolean register() &#123; Connection conn=null; PreparedStatement perstat=null; int rs; try &#123; conn=connDatabase(); String sql=&quot;INSERT INTO StudentUser (name,password) VALUES (?,?)&quot;; perstat=conn.prepareStatement(sql); //执行sql语句 perstat.setString(1,name); perstat.setString(2,passwd); rs=perstat.executeUpdate(); if(rs!=0) &#123; return true; &#125; &#125;catch(Exception e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; conn.close(); &#125;catch(Exception e) &#123; e.printStackTrace(); &#125; &#125; return false; &#125;&#125;/**登录界面*/public class Test&#123; private JLabel userlab=new JLabel(&quot;用户名：&quot;,JLabel.CENTER); private JTextField userText=new JTextField(25); private JLabel passwdlab=new JLabel(&quot;密 码： &quot;,JLabel.CENTER); private JPasswordField passwdText=new JPasswordField(25); private JLabel loginlab=new JLabel(&quot;登录状态&quot;,JLabel.CENTER); public Test() &#123; JFrame jf=new JFrame(&quot;登录界面&quot;); JPanel userPanel=new JPanel(); JPanel passwdPanel=new JPanel(); JPanel buttonPanel=new JPanel(); JPanel labelPanel=new JPanel(); userPanel.add(userlab); userPanel.add(userText); passwdPanel.add(passwdlab); passwdPanel.add(passwdText); JButton submit=new JButton(&quot;登录&quot;); JButton reset=new JButton(&quot;注册&quot;); buttonPanel.add(submit); buttonPanel.add(reset); Font font=new Font(&quot;楷体&quot;,Font.BOLD+Font.PLAIN,35); loginlab.setFont(font); loginlab.setForeground(Color.blue); labelPanel.add(loginlab); submit.addActionListener(new ActionListener()&#123; public void actionPerformed(ActionEvent e) &#123; String user=userText.getText(); String passwd=new String(passwdText.getPassword()); DatabaseCheck date=new DatabaseCheck(user,passwd); boolean flag=date.prepared(); if(flag) &#123; loginlab.setForeground(Color.green); loginlab.setText(&quot;登录成功！！！&quot;); &#125;else &#123; loginlab.setForeground(Color.red); loginlab.setText(&quot;登录失败！！！&quot;); &#125; passwdText.setText(&quot;&quot;); &#125; &#125;); reset.addActionListener(new ActionListener()&#123; public void actionPerformed(ActionEvent e) &#123; String user=userText.getText(); String passwd=new String(passwdText.getPassword()); DatabaseCheck date=new DatabaseCheck(user,passwd); boolean flag=date.register(); if(flag) &#123; loginlab.setForeground(Color.green); loginlab.setText(&quot;注册成功！！！&quot;); &#125;else &#123; loginlab.setForeground(Color.red); loginlab.setText(&quot;注册失败！！！&quot;); &#125; passwdText.setText(null); &#125; &#125;); jf.setLayout(new GridLayout(4,1)); jf.add(userPanel); jf.add(passwdPanel); jf.add(buttonPanel); jf.add(labelPanel); jf.setSize(400,200); jf.setLocation(250,300); jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); jf.setVisible(true); &#125; public static void main(String[] args) &#123; new Test(); &#125;&#125; 运行结果： ​ 在以上程序中，只要输入 StudentUser 数据表中存在的用户，即可登录成功。窗体上的文本框和密码框分别接收用户名和密码，当单击“登录”按钮时，触发 ActionEvent 事件， 从文本框和密码框读取内容并通过 DatabaseCheck 类进行验证，并且将密码框的内容清空。当单击“登录”按钮时，触发 ActionEvent 事件，从文本框和密码框读取内容并通过 DatabaseCheck 类对数据库输入数据进行注册，并且将密码框的内容清空。 文本区域组件：JTextArea ​ JTextField 文本框只允许用户输入一行信息，JTextArea 文本区域组件可以允许用户输入多行信息。JTextArea 类的常用方法如下表所示。 序号 方法 类型 说明 1 JTextArea() 构造 构造新的JTextArea 2 JTextArea(Document doc) 构造 构造一个指定的文件存储模式的JTextArea 3 JTextArea(Document doc,String txt,int rows,int columns) 构造 构造一个指定的文件存储模式，设置其初始文本并具有指定行数和列数的JTextArea 4 JTextArea(int rows,int columns) 构造 构造具有指定行数和列数的JTextArea 5 JTextArea(String txt) 构造 构造显示指定文本的TextArea 6 JTextArea(String txt,int rows,int columns) 构造 构造具有指定文本、行数和列数的新的JTextArea 7 void append(String str) 普通 将给定文本追加到文档结尾 8 void setColumns() 普通 设置此 TextArea 中的列数 9 int getColumns() 普通 返回此 TextArea 中的列数 10 void setRows() 普通 设置此 TextArea 中的行数 11 int getRows() 普通 返回此 TextArea 中的行数 12 void setFont(Font f) 普通 设置当前字体 13 int getLineCount() 普通 返回此文本区中所包含的行数 14 void insert(String str,int pos) 普通 将指定文本插入指定位置 15 void replaceRange(String str,int start,int end) 普通 用给定的新文本替换从指示的起始位置到结尾位置的文本 16 void setLineWrap(boolean wrap) 普通 设置文本区中是否自动换行，若wrap为true，则自动换行，否则不自动换行，默认为false 代码示例： 123456789101112131415161718import javax.swing.JTextArea;import javax.swing.JFrame;import javax.swing.JScrollPane;public class Test&#123; public static void main(String[] args) &#123; JFrame jf=new JFrame(&quot;JTextArea组件&quot;); JTextArea text=new JTextArea(8,25); text.setLineWrap(true); JScrollPane scroll=new JScrollPane(text); jf.add(scroll); jf.pack(); jf.setLocation(400,400); jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); jf.setVisible(true); &#125;&#125; 运行结果： 参考书目： 《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"布局管理器","slug":"java/GUI/布局管理器","date":"2021-10-17T14:14:23.000Z","updated":"2021-10-27T04:41:18.374Z","comments":true,"path":"2021/10/17/java/GUI/布局管理器/","link":"","permalink":"https://silenthly.github.io/2021/10/17/java/GUI/%E5%B8%83%E5%B1%80%E7%AE%A1%E7%90%86%E5%99%A8/","excerpt":"​ 在图形用户界面程序中往往要使用众多的GUI组件，需要将这些组件合理地放置到容器中。这就需要对这些组件的布置进行管理，可以使用布局管理器的类来排列界面上的组件。","text":"​ 在图形用户界面程序中往往要使用众多的GUI组件，需要将这些组件合理地放置到容器中。这就需要对这些组件的布置进行管理，可以使用布局管理器的类来排列界面上的组件。 流式布局管理器：FlowLayout ​ FlowLayout 布局管理器是 JPanel 容器的默认布局管理器，该布局管理器是最简单的一种布局管理器，其排列方式是以容器中的组件大小为首选尺寸，按顺序向容器中添加组件，当一行放不下所有组件时，自动折为多行。在创建 FlowLayout 布局管理器时，可设置一行组件的对齐方式，默认为中间对齐，也可设置为左、右对齐。FlowLayout 类的常用常量和方法如下表所示。 序号 方法 类型 说明 1 static int CENTER 常量 每一行组件都应该是居中的 2 static int LEADING 常量 每一行组件都应该与容器方向的开始边对齐 3 static int LEFT 常量 每一行组件都应该是左对齐的 4 static int RIGHT 常量 每一行组件都应该是右对齐的 5 static int TRALING 常量 每一行组件都应该与容器方向的结束边对齐 6 FlowLayout() 构造 钩针一个新的FlowLayout，它是居中对齐的，默认的水平和垂直间距是5个单位 7 FlowLayout(int align) 构造 钩针一个新的FlowLayout，它具有指定的对齐方式，默认的水平和垂直间距是5个单位 8 FlowLayout(itn align,int hgap,int vgap) 构造 钩针一个新的FlowLayout，它具有指定的对齐方式，及指定的水平和垂直间距 9 int getHgap() 普通 获取组件之间及组件与容器的边之间的水平间距 10 int getVgap() 普通 获取组件之间及组件与容器的边之间的垂直间距 11 void setHgap(int Hgap) 普通 设置组件之间及组件与容器的边之间的水平间距 12 void setVgap(int vgap) 普通 设置组件之间及组件与容器的边之间的垂直间距 提示：间距单位为像素 代码示例： 12345678910111213141516171819202122import java.awt.FlowLayout;import javax.swing.JFrame;import javax.swing.JButton;import javax.swing.JPanel;public class Test&#123; public static void main(String[] args) &#123; JFrame jf=new JFrame(&quot;FlowLayout布局窗口&quot;); FlowLayout flow=new FlowLayout(FlowLayout.LEFT,5,5); JPanel panel=new JPanel(flow); for(int i=1;i&lt;=9;i++) &#123; panel.add(new JButton(&quot;按钮&quot;+i)); &#125; jf.add(panel); jf.setSize(235,150); jf.setLocation(250,300); jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); jf.setVisible(true); &#125;&#125; 运行结果： ​ 其实 JPanel 面板默认的布局管理器就是 FlowLayout。从程序的运行结果可以发现，按钮组件的从左到右从上到下顺序排序的。若使用 pack() 方法替代 setSize(235,150)，则显示结果如下图所示： 边界布局管理器：BorderLayout ​ BorderLayout 是JFrame、JWindow、JDialog、JInternalFrame 及 JApplet 的默认布局管理器。边界布局管理器使用类 BorderLayout 将容器划分为东、西、南、北和中5个区域，每个区域可放置一个组件。中央区域通常放置比较大的组件，而其他其余放置比较小的组件。BorderLayout 类的常用常量和方法如下表所示。 序号 方法 类型 说明 1 static String CENTER 常量 将组件设置在中间区域 2 static String EAST 常量 将组件设置在东区域 3 static String NORTH 常量 将组件设置在北区域 4 static String SOUTH 常量 将组件设置在南区域 5 static String WEST 常量 将组件设置在西区域 6 BorderLayout() 构造 构造一个组件之间没有间距的新边框布局 7 BorderLayout(int hgap,int vgap) 构造 构造一个具有指定组件间距的边框布局 8 float getLayoutAlignmentX(Container parent) 普通 返回沿X轴的对齐方式 9 float getLayoutAlignmentY(Container parent) 普通 返回沿Y轴的对齐方式 10 void removeLayoutComponent(Container comp) 普通 从此边框布局中移除指定组件 11 int getHgap() 普通 返回组件之间的水平间距 12 int getVgap() 普通 返回组件之间的垂直间距 13 void setHgap(int Hgap) 普通 设置组件之间的水平间距 14 void setVgap(int vgap) 普通 设置组件之间的垂直间距 代码示例： 1234567891011121314151617181920212223import java.awt.BorderLayout;import javax.swing.JFrame;import javax.swing.JButton;import javax.swing.JPanel;public class Test&#123; public static void main(String[] args) &#123; JFrame jf=new JFrame(&quot;BoderLayout布局管理器&quot;); BorderLayout border=new BorderLayout(5,5); JPanel panel=new JPanel(border); panel.add(new JButton(&quot;东（EAST）&quot;),BorderLayout.EAST); panel.add(new JButton(&quot;南（SOUTH）&quot;),BorderLayout.SOUTH); panel.add(new JButton(&quot;西（WEST）&quot;),BorderLayout.WEST); panel.add(new JButton(&quot;北（NORTH）&quot;),BorderLayout.NORTH); panel.add(new JButton(&quot;中（CENTER）&quot;),BorderLayout.CENTER); jf.add(panel); jf.setSize(400,300); jf.setLocation(250,300); jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); jf.setVisible(true); &#125;&#125; 运行结果： 网格布局管理器：GridLayout ​ GridLayout 布局管理器将容器划分为指定行数、列数的单元格，每个单元格都有相同的尺寸，可以放置一个组件，该组件占据单元个的整个空间。使用 GridLayout 布局管理器向容器中添加组件时，默认是从左到右、从上到下依次添加到每一个表格中。与 FlowLayout 不同的是，GridLayout 布局管理器中的各个组件的大小由组件所在的网格大小决定，每一个组件都会自动调整为沾满整个表格。GridLayout 类的常用方法如下表所示。 序号 方法 类型 说明 1 GridLayout() 构造 创建具有默认的网格布局管理器，即每个组件占据一行一列 2 GridLayout(int rows,int cols) 构造 创建具有指定行数和列数的网络布局管理器 3 GridLayout(int rows,int cols,int hgap,int vgap) 构造 创建具有指定行数和列数的网络布局管理器 4 void addLayoutComponent(String name,Component comp) 普通 将具有指定名称的指定组件添加到网格布局管理器 5 int getColumns() 普通 获取此网格布局管理器中的列数 6 int getRows() 普通 获取此网格布局管理器中的行数 7 int getHgap() 普通 获取组件之间的水平间距 8 int getVgap() 普通 获取组件之间的垂直间距 9 void removeLayoutComponent(Component comp) 普通 从网格布局管理器中移除指定组件 10 void setColumns(int cols) 普通 将此网格布局管理器中的列数设置为指定值 11 void setRows(int rows) 普通 将此网格布局管理器中的列数设置为指定值 12 void setHgap(int hgap) 普通 将组件之间的水平间距设置为指定值 13 void setVgap(int vgap) 普通 将组件之间的垂直间距设置为指定值 代码示例： 1234567891011121314151617181920212223import java.awt.GridLayout;import javax.swing.JFrame;import javax.swing.JPanel;import javax.swing.JButton;public class Test&#123; public static void main(String[] args) &#123; JFrame jf=new JFrame(&quot;GridLayout布局管理器&quot;); GridLayout grid=new GridLayout(4,4,5,5); JPanel panel=new JPanel(grid); String str[]=&#123;&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;x&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;÷&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;+&quot;,&quot;0&quot;,&quot;.&quot;,&quot;—&quot;,&quot;=&quot;&#125;; for(int i=0;i&lt;str.length;i++) &#123; panel.add(new JButton(str[i])); &#125; jf.add(panel); jf.setSize(400,300); jf.setLocation(250,300); jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); jf.setVisible(true); &#125;&#125; 运行结果： 网格包布局管理器：GridBagLayout ​ GridBagLayout 可以说是 GridBagLayout 的增强版本，是所有布局管理器中功能最强大也是最复杂的。GridBagLayout 网格包布局管理器将容器划分为指定行数、列数的单元格，每个单元格有相同的尺寸。组件可以放置在一个单元格中，也可以跨行或跨列放置在多个单元格中。 ​ 在向 GridBagLayout 布局管理器的容器中添加组件时，需要为每个组件创建一个与之关联的 GridBagConstraints 对象。通过该类中的属性可以设置组件的布局信息，如组件在网格中位于第几行、第几列，以及需要占用几行几列等。GridBagConstraints 的对象可设置的实例变量如下表所示。 序号 方法 类型 说明 1 static int CENTER 常量 将组件置于其显示区域的中部 2 static int EAST 常量 将组件置于其显示区域的东边，即右部 3 static int NORTH 常量 将组件置于其显示区域的南边，即底部 4 static int WEST 常量 将组件置于其显示区域的西边，即左部 5 static int SOUTH 常量 将组件置于其显示区域的北边，即顶部 6 int fill 变量 组件填充网格的方式 7 int gridhwidth 变量 指定组件显示占据的单元表格列数 8 int gridheight 变量 指定组件显示占据的单元表格行数 9 int gridx 变量 指定包含组件的显示区域开始边的单元格，其中一行的第一个单元格(本行第一列)为gridx=0，默认值为RELATIVE 10 int gridy 变量 指定包含组件的显示区域顶部的单元格，其中最上边的单元格(本行第一行)为gridy=0，默认值为RELATIVE 11 static int HORIZONTAL 常量 增加组件宽度,使其水平填充显示区域 12 static int VERTICAL 常量 增加组件高度,使其垂直填充显示区域 13 double weightx 变量 当窗口放大时，组件长度变化 14 double weighty 变量 当窗口放大时，组件高度变化 15 Insets insets 变量 此字段指定组件的外部填充，即组件与其显示区域边缘之间间距的最小值 16 static int RELATIVE 常量 指定此组件是其列或行中的倒数第二个单元格( gridwidth, gridheight)，或将此组件放置在先前添加的组件旁边(gridx, gridy) 17 static int REMAINDER 常量 指定此组件占据本行或列的所有剩余空间 18 static int BOTH 常量 使组件填充整个显示区域 代码示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.awt.GridBagLayout;import java.awt.GridBagConstraints;import javax.swing.JFrame;import javax.swing.JButton;import javax.swing.JLabel;public class Test&#123; JFrame jf; GridBagLayout gridbag; protected void makeButton(String name,GridBagLayout gridbag,GridBagConstraints c) //根据设置的属性将创建的按钮添加到单元格中 &#123; JButton btn=new JButton(name); gridbag.setConstraints(btn,c); jf.add(btn); &#125; public Test() &#123; GridBagConstraints c=new GridBagConstraints(); gridbag=new GridBagLayout(); jf=new JFrame(&quot;GridBagLayout布局管理器&quot;); jf.setLayout(gridbag); //设置指定的布局管理器 c.fill=GridBagConstraints.BOTH; //指定组件填充整个显示区域 c.weightx=1.0; makeButton(&quot;按钮-A&quot;,gridbag,c); makeButton(&quot;按钮-B&quot;,gridbag,c); makeButton(&quot;按钮-C&quot;,gridbag,c); c.gridwidth=GridBagConstraints.REMAINDER; //将组件作为末尾 makeButton(&quot;按钮-D&quot;,gridbag,c); c.weightx=0.0; makeButton(&quot;按钮-E&quot;,gridbag,c); c.gridwidth=GridBagConstraints.RELATIVE; //将组件添加行或列的倒数第二个单元格 makeButton(&quot;按钮-F&quot;,gridbag,c); c.gridwidth=GridBagConstraints.REMAINDER; //将下方的第一个组件作为末尾 makeButton(&quot;按钮-G&quot;,gridbag,c); c.gridwidth=1; c.gridheight=2; c.weighty=1.0; makeButton(&quot;按钮-H&quot;,gridbag,c); c.weighty=0.0; c.gridwidth=GridBagConstraints.REMAINDER; c.gridheight=1; makeButton(&quot;按钮-I&quot;,gridbag,c); makeButton(&quot;按钮-J&quot;,gridbag,c); jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); jf.setSize(400,180); jf.setLocation(250,300); jf.setVisible(true); &#125; public static void main(String[] args) &#123; new Test(); &#125;&#125; 运行结果： ​ 从程序中可以看出 GridBagLayout 的使用非常复杂，如果参数设置地不正确，则得到的图形就会与设计者想象的相距甚远。 卡片布局管理器：CardLayout ​ CardLayout 卡片布局管理器支持容器中的两个或多个组件共享同一空间。在同一位置放置的组件只有一个可见，只有最外面的一个组件可以被看到，也可以通过指定组件名或遍历组件等方式指定显示哪一组件。CardLayout 类的常用方法如下表所示。 序号 方法 类型 说明 1 CardLayout() 构造 创建一个间距大小为0的卡片布局管理器 2 CardLayout(int hgap,int vgap) 构造 创建一个具有指定水平间距和垂直间距的卡片布局管理器 3 void first(Container parent) 普通 翻转到容器的第一张卡片 4 int setHgap() 普通 设置组件之间的水平间距 5 int setVgap() 普通 设置组件之间的垂直间距 6 int getHgap() 普通 获取组件之间的水平间距 7 int getVgap() 普通 获取组件之间的垂直间距 8 float getLayoutAlignmentX(Container parent) 普通 返回沿x轴的对齐方式 9 float getLayoutAlignmentY(Container parent) 普通 返回沿y轴的对齐方式 10 void last(Container parent) 普通 翻转到容器的最后一张卡片 11 void layoutContainer(Container parent) 普通 使用此卡片布局管理器布置指定的容器 12 void next(Container parent) 普通 翻转到指定容器的下一张卡片 13 void removeLayoutComponent(Component comp) 普通 从卡片布局管理器中移除指定的组件 14 void show(Container parent,String name) 普通 显示具有指定组件名称的卡片 代码示例： 1234567891011121314151617181920212223242526272829303132333435import java.awt.CardLayout;import javax.swing.JFrame;import javax.swing.JPanel;import javax.swing.JLabel;import javax.swing.JButton;public class Test&#123; public static void main(String[] args) &#123; JFrame jf=new JFrame(&quot;CardLayout 布局管理器&quot;); CardLayout card=new CardLayout(5,5); JPanel panel=new JPanel(card); panel.add(new JLabel(&quot;第一张标签&quot;),JLabel.CENTER); panel.add(new JLabel(&quot;第二张标签&quot;),JLabel.CENTER); panel.add(new JLabel(&quot;第三张标签&quot;),JLabel.CENTER); panel.add(new JLabel(&quot;第四张标签&quot;),JLabel.CENTER); panel.add(new JLabel(&quot;第五张标签&quot;),JLabel.CENTER); jf.add(panel); jf.setSize(200,100); jf.setLocation(250,300); jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); jf.setVisible(true); for(int i=0;i&lt;5;i++) &#123; try &#123; Thread.sleep(2000); &#125;catch(Exception e) &#123; e.printStackTrace(); &#125; card.next(panel); &#125; &#125;&#125; 运行结果： ​ 以上程序展现了部分结果，可以发现，并不是按照加入的顺序显示标签的，因为在程序中使用 了 Thread.sleep()方法。 绝对定位 ​ 绝对定位使用 Component 中提供的 setBounds() 方法设置组件的位置和占用的空间，但在 GUI 程序使用的组件繁多时，绝对定位很难恰当地布置组件，在此建议使用 swing 提供的布局管理器。 代码示例： 12345678910111213141516171819202122232425262728import java.awt.Font;import java.awt.Color;import javax.swing.JButton;import javax.swing.JFrame;import javax.swing.JLabel;public class Test&#123; public static void main(String[] args) &#123; JFrame jf=new JFrame(&quot;绝对定位&quot;); JButton button1=new JButton(&quot;按钮1&quot;); JButton button2=new JButton(&quot;按钮2&quot;); JLabel label=new JLabel(&quot;标签A&quot;,JLabel.CENTER); Font font=new Font(&quot;楷体&quot;,Font.BOLD+Font.PLAIN,20); label.setFont(font); label.setForeground(Color.blue); jf.setLayout(null); //这只布局管理器为null button1.setBounds(5,40,80,30); label.setBounds(90,40,80,30); button2.setBounds(175,40,80,30); jf.add(button1); jf.add(button2); jf.add(label); jf.setSize(280,150); jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); jf.setVisible(true); &#125;&#125; 运行结果： ​ 在绝对定位时，不论窗体的大小如何改变，组件的大小和位置都是固定不变的。而使用其他的布局管理器时，若窗体大小改变，则组件的大小和位置也会改变。 参考链接： GridBagConstraints详解 - 樊聪 - 博客园 (cnblogs.com) JAVA布局模式：GridBagConstraints终极技巧_shilonggang000的专栏-CSDN博客 JAVA布局管理器_璀璨星空-CSDN博客 java布局之GridBagLayout_eskimoer的专栏-CSDN博客 参考书目： 《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"滚动面板：JScrollPane","slug":"java/GUI/滚动面板：JScrollPane","date":"2021-10-15T01:37:54.000Z","updated":"2021-10-27T04:41:42.434Z","comments":true,"path":"2021/10/15/java/GUI/滚动面板：JScrollPane/","link":"","permalink":"https://silenthly.github.io/2021/10/15/java/GUI/%E6%BB%9A%E5%8A%A8%E9%9D%A2%E6%9D%BF%EF%BC%9AJScrollPane/","excerpt":"​ 滚动面板 JScrollPane 用于显示大于可视区域或大小会自动增长的组件，例如大的图片或者可编辑的文本区域等。JSrollPane 提供了水平和垂直的滚动条，可配合 ScrollPaneLayout 设定布局，构建成需要的滚动窗口。JScrollPane 类的常用常量和方法如下表所示。","text":"​ 滚动面板 JScrollPane 用于显示大于可视区域或大小会自动增长的组件，例如大的图片或者可编辑的文本区域等。JSrollPane 提供了水平和垂直的滚动条，可配合 ScrollPaneLayout 设定布局，构建成需要的滚动窗口。JScrollPane 类的常用常量和方法如下表所示。 序号 方法 类型 说明 1 static int HORIZAONTAL_SCROLLBAR_ALWAYS 常量 始终显示水平滚动条 2 static int HORIZONTAL_SCROLLBAR_AS_NEEDED 常量 只在需要时显示水平滚动条 3 static int HORIZONTIAL_SCROLLBAR_NEVER 常量 从不显示水平滚动条 4 static int VERTICAL_SCROLLBAR_ALWAYS 常量 始终显示垂直滚动条 5 static int VERTICAL_SCROLLBAR_AS_NEEDED 常量 只在需要时显示垂直滚动条 6 static int VERTICAL_SCROLLBAR_NEVER 常量 从不显示垂直滚动条 7 JScrollPane() 构造 创建一个空的、无试图窗口的JScrollPane，需要时水平和垂直滚动条都可显示 8 JScrollPane(Component view) 构造 创建一个显示指定组件内容的JScrollPane，只要组件的内容超过视图大小就会显示水平和垂直滚动条 9 JScrollPane(component view,int vsbPolicy,int hsbPolicy) 构造 创建一个JScrollPane，它将视图组件显示在一个视口中，根据参数设置是否显示水平和垂直滚动条 10 JScrollPane(int vsbPolicy,int hsbPolicy) 构造 构造一个空的滚动面板，根据参数是否显示水平和垂直滚动条 11 void setHorizontalScrollBarPolicy(int policy) 普通 设置水平滚动条的显示策略 12 void setVerticalScrollBarPolicy(int policy) 普通 设置垂直滚动条的显示策略 代码示例： 123456789101112131415161718192021import javax.swing.ImageIcon;import javax.swing.JFrame;import javax.swing.JLabel;import javax.swing.JScrollPane;public class Test&#123; public static void main(String[] args) &#123; JFrame jf=new JFrame(&quot;JScrollPane滚动面板&quot;); ImageIcon icon=new ImageIcon(&quot;1.PNG&quot;); JLabel label=new JLabel(icon); JScrollPane panel=new JScrollPane(label); panel.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_ALWAYS); panel.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS); jf.add(panel); jf.setSize(400,300); jf.setLocation(250,350); jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); jf.setVisible(true); &#125;&#125; 运行结果： ​ 以上程序中，图片已经超过可视窗口的大小，所以只能显示一部分内容，但水平和垂直滚动条都被设置为始终显示，可以滑动滚动条查看没有被显示的内容。 参考书目： 《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"面板组件：JPanel","slug":"java/GUI/面板组件：JPanel","date":"2021-10-14T09:13:54.000Z","updated":"2021-10-27T04:41:47.682Z","comments":true,"path":"2021/10/14/java/GUI/面板组件：JPanel/","link":"","permalink":"https://silenthly.github.io/2021/10/14/java/GUI/%E9%9D%A2%E6%9D%BF%E7%BB%84%E4%BB%B6%EF%BC%9AJPanel/","excerpt":"​ JPanel 称为面板一种常用的中间容器。一般情况下，先将其他的组件添加到面板中，然后将 JPanel 添加到其他的容器中，特别是添加到顶级容器中。JPanel 是 Container 的子类，因此，JPanel 类及其子类的实例同样是一个容器也是一个组件。JPanel 类的常用方法如下表所示。","text":"​ JPanel 称为面板一种常用的中间容器。一般情况下，先将其他的组件添加到面板中，然后将 JPanel 添加到其他的容器中，特别是添加到顶级容器中。JPanel 是 Container 的子类，因此，JPanel 类及其子类的实例同样是一个容器也是一个组件。JPanel 类的常用方法如下表所示。 序号 方法 类型 说明 1 JPanel() 构造 创建具有双缓冲流和流布局的新 JPanel，双缓冲流使用更多内存空间实现快速、无闪烁的更新 2 JPanel(boolean isDoubleBuffered) 构造 创建具有FlowLayout和指定缓冲策略的新JPanel。若boolean值为true表示使用双缓冲，否则不使用 3 JPanel(LayoutManager layout) 构造 创建具有指定布局管理器的新缓冲JPanel 4 JPanel(LayoutManager layout,boolean isDoubleBuffer) 构造 创建具有指定布局管理器的新缓冲JPanel。若boolean值为true表示使用双缓冲，否则不使用 5 public Component add(Companent comp) 普通 将指定组件追加到此panel的尾部 6 public Component add(Companent comp,int index) 普通 将指定组件追加到此panel的给定位置上 7 public void setLayout(LayoutManager mgr) 普通 设置此panel的布局管理器 提示：JPanel 的默认布局管理器是 FlowLayout 代码示例： 123456789101112131415161718192021222324252627282930import java.awt.Font;import java.awt.Color;import javax.swing.JFrame;import javax.swing.JPanel;import javax.swing.JLabel;import javax.swing.JButton;public class Test&#123; public static void main(String[] args) &#123; JFrame jf=new JFrame(&quot;JPanel组件&quot;); JPanel panel=new JPanel(); JLabel label=new JLabel(&quot;在JPanel容器上&quot;,JLabel.CENTER); JButton button1=new JButton(&quot;按钮1&quot;); JButton button2=new JButton(&quot;按钮2&quot;); JButton button3=new JButton(&quot;按钮3&quot;); Font font=new Font(&quot;楷体&quot;,Font.BOLD+Font.PLAIN,15); label.setFont(font); label.setForeground(Color.blue); panel.add(label); panel.add(button1); panel.add(button2); panel.add(button3); jf.add(panel); jf.setSize(400,300); jf.setLocation(250,300); jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); jf.setVisible(true); &#125;&#125; 运行结果： ​ 由以上程序可以发现，标签租金啊和按钮组件都是以顺序的形式加入到JPanel面板中的。值得注意的是，JPanel 可以直接添加到 JFrame 容器中，因为 JPanel 本身也是容器。 参考书目： 《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"按钮组件：JButton","slug":"java/GUI/按钮组件：JButton","date":"2021-10-10T01:43:23.000Z","updated":"2021-10-27T04:41:54.223Z","comments":true,"path":"2021/10/10/java/GUI/按钮组件：JButton/","link":"","permalink":"https://silenthly.github.io/2021/10/10/java/GUI/%E6%8C%89%E9%92%AE%E7%BB%84%E4%BB%B6%EF%BC%9AJButton/","excerpt":"​ 按钮组件也是 GUI 中常用到的一种组件，使用 JButton 类可以向窗体中添加一个按钮，JButton 类的常用方法如下图所示。","text":"​ 按钮组件也是 GUI 中常用到的一种组件，使用 JButton 类可以向窗体中添加一个按钮，JButton 类的常用方法如下图所示。 序号 方法 类型 说明 1 JButton() 构造 创建不带有设置文本或图标的按钮 2 JButton(Icon icon) 构造 创建一个带图标的按钮 3 JButton(String text) 构造 创建一个带文本的按钮 4 JButton(String text,Icon icon) 构造 创建一个带初始文本和图标的按钮 5 Icon getIcon() 普通 返回默认图标 6 String getText() 普通 返回按钮的文本 7 void setMnemonic(int mnemonic) 普通 设置按钮的快捷键 8 void setIcon(Icon defaultIcon) 普通 设置按钮的默认图标 9 void setLayout(LayoutManager mgr) 普通 为此容器设置布局管理器 代码示例： 1234567891011121314151617181920import java.awt.Font;import java.awt.Color;import javax.swing.JButton;import javax.swing.JFrame;public class Test&#123; public static void main(String[] args) &#123; JFrame jf=new JFrame(&quot;文本按钮&quot;); JButton button=new JButton(&quot;按钮&quot;); Font font=new Font(&quot;楷体&quot;,Font.BOLD+Font.PLAIN,35); button.setFont(font); button.setForeground(Color.blue); jf.add(button); jf.setSize(300,200); jf.setLocation(250,300); jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); jf.setVisible(true); &#125;&#125; 运行结果： ​ 与 JLabel 一样，JButton 也可以为按钮设置图片，范例如下： 1234567891011121314151617import javax.swing.JFrame;import javax.swing.JButton;import javax.swing.ImageIcon;public class Test&#123; public static void main(String[] args) &#123; JFrame jf=new JFrame(&quot;图片按钮&quot;); ImageIcon icon=new ImageIcon(&quot;download.png&quot;); JButton button=new JButton(icon); jf.add(button); jf.pack(); //设置内容紧缩 jf.setLocation(250,300); jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); jf.setVisible(true); &#125;&#125; 运行结果： 参考书目： 《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"标签组件：JLabel","slug":"java/GUI/标签组件：JLabel","date":"2021-10-10T01:13:25.000Z","updated":"2021-10-27T04:42:02.610Z","comments":true,"path":"2021/10/10/java/GUI/标签组件：JLabel/","link":"","permalink":"https://silenthly.github.io/2021/10/10/java/GUI/%E6%A0%87%E7%AD%BE%E7%BB%84%E4%BB%B6%EF%BC%9AJLabel/","excerpt":"​ 在GUI程序中几乎每一个窗口都可以见到标签 Label 的存在。标签常用与在窗口中显示文本信息、图像作为分隔符使用。创建 Label 对象后可以通过 Container 类中的 add() 方法加入容器中，JLabel 类的常用常量和方法下表所示。","text":"​ 在GUI程序中几乎每一个窗口都可以见到标签 Label 的存在。标签常用与在窗口中显示文本信息、图像作为分隔符使用。创建 Label 对象后可以通过 Container 类中的 add() 方法加入容器中，JLabel 类的常用常量和方法下表所示。 序号 方法 类型 说明 1 static int CENTER 常量 文本/图片在Label控件中居中 2 static int LEFT 常量 文本/图片在Label控件中居左 3 static int RIGHT 常量 文本/图片在Label控件中居右 4 JLabel() 构造 创建无图像并且标题为空字符串的JLable 5 JLabel(Icon image) 构造 创建具有指定图像的JLabel实例 6 JLabel(Icon image,int horizontalAlignment) 构造 创建具有指定图像和水平对齐方式的JLabel实例 7 JLabel(String text) 构造 创建具有指定文本的JLabel实例 8 JLabel(String text,int horizontalAlignment) 构造 创建具有指定文本和水平对齐方式的JLabel实例 9 JLabel(String text,Icon image,int horizontalAlignment) 构造 创建具有指定文本、图像和水平对齐方式的JLabel实例 10 Icon getIcon() 普通 返回该标签显示的图形图像 11 String getText() 普通 返回该标签显示的文本字符串 12 public void setFont(Font font) 普通 设置标签文字内容的字体格式 13 public void setForeground(Color fg) 普通 设置标签文字内容的字体颜色 14 public void setAlignment(float alignment) 普通 设置标签的对齐方式 15 void setIcon(Icon icon) 普通 定义此标签将要显示的图标 16 void setText(String text) 普通 定义此标签将要显示的单行文本 ​ 还可以使用 Font 类设置标签的文本字体格式，只需要调用 Component 类中的 setFont() 方法即可。Font 类中常用常量和方法如下表所示。 序号 方法 类型 说明 1 static int BOLD 常量 粗体样式 2 staic int ITALIC 常量 斜体样式 3 static int PLAIN 常量 普通样式 4 Font(String name,int style,int size) 构造 根据指定名称、样式和磅值大小，创建一个新Font对象 5 static Font setFont(String nm) 构造 从系统属性列表返回一个Font对象 6 String getFontName() 普通 返回此Font的字体外观名称 7 String getName() 普通 返回此Font的逻辑名称 代码示例： 1234567891011121314151617181920import java.awt.Font;import java.awt.Color;import javax.swing.JFrame;import javax.swing.JLabel;public class Test&#123; public static void main(String[] args) &#123; JFrame jf=new JFrame(&quot;文本标签&quot;); JLabel label=new JLabel(&quot;这是一个标签&quot;,JLabel.CENTER); Font font=new Font(&quot;楷体&quot;,Font.BOLD+Font.PLAIN,35); label.setFont(font); //设置标签文字字体格式 label.setForeground(Color.blue); //设置标签文字字体颜色 jf.add(label); //向容器中添加标签 jf.setSize(400,300); jf.setLocation(250,300); jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); jf.setVisible(true); &#125;&#125; 运行结果： ​ Swing 中的标签还有一个特点就是可以放入图片，让程序外观更加美观漂亮。JLabel中提供了两种方法可以在标签中添加图片，一种是利用 JLabel 的构造方法 JLabel(Icon image)，另一种是利用 JLabel 的 setIcon(Icon icon)方法。这两种方法需要使用 ImageIcon 类将图片数据以 byte 数组的形式设置上去，ImageIcon 类常用方法如下表所示。 序号 方法 类型 说明 1 ImageIcon() 构造 创建一个未初始化的图像图标 2 ImageIcon(byte[] imageData) 构造 将保存图片信息的byte数组设置到ImageIcon中 3 ImageIcon(byte[] imageData,String description) 构造 将保存图片信息的byte数组设置到ImageIcon中。其中，参数description为图像的简明文本描述 4 ImageIcon(Image image) 构造 根据图像对象创建一个ImageIcon 5 ImageIcon(Image image,String description) 构造 根据图像创建一个ImageIcon。其中，参数法description为图像的简明文本描述 6 ImageIcon(String filename) 构造 根据指定的文件创建一个ImageIcon 7 ImageIcon(String filename,String description) 构造 根据指定的文件创建一个ImageIcon。其中，参数description为图像的简明文本描述 8 String getDescription() 普通 获得图像的描述 9 int getIconHeight() 普通 获得图标的高度 10 int getIconWidth() 普通 获得图标的宽度 11 Image getImage() 普通 返回此图标的Image 12 int getImageLoadStatus() 普通 返回图像加载操作的状态 13 void paintIcon(Component c,Graphics g,int x,int y) 普通 绘制图标 14 void setDescription(String description) 普通 设置图像的描述 15 void setImage(Image image) 普通 设置由此图标显示的图像 提示：ImageIcon 是 Icon 的实现类 代码示例： 12345678910111213141516171819202122import java.awt.Font;import java.awt.Color;import javax.swing.JLabel;import javax.swing.JFrame;import javax.swing.ImageIcon;public class Test&#123; public static void main(String[] args) &#123; JFrame jf=new JFrame(&quot;图片标签&quot;); ImageIcon icon=new ImageIcon(&quot;GUI2.PNG&quot;,&quot;GUI2&quot;); //创建ImageIcon对象，并指定图片 JLabel label=new JLabel(&quot;GUI2&quot;,icon,JLabel.CENTER); //创建标签并设置文本 Font font=new Font(&quot;楷体&quot;,Font.BOLD+Font.PLAIN,30); label.setFont(font); //设置文本字体格式 label.setForeground(Color.blue); //设置文本字体颜色 jf.add(label); //添加标签 jf.setSize(1000,1000); jf.setLocation(250,300); jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); jf.setVisible(true); &#125;&#125; 运行结果： ​ 以上程序中的图片是从文件中提取出来的，使用 ImageIcon 的构造方法 ImageIcon(Image image) 非常方便。但图片若来自一个输入流，则需要使用 ImageIcon 的另一个构造方法 ImageIcon(byte[] imageData)，范例如下。 123456789101112131415161718192021222324252627282930313233343536import java.awt.Font;import java.awt.Color;import java.io.File;import java.io.FileInputStream;import javax.swing.JLabel;import javax.swing.JFrame;import javax.swing.ImageIcon;public class Test&#123; public static void main(String[] args) &#123; File file=new File(&quot;GUI2.PNG&quot;); FileInputStream fin=null; byte b[]=new byte[(int)file.length()]; try &#123; fin=new FileInputStream(file); fin.read(b,0,(int)file.length()); fin.close(); &#125;catch(Exception e) &#123; e.printStackTrace(); &#125; JFrame jf=new JFrame(&quot;输入流图片标签&quot;); ImageIcon icon=new ImageIcon(b,&quot;GUI2&quot;); JLabel label=new JLabel(&quot;输入流中的图片&quot;,icon,JLabel.CENTER); Font font=new Font(&quot;楷体&quot;,Font.BOLD+Font.PLAIN,35); label.setFont(font); label.setForeground(Color.blue); jf.add(label); jf.setSize(700,500); jf.setLocation(250,300); jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); jf.setVisible(true); &#125;&#125; 运行结果： ​ 以上程序通过输入流来获取图片，常用于从数据库、网络中读取图片。 参考书目： 《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"基本容器：JFrame","slug":"java/GUI/基本容器：JFrame","date":"2021-10-09T09:29:14.000Z","updated":"2021-10-27T04:42:20.923Z","comments":true,"path":"2021/10/09/java/GUI/基本容器：JFrame/","link":"","permalink":"https://silenthly.github.io/2021/10/09/java/GUI/%E5%9F%BA%E6%9C%AC%E5%AE%B9%E5%99%A8%EF%BC%9AJFrame/","excerpt":"​ Swing 有4中顶层的容器，即 JFrame、JDialog、JApplet 和 JWindow ，在此优先对 JFrame 进行讲解，其他容器以后补充。使用 JFrame 类可以创建一个窗口，它是 Component 的子类，其常用常量和方法如下表所示。","text":"​ Swing 有4中顶层的容器，即 JFrame、JDialog、JApplet 和 JWindow ，在此优先对 JFrame 进行讲解，其他容器以后补充。使用 JFrame 类可以创建一个窗口，它是 Component 的子类，其常用常量和方法如下表所示。 序号 常量或方法 类型 说明 1 static int EXIT_ON_CLOSE 常量 退出应用程序后的默认窗口关闭操作 2 JFrame() 构造 创建一个初始时不可见的新窗体 3 JFrame(String title) 构造 创建一个新的、初始不可见的、具有指定标题的窗口 4 public Component add(Component comp) 普通 将指定组件追加到此容器的尾部 5 public Component add(Component comp,int index) 普通 将指定组件添加到此容器的给定位置上 6 int getDefaultCloseOperation() 普通 返回用户在此窗体上发起关闭时默认执行的操作 7 JMenuBar getJMenuBar() 普通 返回此窗体上设置的菜单栏 8 public String getTitle() 普通 获得窗体的标题。标题显示在窗体的边框中 9 public void pack() 普通 调整此窗口的大小，以合适其子组件的首选大小和布局 10 void remove(Component comp) 普通 从该容器中移除指定组件 11 void repaint(long time,int x,int y,int width,int height) 普通 在time毫秒内重绘此组件的指定矩形区域 12 public void setBackground(Color c) 普通 设置组件的背景色 13 void setDefaultCloseOperation(int Operation) 普通 设置用户在此窗体上发起close时默认执行的操作 14 void setIconImage(Image image) 普通 设置要作为此窗口图标显示的图像 15 void setJMenuBar(JMenuBar menubar) 普通 设置此窗体的菜单栏 16 public void setLocation(int x,int y) 普通 将组件移到新位置。通过此组件父级坐标空间中的x和y参数，来指定新位置的左上角 17 public void setLocation(Point p) 普通 设置组件的显示位置。通过点p来指定新位置的左上角。在父级坐标空间中给出点p 18 void setLayout(LayoutMananger manager) 普通 设置布局管理器 19 public void setSize(int width,int height) 普通 调整组件的大小为指定宽与高 20 public void setSize(Dimension d) 普通 调整组件的大小为组件d的大小 21 public void setTitle(String title) 普通 将此窗口的标题设置为指定的字符串 22 public void setVisible(boolean b) 普通 根据参数b的值显示或隐藏此窗口。若b为true，则显示，否则隐藏 ​ 在上表中使用的两个类，Dimension 类和 Point 类。Dimension 类用于设置窗体的大小，而 Point 类用于设置窗体的显示位置。Dimension 类和 Point 类的常用常量和方法如下所示。 Dimension类的常用方法 序号 方法 类型 说明 1 int height 常量 Dimension的高度，可以使用负值 2 int width 常量 Dimension的宽度，可以使用负值 3 Dimension() 构造 创建Dimension的一个示例，其宽度为0，高度为0 4 Dimension(Dimension d) 构造 创建Dimension的一个示例，大小与指定的对象d相同 5 Dimension(int width,int height) 构造 构造一个Dimension，并将其初始化为指定宽度和高度 6 double getHeight() 普通 返回此Dimension的高度 7 Dimension getSize() 普通 获得此Dimension对象的大小 8 double getWidth() 普通 返回此Dimension的宽度 9 void setSize(Dimension d) 普通 设置此Dimension对象的大小为指定大小 10 void setSize(double width,double height) 普通 设置此Dimension对象的大小为指定大小 11 void setSize(int width,int height) 普通 设置此Dimension对象的大小为指定大小 Point类的常用常量和方法 序号 方法 类型 说明 1 int x 常量 x坐标 2 int y 常量 y 坐标 3 Point() 构造 在坐标空间的原点(0,0)构造并初始化一个点 4 Point(x,y) 构造 在坐标空间中指定的(x,y)位置构造并初始化一个点 5 Point(Point p) 构造 在坐标空间中构造并初始化一个与p相同位置的点 6 Point getLocation() 普通 返回此点的位置 7 double getX() 普通 以双精度类型返回点的X坐标 8 double getY() 普通 以双精度类型返回点的y坐标 9 void move(int x,int y) 普通 将此点移动到(x,y)坐标平面中的指定位置 10 void setLocation(double x,double y) 普通 将此点的位置设置为指定的双精度坐标 11 void setLocation(int x,int y) 普通 将此点的位置更改为指定位置 12 void setLocation(Point p) 普通 将此点的位置设为指定位置 13 void translate(int dx,int dy) 普通 平移(x,y)位置的点，沿x轴平移dx，沿y轴平移dy，移动后得到点(x+dx,y+dy) ​ 根据以上的类方法创建以新的窗口，范例如下。 1234567891011121314151617181920import java.awt.Dimension;import java.awt.Point;//import java.awt.Container;import javax.swing.JFrame;//import java.awt.Color;public class Test&#123; public static void main(String[] args) &#123; JFrame jf=new JFrame(&quot;第一个窗口&quot;); //Container con=jf.getContentPane(); //con.setBackground(Color.black); Dimension d=new Dimension(400,300); Point p=new Point(250,300); jf.setLocation(p); //设置窗口的初始位置 jf.setSize(d); //设置窗口的大小 jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); //设置窗口关闭方式 jf.setVisible(true); &#125;&#125; 运行结果： ​ 以上程序创建了一个空白的窗口，其中setDefaultCloseOperation(jf.EXIT_ON_CLOSE)设置了窗口的关闭方式。若没有设置窗口的关闭方式，单击“关闭”按钮是不能真正关闭窗口的。就是说，单击关闭按钮时窗口会消失，虽然窗口不见了，但是JVM并没有退出。 参考书目： 《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Swing概述","slug":"java/GUI/Swing概述","date":"2021-10-07T07:32:42.000Z","updated":"2021-10-27T04:42:30.727Z","comments":true,"path":"2021/10/07/java/GUI/Swing概述/","link":"","permalink":"https://silenthly.github.io/2021/10/07/java/GUI/Swing%E6%A6%82%E8%BF%B0/","excerpt":"​ Swing 是 java 提供的 GUI 编程的类库，并且Swing组件是完全采用 java 语言来编写、操作和显示的，可以用来开发跨平台的 GUI 组件。使用 Swing 来开发 GUI 比 AWT更加优秀，Swing 是一组轻量级的组件，而且 Swing 除了包含 AWT 中的组件以外还提供了大量新的组件，如滚动窗口、选项版和表格等。","text":"​ Swing 是 java 提供的 GUI 编程的类库，并且Swing组件是完全采用 java 语言来编写、操作和显示的，可以用来开发跨平台的 GUI 组件。使用 Swing 来开发 GUI 比 AWT更加优秀，Swing 是一组轻量级的组件，而且 Swing 除了包含 AWT 中的组件以外还提供了大量新的组件，如滚动窗口、选项版和表格等。 认识Swing ​ Swing 包是 JDK1.2 起引入的界面设计接口。Swing 对 AWT 进行了大量的扩展，通过 Swing 可以设计出功能强大、界面优美的 GUI 程序。Swing 不但提供了很多功能完善的组件，还具有良好的扩展能力，使用 Swing 可以开发出跨平台的 GUI 程序。 ​ Swing 类库非常庞大，其功能涉及图形用户界面开发的各个方面，绝大部分相关的类都位于 java.swing 包及其子包中，Swing库中常用的包及其相关功能如下表所示。 序号 包名 功能说明 1 javax.accessibilty 定义了用户界面组件与提供这些组件进行访问的辅助技术之间的协定。该包中提供了很多具有辅助功能的类和接口，这些类和接口可以与Swing组件进行交流。注意：此包不是Swing包中的一部分，但是在Swing中应用得非常广泛 2 javax.swing 提供一组“轻量级”(全部是java语言)组件，尽量让这些组件在所有平台上的工作方式都相同 3 javax.swing.border 提供围绕Swing组件绘制特殊边框的类和接口 4 javax.swing.colorchooser 包含为JColorChooser组件使用提供支持的类和接口 5 javax.swing.event 包含了关于Swing监听器和事件处理的类和接口 6 javax.swing.filechooser 包含为JColorChooser组件使用提供支持的类和接口 7 javax.swing.plaf 包含了支持不同操作系统平台显示外观的类，其中包括了实现Metal和Multi外观风格的类，通过包中的类可以调整界面的外观风格。此包中包含多个子包，可在API帮助文档进行查阅 8 javax.swing.table 包含了为表格组件提供支持的类 9 javax.swing.text 提供了一些为文本组件使用的支持类 10 javax.swing.text.html 提供了HTMLEditorKit和创建HTML文本编辑器的支持类 11 javax.swing.text.html.parser 提供默认的HTML解析器及支持类 12 javax.swing.text.rtf 提供一个类(RTFEditorKit)，用于创建富文本格式(Rich-Text-Format)的文本编辑器 13 javax.swing.tree 包含了为树状列表组件提供支持的类 14 javax.swing.undo 允许开发人员为应用程序(例如文本编辑器)中的撤销/恢复提供支持 提示：javax中的x是Extension的缩写形式，表示java核心类的扩展包 Swing 与 AWT 的对比 ​ Swing 是在 AWT 组件的基础上构建的，也就是说 Swing 组件实际上也是 AWT 的一部分。下面介绍 Swing 与 AWT 的关系。 ​ （1）AWT 是随着早期的 JDK 一起发布的 GUI 工具包，所有的 JDK 中都包含有基本的 GUI 工具包。AWT 本身就提供了基本的组件和丰富的事件处理接口。Swing 则是在 AWT 的基础上引入的轻量级的 GUI 工具包，也就是说 AWT 是 Swing 的基础。 ​ （2）AWT 提供的组件数量非常有限，远远没有 Swing 那么丰富，如 Swing 提供的滚动窗口、选项板和表格等在 AWT 中并不存在。另外，在 AWT 中提供的都是重量级组件， 如果希望编写能在不同平台运行的程序，必须在每一个平台上单独测试，无法实现“Write Once，Run Anywhere”的跨平台特性。 ​ （3）需要说明的是 Swing 的出现并不是为了替代 AWT，只是提供更加丰富的组件， 为开发人员提供更多的选择。Swing 使用的事件处理就是 AWT 提供的。因此，在实际的程序设计中会同时使用到 Swing 和 AWT，但组件一般只使用 Swing，而很多的辅助类常常使用的却是 AWT，特别是在事件处理的开发上。 提示：AWT 提供的是重量级组件，是依赖于本地操作系统的 GUI 工具包。而 Swing 属于轻量级组件，是纯 Java 语言编写，使用基本的图形元素直接在屏幕上绘制。因此，在搭建界面时，如果将 Swing 和 AWT 同时使用，就可能会出现先后遮挡的正常现象。因为 AWT 组件是依赖本地系统对等体显示的，而 Swing 使用基本的图形元素是直接由 Java 所绘制的。所以当 AWT 与 Swing 组件重叠时，AWT 的显示优先级高，也就是说 AWT 组件总是会显示在 Swing 组件前面。建议不要将 Swing 和 AWT 组件进行混用。 ​ 前面多次强调 Swing 组件是采用纯 Java 编写的，不再调用本地操作系统的函数，所以 Swing 图形界面的组件显示速度要比 AWT 要慢一些。但相对于高速发展的硬件设备而言， 这样微小的速度差别是没有任何妨碍的。相比 AWT，Swing 组件的优势十分明显： Swing 是采用纯 Java 实现的，不依赖本地操作系统的支持，在不同的平台上运行 时可以保证具有相同的图形界面外观，具有良好的跨平台特性。 Swing 提供了更多的组件，且在 AWT 的基础上进行扩展，以“J”字母开头，如增加了很多的高级组件 JTable、JTree 等。 Swing 组件遵守 MVC（Model-View-Controlle，模式-视图-控制器）的设计模式。 将模式和视图分隔开，可以方便用户直接通过模式管理数据。 Swing 可以使用可插拔式外观感觉（Pluggable Look and Feel，PL&amp;F）来控制组件外观。开发人员可以在程序中加入相应的开关，使得用户可以根据喜好选择不同的界面。 Swing 加入了支持键盘操作。通过使用 JComponent 类中的 registerKeyboardAction() 方法，用户可以通过键盘操作代替鼠标控制 Swing 组件。 参考书目： 《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"事务处理","slug":"java/数据库/事务处理","date":"2021-10-05T08:14:45.000Z","updated":"2021-10-27T04:40:49.923Z","comments":true,"path":"2021/10/05/java/数据库/事务处理/","link":"","permalink":"https://silenthly.github.io/2021/10/05/java/%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/","excerpt":"​ 对数据库而言，事务处理都是很重要的，因为在对数据库的操作中并不能保证完全不出错。事务是保证数据库中数据的完整性和统一性的重要手段。","text":"​ 对数据库而言，事务处理都是很重要的，因为在对数据库的操作中并不能保证完全不出错。事务是保证数据库中数据的完整性和统一性的重要手段。 事务简介 ​ 在操作数据库时，经常出现这样一种情况，数据库中已经存在了一些记录。现在想要向数据库中插入数据，但数据插入一半时，系统发生了错误。此时已经有一半的数据已经成功插入数据，但还有一部分没有插入，若重新执行插入操作，很可能会引起数据库错误。这时就需要使用事务处理。 ​ 事务是SQL中单个的逻辑执行单元，可由一步或多步的数据库操作组成。一个事务内的所有语句作为整体执行，遇到错误时可以回滚事务，取消事务所作的所有改变，就是说这一系列操作要么全部执行，要么全部放弃，从而保证数据库的一致性和可恢复性。 ​ 事务一般具有以下4种特性： 原子性：一个事务必须作为一个原子单位，是最小的执行单位。它所作的数据修改要么全部执行，要么全部取消。 一致性：当事务执行结束，数据库必须从一个一致性状态，转变为另一个一致性状态。事务的一致性是需要原子性来保证的。 隔离性：一个事务所作的修改必须能够跟其他事务所作的修改是隔离的，就是说并发执行的事务之间不能知道对方的中间状态。并发执行的事务之间不能相互影响，以免在并发处理时发生数据错误。 持久性：事务执行结束后，它对数据库所作的修改被永久保存。 MySQL对事务的支持 ​ MySQL默认情况下是关闭事务，这就需要用户手动开启MySQL的事务支持。MySQL中提供的事务处理命令如下表所示。 序号 命令 描述 1 SET AUTOCOMMIT=0 取消自动提交处理，开启事务处理 2 SET AUTOCOMMIT=1 打开自动提交处理，关闭事务处理 3 START TRANSACTION 启动事务 4 BEGIN 启动事务，相当于执行START TRANSACTION 5 COMMIT 提交事务 6 ROLLBACK 回滚全部操作 7 SAVEPOINT 事务保存点名称 设置事务保存点 8 ROLLBACK TO SAVEPOINT 保存点名称 回滚操作到保存点 执行事务处理 ​ 在此删除前面的StudentUser表，新建一个StudentUser表，SQL语句如下： ​ 删除StudentUser表： 1DROP TABLE StudentUser; ​ 新建StudentUser表： 12345678CREATE TABLE StudentUser(id INT NOT NULL PRIMARY KEY,name VARCHAR(15) NOT NULL,password VARCHAR(20) NOT NULL, sex VARCHAR(2) NOT NULL,mail VARCHAR(25),college VARCHAR(15) NOT NULL)ENGINE=InnoDB; ​ 插入两条记录： 1INSERT INTO StudentUser (id,name,password,sex,mail,college) VALUES (123,&#x27;小强&#x27;,&#x27;qian&#x27;,&#x27;男&#x27;,&#x27;qiangmzsx@gmail.com&#x27;,&#x27;信通学院&#x27;),(456,&#x27;小明&#x27;,&#x27;ming&#x27;,&#x27;男&#x27;,&#x27;tonglyu@gmail.com&#x27;,&#x27;信通学院&#x27;); ​ 其中，ENGINE指定表的默认引擎为InnoDB，因为InnoDB引擎支持事务处理。下面通过一个范例来演示事务处理中的回滚功能。 代码示例：(事务处理) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.sql.ResultSet;import java.sql.PreparedStatement;public class Test&#123; public static final String DBDRIVER=&quot;com.mysql.cj.jdbc.Driver&quot;; public static final String DBURL=&quot;jdbc:mysql://localhost:3306/javaTest&quot;; public static final String DBUSER=&quot;root&quot;; public static final String DBPASSWORD=&quot;123456&quot;; private static Connection conn=null; //声明静态的Connection对象 /** 连接数据库 */ public Connection connDatebase() &#123; try &#123; Class.forName(DBDRIVER); conn=DriverManager.getConnection(DBURL,DBUSER,DBPASSWORD); &#125;catch(Exception e) &#123; System.out.println(&quot;MySQL数据库连接失败！&quot;); e.printStackTrace(); &#125; return conn; &#125; /** 使用PreparedStatement执行SQL语句 */ public void prepared() &#123; PreparedStatement perstat=null; try &#123; perstat=conn.prepareStatement(&quot;INSERT INTO StudentUser (id,name,password,sex,mail,college) VALUES (?,?,?,?,?,?)&quot;); for(int i=1;i&lt;=5;i++) &#123; perstat.setInt(1,i); perstat.setString(2,&quot;小强&quot;); perstat.setString(3,&quot;qian&quot;); perstat.setString(4,&quot;男&quot;); perstat.setString(5,&quot;qiangmzsx@gmail.com&quot;); perstat.setString(6,&quot;信通学院&quot;); perstat.executeUpdate(); //执行更新 &#125; &#125;catch(Exception e) &#123; e.printStackTrace(); &#125; &#125; /** 查询操作 */ public void query() &#123; PreparedStatement perstat=null; ResultSet res=null; String sql=&quot;SELECT id,name,password,sex,mail,college from StudentUser&quot;; try &#123; perstat=conn.prepareStatement(sql); res=perstat.executeQuery(); System.out.println(&quot;id\\tname\\tpassword\\tsex\\t\\tmail\\t\\t\\tcollege&quot;); while(res.next()) &#123; int id=res.getInt(1); String name=res.getString(2); String password=res.getString(3); String sex=res.getString(4); String mail=res.getString(5); String college=res.getString(6); System.out.println(id+&quot;\\t&quot;+name+&quot;\\t&quot;+password+&quot;\\t\\t&quot;+ sex+&quot;\\t&quot;+mail+&quot;\\t\\t&quot;+college); &#125; &#125;catch(Exception e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; try &#123; Test tra=new Test(); conn=tra.connDatebase(); conn.setAutoCommit(false); //关闭自动提交 System.out.println(&quot;数据库插入前：&quot;); tra.query(); //查询插入操作前的数据表 tra.prepared(); //执行插入操作 System.out.println(&quot;数据库插入后：&quot;); tra.query(); tra.conn.rollback(); //执行回滚操作 System.out.println(&quot;数据库回滚后：&quot;); tra.query(); conn.close(); &#125;catch(Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 运行结果： ​ 在以上程序中实现了事务的回滚操作，但有两点需要注意，第一，JDBC的事务范围仅局限于一个数据库连接，不能跨越多个数据库连接；第二，在插入操作后，若执行commit()办法提交事务，则无法再进行回滚操作，即执行rollback()方法是没有效果的。 参考书目： 《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"预处理操作:PreparedStatement接口","slug":"java/数据库/预处理操作PreparedStatement接口","date":"2021-10-02T04:21:13.000Z","updated":"2021-10-27T04:41:24.011Z","comments":true,"path":"2021/10/02/java/数据库/预处理操作PreparedStatement接口/","link":"","permalink":"https://silenthly.github.io/2021/10/02/java/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%A2%84%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9CPreparedStatement%E6%8E%A5%E5%8F%A3/","excerpt":"​ Statement接口用于向数据库发送SQL语句。在JDBC中含有3种类型的Statement对象，分别是Statement、PreparedStatement和CallableStatement。其中Statement对象用于执行静态的SQL语句，PreparedStatement对象用于执行动态的SQL语句，而CallableStatement对用于执行对数据库存储过程调用，本文介绍PreparedStatement接口的应用。","text":"​ Statement接口用于向数据库发送SQL语句。在JDBC中含有3种类型的Statement对象，分别是Statement、PreparedStatement和CallableStatement。其中Statement对象用于执行静态的SQL语句，PreparedStatement对象用于执行动态的SQL语句，而CallableStatement对用于执行对数据库存储过程调用，本文介绍PreparedStatement接口的应用。 PreparedStatement接口 ​ PreparedStatement接口的定义如下： 1public interface PreparedStatement extends Statement ​ PreparedStatement继承了Statement接口，可以完成Statement所有的功能，用于执行动态的SQL语句，即包含参数的SQL语句。 ​ 数据库在执行SQL语句的时候如果使用PreparedStatement语句会有一点优势：因为数据库会对PreparedStatement语句进行预编译，下次执行相同的SQL语句时，数据库端不会再进行预编译了，而是直接使用数据库的缓冲区，提高数据访问的效率（但尽量尽量采用使用？号的方式传递参数），如果SQL语句只执行一次，以后不再复用。PreparedStatement的常用方法如下表所示。 序号 方法 类型 说明 1 public boolean execute()throws SQLException 普通 执行任意的SQL语句 2 public ResultSet executeQuery()throws Exception 普通 执行给定的SQL查询语句，该语句返回单个ResultSet对象 3 public int executeUpdate()throws Exception 普通 执行给定的INSERT、UPDATE和DELETE的SQL语句，返回更新记录数 4 public void setLong(int parameterIndex,long x)throws Exception 普通 将指定索引设置为给定的long值，可重写为其他基本类型及Time，Timestamp型 提示：在程序开发中，大多数情况下都会使用PreparedStatement替代Statement。因为使用PreparedStatement可以提高代码的可读性和可维护性，同时也尽可能地提高程序的运行效率，最重要的是增强了安全性。 使用PreparedStatement对数据库进行操作 ​ 下面通过插入操作比较 Statement 和 PreparedStatement 的执行效率。分别向StudentUser表插入50条记录，使用Statement则需要传入50条插入语句，而PreparedStatement只需要传入一条SQL插入语句，然后再为PreparedStatement的参数设置即可。 代码示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.sql.Statement;import java.sql.PreparedStatement;public class Test&#123; public static final String DBDRIVER=&quot;com.mysql.cj.jdbc.Driver&quot;; public static final String DBURL=&quot;jdbc:mysql://localhost:3306/javaTest&quot;; public static final String DBUSER=&quot;root&quot;; public static final String DBPASSWORD=&quot;ren74520&quot;; /** 连接数据库 */ public Connection connDatebase() &#123; Connection con=null; try &#123; Class.forName(DBDRIVER); con=DriverManager.getConnection(DBURL,DBUSER,DBPASSWORD); &#125;catch(Exception e) &#123; System.out.println(&quot;MySQL数据库连接失败！&quot;); e.printStackTrace(); &#125; return con; &#125; /** 使用Statement实例执行SQL语句 */ public void statement() &#123; Connection conn=null; Statement stat=null; try &#123; conn=connDatebase(); stat=conn.createStatement(); long start=System.currentTimeMillis(); for(int i=1;i&lt;=50;i++) &#123; stat.executeUpdate(&quot;INSERT INTO StudentUser (id,name,password,sex,mail,college) VALUES (&quot;+i+&quot;,&#x27;姓名&#x27;,&#x27;密码&#x27;,&#x27;性别&#x27;,&#x27;邮箱&#x27;,&#x27;学院&#x27;)&quot;); &#125; System.out.println(&quot;使用Statement插入耗时：&quot;+(System.currentTimeMillis()-start)); &#125;catch(SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; conn.close(); &#125;catch(SQLException e) &#123; System.out.println(&quot;MySQL数据库关闭失败！&quot;); e.printStackTrace(); &#125; &#125; &#125; /** 使用PreparedStatement示例执行SQL语句 */ public void prepared() &#123; Connection conn=null; PreparedStatement perstat=null; try &#123; conn=connDatebase(); perstat=conn.prepareStatement(&quot;INSERT INTO StudentUser (id,name,password,sex,mail,college) VALUES(?,&#x27;姓名&#x27;,&#x27;密码&#x27;,&#x27;性别&#x27;,&#x27;邮箱&#x27;,&#x27;学院&#x27;)&quot;); long start=System.currentTimeMillis(); for(int i=51;i&lt;=100;i++) &#123; perstat.setInt(1,i); perstat.executeUpdate(); &#125; System.out.println(&quot;使用PreparedStatement插入耗时：&quot;+(System.currentTimeMillis()-start)); &#125;catch(SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; conn.close(); &#125;catch(SQLException e) &#123; System.out.println(&quot;MySQL数据库关闭失败！&quot;); e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) &#123; Test per=new Test(); per.statement(); per.prepared(); &#125;&#125; ​ 运行结果如图所示： ​ 从程序运行结果可以发现，使用 PrepareStatement 消耗的时间反而比使用 Statement 消耗的时间要长，这是为什么呢？通过查找资料发现，PreparedStatement并不是绝对提高性能的，可以参考下方信息。 对于Oracle（非常肯定，实践证明+测试结果表明）和PostgreSQL8（较肯定），使用PreparedStatement时，性能更高； 对于MySQL（非常肯定，测试结果表明），使用PreparedStatement时，性能反而低。 ​ 使用 Statement 时，执行的 SQL 语句需要拼接而成，容易产生错误，而使用 PreparedStatement 则不需要拼接 SQL 语句， 使用“?”进行占位。 参考链接：PreparedStatement真的比Statement快吗？_kang的专栏-CSDN博客 参考书目： 《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"事务处理","slug":"java/GUI/事务处理(GUI)","date":"2021-10-01T07:01:41.000Z","updated":"2021-10-27T04:41:36.863Z","comments":true,"path":"2021/10/01/java/GUI/事务处理(GUI)/","link":"","permalink":"https://silenthly.github.io/2021/10/01/java/GUI/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86(GUI)/","excerpt":"​ 前面介绍了多个 GUI 常用的组件和布局管理器，但是这些组件还不能响应用户的任何操作，如单击按钮没有任何响应。如果不对组件产生的事件进行处理，那么界面将不具有相应的功能，这样的 GUI 程序也没有多大意义。Java 语言为图形用户界面响应用户操作提供了相应的事件处理。","text":"​ 前面介绍了多个 GUI 常用的组件和布局管理器，但是这些组件还不能响应用户的任何操作，如单击按钮没有任何响应。如果不对组件产生的事件进行处理，那么界面将不具有相应的功能，这样的 GUI 程序也没有多大意义。Java 语言为图形用户界面响应用户操作提供了相应的事件处理。 事务处理的基本概念 ​ Java 的事件处理采用了委托事件模式（Delegation Event Model）是指 GUI 组件将整个事件处理委托一个或多个事件监听器来处理。就是说当事件源发生指定的事件时，就通知所委托的事件监听器来处理该事件。 ​ 委托事件模式主要涉及3部分：事件、事件源和事件监听器。 事件是指一个描述事件源状态改变的对象，它作为用户对界面操作在 Java 语言上的描述。例如，按下按钮时，实际上这个按钮的状态就发生了改变，就会产生一个事件。 事件源是指产生事件的对象，通常就是各个组件。每当这些组件内部的状态发生改变时，事件就会产生。值得注意的是，一个事件源一次可以不止产生一个事件。 事件监听器是指在事件发生时被通知的对象，其中定义了当被监听的事件发生时系统要调用的方法。一个事件源必须注册监听器，以便监听器接收特定事件的通知。每一种事件都有各自的组成方法，一般形式如下： 1public void addTypeListener(TypeListener) ​ 用于接收和处理事件的方法在 java.awt.event 中被定义为一系列的接口。最底层的监听器都是以接口的形式提供的，而一个接口中往往提供多个抽象方法，为了避免重复实现这些方法，系统提供了对这些方法实现的类，这些类就被称为适配器。 提示：事件也可能不是用户直接触发的，可能是一个操作完成后而产生。 ​ swing 编程中依旧使用 AWT 的事件处理方式，所有的事件都是 EventObject 的子类。这些事件监听器的接口大多定义在 java.awt.event 中，它们如下表所示。 序号 接口 说明 1 ActionListener 用于接收操作事件的监视器接口，也就是用户对组件的操作，例如处理用户单击按钮时触发的事件 2 AdjustmentListenr 用于接收调整事件的监听器接口，例如用户滑动滚动条触发的事件 3 FocusListenr 用于接收组件上键盘焦点事件的监听器接口，例如将当前事件的焦点转移到某个对话框时使用 4 InputMethodListener 接收输入方法事件的监听器接口。文本编辑组件必须安装输入方法事件监听器，以使用输入法 5 ItemListener 用于处理选项事件的监听器接口，例如用户单击复选框时，处理相应的事件 6 KeyListener 用于接收**键盘事件(击键)**的监听器接口。例如接收用户键盘输入信息时，处理用户的触击键盘事件 7 MouseListener 用于处理鼠标事件(按下、释放、单击、进入或离开)的监听器接口 8 MouseMotionListener 用于处理鼠标移动事件的监听器接口 9 WindowListener 用于处理窗口事件的监听器接口，例如单击对话框上的最大化、最小化以及关闭等事件的实现 窗体事件 ​ WindowListener 是用于处理窗口事件的监听器接口，对窗体的所有变化，包括窗口的最大化、最小化以及关闭等事件进行监听。WindowListener 接口的方法如下表所示。 序号 方法 类型 说明 1 void windowActicated(WindowEvent e) 普通 将窗口设置为活跃时触发 2 void windowClosed(WindowEvent e) 普通 将窗口关闭时触发 3 void windowClosing(WindowEvent e) 普通 窗口正在关闭时触发 4 void windowDeactivated(WindowEvent e) 普通 将窗口设置为非活跃时触发 5 void windowDeiconified(WindowEvent e) 普通 将窗口从最小化状态变为活动时触发 6 void windowIconified(WindowEvent e) 普通 将窗口设置为最小化时触发 7 void windowOpened(WindowEvent e) 普通 将窗口打开时触发 代码示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import java.awt.Point;import java.awt.Dimension;import java.awt.event.WindowListener;import java.awt.event.WindowEvent;import javax.swing.JFrame;class WindowListenerClass implements WindowListener&#123; public void windowOpened(WindowEvent e) &#123; System.out.println(&quot;窗口被打开.....&quot;); &#125; public void windowClosing(WindowEvent e) &#123; System.out.println(&quot;窗口将要被关闭.....&quot;); &#125; public void windowClosed(WindowEvent e) &#123; System.out.println(&quot;窗口被关闭.....&quot;); &#125; public void windowIconified(WindowEvent e) &#123; System.out.println(&quot;窗口被最小化......&quot;); &#125; public void windowDeiconified(WindowEvent e) &#123; System.out.println(&quot;窗口被激活.....&quot;); &#125; public void windowActivated(WindowEvent e) &#123; System.out.println(&quot;窗口处于活动状态.....&quot;); &#125; public void windowDeactivated(WindowEvent e) &#123; System.out.println(&quot;窗口处于非活动状态.....&quot;); &#125;&#125;public class Test&#123; public static void main(String[] age) &#123; JFrame jf=new JFrame(&quot;窗口事件&quot;); Dimension d=new Dimension(400,300); Point p=new Point(250,300); jf.setSize(d); jf.setLocation(p); jf.addWindowListener(new WindowListenerClass()); //添加窗口事件监听器 jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); jf.setVisible(true); &#125;&#125; 运行结果： ​ 以上程序实现了对窗口事件的监听，但是需要程序实现 WindowListener 接口中的所有方法，这无疑会增加劳动量。若只需要对窗口的最小化事件进行监听，并不需要监听其他的事件，那么直接使用监听接口是不合适的。为此 java 提供了各个事件的适配器，在实现类和接口之间增加一个过渡的抽象类，子类可以根据自身的需求实现事件处理中的方法。Window 事件的适配器是 WindowAdapter，子类只需要继承该类并覆写自己需要的方法即可。 代码示例： 1234567891011121314151617181920212223import java.awt.event.WindowListener;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;import javax.swing.JFrame;class windowAdapterClass extends WindowAdapter&#123; public void windowIconified(WindowEvent e) &#123; System.out.println(&quot;窗口被最小化.....&quot;); &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; JFrame jf=new JFrame(&quot;窗口事件&quot;); jf.setSize(400,300); jf.setLocation(250,300); jf.addWindowListener(new windowAdapterClass()); jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); jf.setVisible(true); &#125;&#125; 运行结果： ​ 除此之外，还可以使用匿名类来完成监听操作，这样有利于减少代码量增强代码的可读性。 代码示例： 123456789101112131415161718192021import java.awt.event.WindowListener;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;import javax.swing.JFrame;public class Test&#123; public static void main(String[] args) &#123; JFrame jf=new JFrame(&quot;窗口事件&quot;); jf.setSize(400,300); jf.setLocation(250,300); jf.addWindowListener(new WindowAdapter()&#123; public void windowIconified(WindowEvent e) &#123; System.out.println(&quot;窗口被最小化.....&quot;); &#125; &#125;); jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); jf.setVisible(true); &#125;&#125; 运行结果： ​ 在以上程序中使用匿名类进行适配器的操作，可以减少监听类，这是在程序设计中最常用的方法。 键盘事件 ​ 当用户按下或松开键盘上的按键时，就会产生一个键盘事件。在 Swing 编程中，可以使用 KeyListener 接口对键盘的操作进行监听。KeyListener 接口提供了用于处理键盘事件的方法，在键盘事件被触发时，会产生一个 KeyEvent 事件对象。KeyEvent 负责捕获键盘事件，可以通过 getKeyCode() 方法获取按下的是键盘上的哪个按键。KeyListener 接口的方法如下表所示。 序号 方法 类型 说明 1 void keyPressed(KeyEvent e) 普通 在键盘上的按键被按下使调用此方法 2 void keyReleased(KeyEvent e) 普通 在键盘上的按键被释放时调用此方法 3 void keyTyped(KeyEvent e) 普通 在按下键盘上的按键输入一个字符时调用此方法 ​ 在 KeyLisiener 接口中的每一个方法都传入 KeyEvent 对象，KeyEvent 类的常用方法如下表所示。 序号 方法 类型 说明 1 char getKeyChar() 普通 返回此事件中的键关联的字符 2 int getKeyCode() 普通 返回此事件中的键关联的整数keyCode 3 int getLocation() 普通 返回产生此按键事件的键位置 4 static String getKeyModifiersText(int modifiers) 静态 返回描述修改键的String，如Shift或Ctrl+Shift 5 static String getKeyText(int keyCode) 静态 返回描述 KeyCode 的String，如HOME、F1或A 6 boolean isActionKey() 普通 返回此事件中的键是否为&quot;动作&quot;键 7 String paremString() 普通 返回标识此事件的参数字符串 8 void setKeyChar(char keyChar) 普通 设置keyChar值，以表示某个逻辑字符 9 void setKeyCode(int keyCode) 普通 设置keyCode值，以表示某个物理按键 代码示例： 12345678910111213141516171819202122232425262728import java.awt.event.KeyEvent;import java.awt.event.KeyAdapter;import javax.swing.JFrame;import javax.swing.JTextArea;import javax.swing.JScrollPane;public class Test&#123; JTextArea text=new JTextArea(5,20); public Test() &#123; JFrame jf=new JFrame(&quot;键盘事件&quot;); JScrollPane scroll=new JScrollPane(text); jf.add(scroll); jf.setSize(400,300); jf.setLocation(250,300); text.addKeyListener(new KeyAdapter()&#123; public void keyTyped(KeyEvent e)&#123; text.append(&quot;\\n 按下的按键为：&quot;+e.getKeyChar()+&quot;\\n&quot;); &#125; &#125;); jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); jf.setVisible(true); &#125; public static void main(String[] args) &#123; new Test(); &#125;&#125; 运行结果： 行为事件 ​ ActionListener 接口用于处理行为事件，也就是用户对组件的操作，如 ActionListener 接口可以处理按钮的行为事件。ActionListener 接口中只有一个方法如下表所示。 序号 方法 类型 说明 1 void actionPerformed(ActionEvent e) 普通 发生操作时调用 代码示例： 1234567891011121314151617181920212223242526272829303132333435import java.awt.event.ActionListener;import java.awt.event.ActionEvent;import java.awt.Font;import java.awt.GridLayout;import java.awt.Color;import javax.swing.JLabel;import javax.swing.JFrame;import javax.swing.JButton;public class Test&#123; private static int count=0; public static void main(String[] args) &#123; JFrame jf=new JFrame(&quot;行为事件&quot;); JButton button=new JButton(&quot;按钮事件源&quot;); Font font=new Font(&quot;楷体&quot;,Font.BOLD+Font.PLAIN,20); JLabel label=new JLabel(&quot;没有按下按钮&quot;,JLabel.CENTER); label.setFont(font); label.setForeground(Color.red); jf.setLayout(new GridLayout(2,1,3,3)); button.addActionListener(new ActionListener()&#123; public void actionPerformed(ActionEvent e) &#123; count++; label.setText(&quot;第&quot;+count+&quot;次按下按钮！&quot;); &#125; &#125;); jf.add(label); jf.add(button); jf.setSize(400,300); jf.setLocation(250,300); jf.setDefaultCloseOperation(jf.EXIT_ON_CLOSE); jf.setVisible(true); &#125;&#125; 运行结果： ​ 以上程序中，在按下按钮后标签中的文字就会改变。 参考书目： 《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"接收操作数据库结果","slug":"java/数据库/接收操作数据库结果","date":"2021-10-01T00:32:55.000Z","updated":"2021-10-27T04:41:29.836Z","comments":true,"path":"2021/10/01/java/数据库/接收操作数据库结果/","link":"","permalink":"https://silenthly.github.io/2021/10/01/java/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%8E%A5%E6%94%B6%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%93%E6%9E%9C/","excerpt":"​ 数据库操作中使用最多的就是查询操作。java程序对数据库进行查询操作时，需要利用SQL语句中的SELECT命令查询得到结果，然后将结果放在一个ResultSet集中，再遍历这个集合，就可以做关于此查询的操作。","text":"​ 数据库操作中使用最多的就是查询操作。java程序对数据库进行查询操作时，需要利用SQL语句中的SELECT命令查询得到结果，然后将结果放在一个ResultSet集中，再遍历这个集合，就可以做关于此查询的操作。 查询数据 ​ 为了能更清楚地讲解数据库的查询操作，我们先向 StudentUser 表中添加多条记录，其 SQL 语句如下： 123456INSERT INTO StudentUser (id,name,password,sex,mail,college) VALUES (12,&#x27;小明&#x27;,&#x27;ming&#x27;,&#x27;男&#x27;,&#x27;ming@mail.com&#x27;,&#x27;海运学院&#x27;),(34,&#x27;小婷&#x27;,&#x27;ting&#x27;,&#x27;女&#x27;,&#x27;tingx@cumt.edu.cn&#x27;,&#x27;外语学院&#x27;), (56,&#x27;小华&#x27;,&#x27;hua&#x27;,&#x27;男&#x27;,&#x27;huaql@gmail.com&#x27;,&#x27;信通学院&#x27;), (78,&#x27;小琴&#x27;,&#x27;xiaoqin&#x27;,&#x27;女&#x27;,&#x27;567890@uu.com&#x27;,&#x27;外语学院&#x27;), (90,&#x27;晓同&#x27;,&#x27;tong&#x27;,&#x27;男&#x27;,&#x27;tonglx@gmail.com&#x27;,&#x27;信通学院&#x27;); ​ 执行上面的 SQL 语句后，查看 MySQL 数据库中的 StudentUser 表，得到如图1所示的结果。 图1 ​ 数据库的查询操作使用的是 Statement 接口的 executeQuery()方法，该方法返回的是 ResultSet 实例，此实例中存放了所有的查询结果，再通过 ResultSet 接口的 next()方法将查询的结果一条条地输出。next()方法返回的boolean值，当指针移动最后一行时就会返回false。 下面通过一个范例实现将 StudentUser 表中的全部数据显示在控制台上。 代码示例：(顺序查询) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.sql.Statement;import java.sql.ResultSet;public class Test&#123; public static final String DBDRIVER=&quot;com.mysql.cj.jdbc.Driver&quot;; public static final String DBURL=&quot;jdbc:mysql://localhost:3306/javaTest&quot;; public static final String DBUSER=&quot;root&quot;; public static final String DBPASSWORD=&quot;ren74520&quot;; public static void main(String[] args) &#123; Connection conn=null; Statement stat=null; ResultSet res=null; int count=0; String sql=&quot;SELECT id,name,password,sex,mail,college FROM StudentUser&quot;; try &#123; Class.forName(DBDRIVER); System.out.println(&quot;JDBC加载成功！&quot;); &#125;catch(Exception e) &#123; System.out.println(&quot;JDBC加载失败！&quot;); e.printStackTrace(); &#125; try &#123; conn=DriverManager.getConnection(DBURL,DBUSER,DBPASSWORD); stat=conn.createStatement(); res=stat.executeQuery(sql); System.out.println(&quot;id\\tname\\tpassword\\tsex\\t\\tmail\\t\\t\\tcollege&quot;); while(res.next()) &#123; count++; int id=res.getInt(1); String name=res.getString(2); String password=res.getString(3); String sex=res.getString(4); String mail=res.getString(5); String college=res.getString(6); System.out.println(id+&quot;\\t&quot;+name+&quot;\\t&quot;+password+&quot;\\t\\t&quot;+ sex+&quot;\\t&quot;+mail+&quot;\\t\\t&quot;+college); &#125; System.out.println(&quot;\\n 此次查询的结果集中的数目：&quot;+count+&quot;条&quot;); &#125;catch(Exception e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; conn.close(); System.out.println(&quot;数据库关闭成功！&quot;); &#125;catch(Exception e) &#123; System.out.println(&quot;数据库关闭失败！&quot;); e.printStackTrace(); &#125; &#125; &#125;&#125; 运行结果如图2所示： 图2 ​ 在以上程序中，先用 SQL 语句查询并获取一个结果集，然后遍历这个结果集，将其记录输出到屏幕。这个结果集由 ResultSet 实例接收并保存在内存之中。除了上面以顺序编码的形式将内容读取出来，还可以在读取数据时输入列的名称，如下所示。 12345678910111213while(res.next())&#123; count++; int id=res.getInt(&quot;id&quot;); String name=res.getString(&quot;name&quot;); String password=res.getString(&quot;password&quot;); String sex=res.getString(&quot;sex&quot;); String mail=res.getString(&quot;mail&quot;); String college=res.getString(&quot;college&quot;); System.out.println(id+&quot;\\t&quot;+name+&quot;\\t&quot;+password+&quot;\\t\\t&quot;+ sex+&quot;\\t&quot;+mail+&quot;\\t\\t&quot;+college); &#125; 以上程序的 SQL 查询语句虽然可以写成“SELECT * FROM StudentUser;”，但笔 者不推荐在程序开发中这么使用，最好是明确写出需要查询的列。 牛刀小试 比较 Statement 接口中的 execute()、executeQuery()和 executeUpdate()方法。 答：execute()方法用于执行返回多个结果集、多个更新计数或二者相结合的语句。executeQuery()产生一个结果集的语句，常用于执行 SELECT 命令的 SQL 语句。executeUpdate()方法用于执行 INSERT、UPDATE、DELETE 语句和 SQL 语言的 DDL 语句。executeUpdate()方法返回的是一个整型，表示受影响的记录数。对于 CREATE TABLE 和 DROP TABLE 等不操作记录的语句，返回值为 0。 参考书目： 《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"JAVA对数据库的更新操作","slug":"java/数据库/JAVA对数据库的更新操作","date":"2021-09-30T15:54:11.000Z","updated":"2021-10-27T04:41:04.761Z","comments":true,"path":"2021/09/30/java/数据库/JAVA对数据库的更新操作/","link":"","permalink":"https://silenthly.github.io/2021/09/30/java/%E6%95%B0%E6%8D%AE%E5%BA%93/JAVA%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%9B%B4%E6%96%B0%E6%93%8D%E4%BD%9C/","excerpt":"​ 获得数据库的连接后，程序就可以操作数据库了，本节将介绍数据库的数据更新操作，这就需要将SQL语句传入Statement对象中，再执行executeUpdate()方法即可。","text":"​ 获得数据库的连接后，程序就可以操作数据库了，本节将介绍数据库的数据更新操作，这就需要将SQL语句传入Statement对象中，再执行executeUpdate()方法即可。 执行数据库插入操作 ​ 数据库的更新操作需要对数据表进行操作，为此先建立一个StudentUser表，其SQL语句如下。 12345678CREATE TABLE StudentUser( id INT NOT NULL PRIMARY KEY, name VARCHAR(15) NOT NULL, password VARCHAR(20) NOT NULL, sex VARCHAR(2) NOT NULL, mail VARCHAR(25), college VARCHAR(15) NOT NULL); 执行以下命令查看表结构： 1DESC 表名; StudentUser表结构如图： 图1 ​ 由于插入表的信息中含有中文字符，因此在执行插入语句前先把表中所有属性的编码更改为UTF-8，表自身的编码可改可不改。 1ALTER TABLE StudentUser CONVERT TO CHARACTER SET utf8; ​ 下面通过java程序向StudentUser表中插入一条新的记录，其中的SQL语句为： 1INSERT INTO StudentUser (id,name,password,sex,mail,college) values (123456,&#x27;小明&#x27;,&#x27;ming&#x27;,&#x27;男&#x27;,&#x27;ming@mail.com&#x27;,&#x27;麻省理工&#x27;); 代码示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.sql.Statement;public class Test&#123; public static void main(String[] args) &#123; Connection conn=null; Statement stat=null; String sql=&quot;INSERT INTO StudentUser (id,name,password,sex,mail,college) values (123456,&#x27;小明&#x27;,&#x27;ming&#x27;,&#x27;男&#x27;,&#x27;ming@mail.com&#x27;,&#x27;麻省理工&#x27;)&quot;; try &#123; Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); //加载JDBC System.out.println(&quot;JDBC加载成功！&quot;); &#125;catch(Exception e) &#123; System.out.println(&quot;JDBC加载失败&quot;); e.printStackTrace(); &#125; try &#123; conn=DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/javaTest&quot;,&quot;root&quot;,&quot;123456&quot;); System.out.println(&quot;MySQL数据库连接成功！&quot;); stat=conn.createStatement(); stat.executeUpdate(sql); System.out.println(&quot;数据插入成功！&quot;); &#125;catch(Exception e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; conn.close(); System.out.println(&quot;数据库关闭成功！&quot;); &#125;catch(Exception e) &#123; System.out.println(&quot;数据库关闭失败！&quot;); e.printStackTrace(); &#125; &#125; &#125;&#125; 运行结果： 12345Loading class `com.mysql.cj.jdbc.Driver&#x27;. This is deprecated. The new driver class is `com.mysql.cj.jdbc.Driver&#x27;. The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary.JDBC加载成功！MySQL数据库连接成功！数据插入成功！数据库关闭成功！ ​ 程序结果如上所示，执行完或查看MySQL数据库中的StudentUser表，得到如图2所示结果。 图2 修改数据 ​ 使用SQL语句的UPDATE命令可以修改数据表中的数据，范例如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.sql.Statement;public class Test&#123; public static void main(String[] args) &#123; Connection conn=null; Statement stat=null; String sql=&quot;UPDATE StudentUser SET College=&#x27;清华大学&#x27; WHERE id=123456;&quot;; try &#123; Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); System.out.println(&quot;JDBC加载成功！&quot;); &#125;catch(Exception e) &#123; System.out.println(&quot;JDBC加载失败&quot;); e.printStackTrace(); &#125; try &#123; conn=DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/javatest&quot;,&quot;root&quot;,&quot;123456&quot;); System.out.println(&quot;数据库连接成功！&quot;); stat=conn.createStatement(); stat.executeUpdate(sql); System.out.println(&quot;数据修改成功！&quot;); &#125;catch(Exception e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; conn.close(); System.out.println(&quot;数据库关闭成功&quot;); &#125;catch(Exception e) &#123; System.out.println(&quot;数据库关闭失败&quot;); e.printStackTrace(); &#125; &#125; &#125;&#125; ​ 以上程序执行完或查看MySQL数据库中的StudentUser表，得到如图3所示结果。 图3 执行数据库删除操作 ​ 数据库只要执行SQL语句中的DELETE命令，即可完成记录的删除操作。在程序设计中，一般将驱动程序、数据库URL甚至用户名和密码设置成public static final属性。 代码示例：(删除数据) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.sql.Statement;import java.util.Scanner;public class Test&#123; public static final String DBDRIVER=&quot;com.mysql.cj.jdbc.Driver&quot;; public static final String DBURL=&quot;jdbc:mysql://localhost:3306/javatest&quot;; public static final String DBUSER=&quot;root&quot;; public static final String DBPASSWORD=&quot;123456&quot;; public static void main(String[] args) &#123; Scanner scan=new Scanner(System.in); System.out.println(&quot;请输入要删除的账号：&quot;); int id=scan.nextInt(); Connection conn=null; Statement stat=null; String sql=&quot;DELETE FROM StudentUser WHERE id=id&quot;; try &#123; Class.forName(DBDRIVER); System.out.println(&quot;JDBC加载成功！&quot;); &#125;catch(Exception e) &#123; System.out.println(&quot;JDBC加载失败！&quot;); e.printStackTrace(); &#125; try &#123; conn=DriverManager.getConnection(DBURL,DBUSER,DBPASSWORD); System.out.println(&quot;数据库连接成功！&quot;); stat=conn.createStatement(); stat.executeUpdate(sql); System.out.println(&quot;数据删除成功&quot;); &#125;catch(Exception e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; conn.close(); System.out.println(&quot;数据库关闭成功！&quot;); &#125;catch(Exception e) &#123; System.out.println(&quot;数据库关闭失败！&quot;); e.printStackTrace(); &#125; &#125; &#125;&#125; ​ 以上程序执行完或查看MySQL数据库中的StudentUser表，得到以下结果： 1Empty set (0.00 sec) 参考书目： 《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"连接数据库","slug":"java/数据库/数据库的连接","date":"2021-09-30T00:34:34.000Z","updated":"2021-10-27T04:40:58.430Z","comments":true,"path":"2021/09/30/java/数据库/数据库的连接/","link":"","permalink":"https://silenthly.github.io/2021/09/30/java/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%BF%9E%E6%8E%A5/","excerpt":"配置MySQL数据库的驱动程序 ​ 在连接之前首先需要下载连接MySQL数据库的JDBC驱动程序。可以到MySQL的官方网站下载相应的JDBC驱动程序，网址为：MySQL :: Download Connector/J，下载流程如下列图示，本文下载的是mysql-connector-java-8.0.26.zip。","text":"配置MySQL数据库的驱动程序 ​ 在连接之前首先需要下载连接MySQL数据库的JDBC驱动程序。可以到MySQL的官方网站下载相应的JDBC驱动程序，网址为：MySQL :: Download Connector/J，下载流程如下列图示，本文下载的是mysql-connector-java-8.0.26.zip。 图1 图2 图3 提示：在图 3 页面中，有两个 JDBC 文件，一个是 mysql-connector-java-5.1.22.tar.gz， 一个是 mysql-connector-java-5.1.22.zip。前者用于 Linux 操作系统，而后者用于 Windows 操作系统。这些文件中都含有驱动程序的源代码、文档和 jar 文件，源代码可以由用于自己编译，jar 文件名为 mysql-connector-java-5.1.22-bin.jar。 ​ 下载完成后，需要对其进行配置，才能建立连接。现在假定将MySQL数据库的JDBC驱动程序保存到C:\\Program Files\\MySQL\\MySQL Server 5.7\\mysql-connector-java-8.0.26.jar 路径中（这里的路径并不唯一，可以任意存放，这里为了方便放在MySQL的文件夹下，但需明确存放的路径），再将该路径配置到CLASSPATH中（可以参考win10的环境配置），如下图所示。 图4 JDBC连接数据库步骤 ​ MySQL数据库的驱动程序配置完成后，即可按照以下的步骤进行MySQL数据库的连接和操作。 （1）加载JDBC驱动程序 ​ 可以使用以下方法： 1Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); 或 1Class.forName(&quot;org.git.mm.mysql.Driver&quot;); 提示：org.gjt.mm.mysql.Driver 是 MySQL 数据库早期的驱动名称，后来改为了 com.mysql.cj.jdbc.Driver，推荐使用后者。在新的版本中，为了兼容前期的版本， 仍然保留在 org.gjt.mm.mysql.Driver，实际上没有功能上的差异。另网上可以经常看到驱动的名称为com.mysql.jdbc.Driver，这也是早期的驱动名称，现已废弃。 （2）建立连接 ​ 加载了驱动程序后，就可以建立连接了。这需要使用java.sql包中的Connection类来声明一个对象，再使用类DriverManager的静态方法getConnection()创建连接对象。方法如下： 1Connection conn=DriverManager.getConnection(url,userName,passWord); ​ 其中，url指定要连接的数据库名，一般形式为&quot;jdbc:mysql://数据库主机名/数据库名&quot;；userName表示数据库用户名；passWord表示与用户名相对应的密码。 提示：此处的数据库可以是本地数据库，也可以是远程数据库。 （3）使用SQL语句进行数据库操作。 ​ 数据库的操作主要分为数据更新和数据查询。 （4）释放资源 ​ 数据库操作完成后，还需要关闭数据库连接以释放资源。方法如下： 1conn.close(); ​ 一般将释放资源的操作放在finally语句块中。 123456789101112131415161718192021222324252627282930313233343536373839import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;public class Test&#123; public static void main(String[] args) &#123; Connection conn=null; try &#123; Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); //加载JDBC驱动 System.out.println(&quot;JDBC加载成功！！！&quot;); &#125;catch(Exception e) &#123; System.out.println(&quot;MySQL数据库的JDBC加载失败！！！！&quot;); e.printStackTrace(); &#125; try &#123; conn=DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/javatest&quot;,&quot;root&quot;,&quot;123456&quot;); //创建与数据库的连接 System.out.println(&quot;MySQL数据库连接成功！！！&quot;); &#125;catch(Exception e) &#123; System.out.println(&quot;MySQL数据库连接失败！！！！&quot;); e.printStackTrace(); &#125;finally &#123; try &#123; conn.close(); System.out.println(&quot;MySQL数据库关闭成功！！！&quot;); &#125;catch(Exception e) &#123; System.out.println(&quot;MySQL数据库关闭失败！！！！&quot;); e.printStackTrace(); &#125; &#125; &#125;&#125; 运行结果如图1所示 图5 若运行结果如图2所示，则说明配置CLASSPATH没有成功。 图6 参考书目： 《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"JDBC常见接口和类","slug":"java/数据库/JDBC常见接口和类","date":"2021-09-28T14:14:23.000Z","updated":"2021-10-27T04:40:32.036Z","comments":true,"path":"2021/09/28/java/数据库/JDBC常见接口和类/","link":"","permalink":"https://silenthly.github.io/2021/09/28/java/%E6%95%B0%E6%8D%AE%E5%BA%93/JDBC%E5%B8%B8%E8%A7%81%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%B1%BB/","excerpt":"​ 无论是哪一个程序设计语言，想要操作数据库，第一件事就是连接数据库。java语言提供了多种方式连接数据库，都是通过JDBC来进行连接的。本文将介绍JDBC的基本知识。","text":"​ 无论是哪一个程序设计语言，想要操作数据库，第一件事就是连接数据库。java语言提供了多种方式连接数据库，都是通过JDBC来进行连接的。本文将介绍JDBC的基本知识。 认识JDBC ​ JDBC是java Database Connectivity的缩写，其中文含义是java数据库连接。JDBC提供了一组与平台无关性，可用于连接数据库及执行SQL语句的API。JDBC允许用户从java程序访问任何支持SQL语言的关系型数据库，它由一组用java编程语言编写的类和接口组成。 ​ 在程序设计中可以直接使用JDBC进行各个关系数据库的连接和操作，可以向数据库发送SQL语句。就是说，开发人员不需要为访问不同的数据库而编写不同的程序。JDBC中含有一套标准的接口，为许多不同的数据库连接模块的前端提供统一的接口。java语言编写的程序可以在支持java的平台上运行，而JDBC就是使用java语言编写的。因此，java与JDBC的结合，可以让程序实现 Write Once，Run Anywhere。java程序、JDBC和各个数据库之间的关系如图所示： ​ 大部分的数据库系统都有自己的JDBC驱动程序，如 Oracle、MySQL 和 Sybase 等。但某些特定的数据库，还需要相应的数据库驱动，如 Access 数据需要的是 JDBC-ODBC 桥进行数据库的连接。目前比较常见的 JDBC 驱动程序主要有以下 4 类。 **JDBC-ODBC 桥：JDBC-ODBC桥驱动程序使用ODBC驱动程序来连接数据库。JDBC-ODBC桥驱动程序将JDBC方法调用转换为ODBC函数调用。**这种方式利用ODBC驱动程序提供JDBC访问数据库，即允许JDBC驱动程序被用于ODBC的驱动程序。必须将ODBC二进制加载到使用到驱动程序的每一个客户机上。但这种方式操作性能低，不推荐使用。 **本地API部分java驱动程序：本地API驱动程序使用数据库提供的客户端库。驱动程序将JDBC方法调用转换为数据库API的本机调用。它不是完全用Java编写的。**这类的驱动程序把客户机API的JDBC转换为Oracle、DB2、Sybase、Informix 或其他 DBMS（数据库管理系统）的调用。这种类型要求驱动程序与应用程序一起驻留在客户机上，并直接与数据库服务器进行通信。这种驱动连接方式不能应用在 Internet 上且只能应用在特定的数据库上，会丧失可移植性。 **JDBC网络纯java驱动程序：网络协议驱动程序使用中间件（应用程序服务器），该中间件将JDBC调用直接或间接转换为供应商特定的数据库协议。它是完全用Java编写的。**这种驱动程序将JDBC转换为DBMS无关的网络协议，之后再被某个服务器转换为一种DBMS协议。它是一种利用java语言编写的JDBC驱动程序，也是目前最灵活的JDBC驱动程序。所有这种解决方案的提供者，都提供了适合于Internet用户的产品。为了使这些产品支持internet，它们必须处理Web所提出的安全性、通过防火墙的访问等额外要求。 **本地协议纯java驱动程序：本地协议驱动将JDBC调用直接转换为供应商特定的数据库协议。这就是为什么它被称为本地协议驱动。它完全用Java语言编写。**这种类型的驱动程序将JDBC调用直接转换为BDMS所使用的网络协议，这将允许从客户机上直接调用DBMS服务器，是Internet访问的一个实用的解决方法。此方式的执行效率非常高，不需要在客户端装载任何的软件或驱动程序，这种驱动程序可以被动态下载，但是对于不同的数据库需要下载不同的驱动程序。 JDBC常见接口和类 ​ JDBC提供了独立于数据库的统一API，让用户能够创建数据库连接、执行SQL语句、查询结果集等操作。要操作数据库，一般需要通过下面的类及接口来实现。 DirverManager类 ​ **DriverManager类用来管理数据库中所有的驱动程序，作用于用户和驱动程序之间。**DirverManger类用于跟踪可用的驱动程序，并在数据库和相应驱动程序之间建立连接。**DriverManger类也可以处理驱动程序登录时间限制，及登录和跟踪信息的显示等事务。**DriverManger类常用方法如下表所示。 序号 方法 类型 说明 1 public static Connection getConnection(String url)throws SQLException 静态 通过给定的数据库URL尝试与数据库建立连接 2 public static Connection getConnecion(String url,String user,String password)throws SQLException 静态 通过给定的数据库URL尝试与数据库建立连接 3 public static int getLoginTimeout() 静态 获取驱动程序在尝试登录到某一数据库时可以等待的最长时间，以秒为单位 4 public static PrintWriter getLogWriter() 静态 检索日志编写器 5 public static void println(String message) 静态 将一条信息打印到当前JDBC日志流中 6 public static void registerDriver(Driver driber) 静态 使用给定的驱动程序 7 public static void setLoginTimeout(int seconds) 静态 设置驱动程序连接到某一数据库时将等待的最长时间，以秒为单位 Connection接口 ​ **Connection接口用于建立与特定的数据库连接，连接过程包括了所有执行SQL语句和在连接上所返回的结果。**一个连接就是一个会话，一个java程序可以存在一个连接或多个连接，还可以与多个数据库连接。Connection接口中常用方法如下表所示。 序号 方法 类型 说明 1 public void close() throws SQLException 普通 关闭数据库连接，并立即释放与此连接有关的数据库和JDBC资源，而不是等待它们被自动释放 2 public void commit() throws SQLException 普通 提交与事务有关的操作，并释放此Connection对象当前持有的所有数据库锁 3 public Statement createStatement() throws SQLException 普通 创建一个Statement对象将SQL语句发送到数据 4 public Statement createStatement(int resultSetTyp,int resultSetConcurrency) 普通 创建一个Statement对象，该对象将生成具有给定类型和并发性的ResultSet对象 5 public Statement createStatement(int resultSetType,int resultSetConcurrency,int resultSetHoldability) throws SQLException 普通 创建一个Statement对象，该对象将生成具有给定类型、并发性和保存性的ResultSet对象 6 public boolean getAutoCommit() throws SQLException 普通 判断此Connection对象释放为自动提交模式，该操作与事务无关 7 public DatabaseMateData getMetaData()throws SQLException 普通 获取数据库的元数据 8 public boolean isClosed()throws SQLException 普通 判断此Connection对象释放已经被关闭。若已被关闭，则返回true，否则返回false 9 public boolean isReadOnly()throws SQLException 普通 判断此Connection对象是否处于只读模式。若为只读的，则返回true，否则返回false 10 public boolean isValid(int timeout)throws SQLException 普通 判断此连接尚未关闭并且仍然有效。若连接有效，则返回true，否则返回false *11 public String nativeSQL(String sql)throws SQLException 普通 将给定的SQL语句转换成系统本机SQL语法 12 public CallableStatement prepareCall(String sql)throws SQLException 普通 创建一个CallableStatement对象来调用数据库存储过程 13 public CallableStatement prepareCall(String sql,int resultSetType,int resultSetConcurrency)throws SQLException 普通 创建一个 CallableStatement 对象，该对象将生成具有给定类型和并发性的 ResultSet 对 象 14 public CallableStatement prepareCall(String sql,int resultSetType,int resultSetConcurrency,int resultSetHoldability)throws SQLException 普通 创建一个 CallableStatement 对象，该对象将生成具有给定类型和并发性的 ResultSet 对象 15 public void rollback()throws SQLException 普通 取消在当前食物中进行的所有更改，实现回滚功能，并释放此Connection对象当前持有的所有数据库锁。此操作与事务无关 16 public void rollback(Savepoint savepoint)throws SQLException 普通 数据库回滚到指定的保存点 17 public void setAutoCommit(boolean autoCommit)throws SQLException 普通 将此连接的自动提交模式设置为指定状态 18 public void setReadOnly(boolean readOnly)throws SQLException 普通 将此连接设置为只读模式，作为驱动程序启用数据库优化的提示 19 public Savepoint setSavepoint()throws SQLException 普通 设置数据库事务的保存点 Statement接口 ​ Statement 接口用于在建立连接的基础上向数据库发送静态的 SQL 语句，并返回执行结果。 Statement 接口的对象可以执行 DDL、DCL 语句，还可以执行 DML 语句，主要用于 SQL 查询。例如，对于 INSERT、UPDATE和DELETE 语句，可以调用 executeUpdate() 方法；而执行 SELECT 语句时调用 executeQuery() 方法，并返回一个不能为null的 ResultSet 实例。Statement接口常用的方法如下表所示。 序号 方法 类型 说明 1 public void addBatch(String sql)throws SQLException 普通 将给定的SQL命令添加到此Statement对象的命令列表中 2 public void cancel()throws SQLException 普通 如果BMS和驱动程序都支持终止SQL语句，则取消此Statement对象 3 public void clearBatch()throws SQLException 普通 清空此Statement对象的当前SQL命令列表 4 public void clearWarnings()throws SQLException 普通 清除此Statement对象上报告的所有警告 5 public void close()throws SQLException 普通 立即释放此Statement对象的数据库和JDBC资源 6 public boolean execute(String sql)throws SQLException 普通 执行给定的SQl语句，该语句可能返回多个结果 7 public int[] executeBatch()throws SQLException 普通 将一批命令提交到数据库以供执行，如果所有命令成功执行，则返回一组更新计数。 8 public ResultSet executeQuery(String sql)throws SQLException 普通 执行给定的SQL查询语句，该语句返回单个ResultSet对象 9 public int executeUpdate(String sql)throws SQLException 普通 执行给定的INSERT、UPDATE和DELETE的SQL语句，返回更新记录数 10 public Connection getConnection()throws SQLException 普通 返回生成此Statement对象的Connection对象 11 public int getMaxRows()throws SQLException 普通 获取由此Statement对象生成的ResultSet对象可以包含的最大行数 12 public int getQueryTimeout()throws SQLException 普通 获取驱动程序等待Statement对象执行的秒数 13 public ResultSet getResultSet()throws SQLException 普通 以ResultSet对象的形式获取当前结果 14 public boolean isClosed()throws SQLException 普通 判断是否已关闭了此Statement对象，若已关闭，则返回true，否则返回false 15 public void setQueryTimeout(int seconds)throws SQLException 普通 设置等待Statement对象实现的秒数 ResultSet接口 ​ ResultSet 接口用于接收SQL语句执行的结果集，类似一张临时的数据表，用来暂时存放数据库查询操作后所获得的结果集，可以通过next()方法将指针下移。ResultSet接口的常用方法如下表所示。 序号 方法 类型 说明 1 public boolean absolute(int row)throws SQLException 普通 将指针移动带此ResultSet对象指定编号的行 2 public void afterLast()throws SQLException 普通 将指针移动到此ResultSet对象的末尾，即最后一行的位置 3 public void beforeFirest()throws SQLException 普通 将指针移动到此ResultSet对象的开头，即第一行的位置 4 public void cancelRowUpdates()throws SQLException 普通 取消对ResultSet对象中的当前行所作的更新 5 public clearWarnings()throws SQLException 普通 取消此ResultSet对象上报告的所有警告 6 public void close()throws SQLException 普通 立即释放ResultSet对象的数据库和JDBC资源 7 public void deleteRwow()throws SQLException 普通 从此ResultSet都系和数据库中删除当前行 8 public boolean first()throws SQLException 普通 将指针移动到此ResultSet对象的第一行 9 public boolean getBoolean(int col)throws SQLException 普通 以boolean的形式获取此ResultSet对象的当前列的值。若为NULL，则返回false 10 public byte getByte(int col)throws SQLException 普通 以byte的形式获取此ResultSet对象的当前行中指定列的值。若为NULL，则返回0，可重写为double,float,int,long,short类型 11 public Date getDate(int col)throws SQLException 普通 以java.sql.Date对象的形式获取此ResultSet对象的当前行指定列的值。若为NULL，则返回null 12 public ResultSetMetaDate getMetaDate()throws SQLException 普通 获取ResultSet对象的列的编号、类型和属性 13 public Object getObject(int col)throws SQLException 普通 以Object的形式获取此ResultSet对象的当前行中指定列的值。若为NULL，则返回值为null 14 public int getRow()throws SQLException 普通 获取当前行编号 15 public Statement getStatement()throws SQLException 普通 返回生成此ResultSet对象的Statement对象 16 public String getString(int col)throws SQLException 普通 以String的形式获取此ResultSet对象的当前行中指定列的值。若为NULL，则返回null 17 public Time getTime(int col)throws SQLException 普通 以java.sql.Time对象的形式获取此ResultSet对象的当前行指定列的值。若为NULL，则返回null 18 public int getType()throws SQLException 普通 获取此ResultSet对象的类型 19 public void insertRow()throws SQLException 普通 将插入行的内容插入到此ResultSet对象和数据库中 20 public boolean isAfterLast()throws SQLException 普通 判断指针是否位于此ResultSet对象的最后一行之后 21 public boolean beforeFirst()throws SQLException 普通 判断指针是否位于此ResultSet对象的第一行之前 22 public boolean isClosed()throws SQLException 普通 判断此ResultSet对象是否已关闭 23 public boolean isFirst()throws SQLException 普通 判断此指针是否位于此ResultSet对象的第一行 24 public boolean isLast()throws SQLException 普通 判断此指针是否位于此ResultSet对象的最后一行 25 public boolean last()throws SQLException 普通 将指针移动到此ResultSet对象的最后一行 26 public boolean next()throws SQLException 普通 将指针向下移动一行 27 public boolean previous()throws SQLException 普通 将指针向上移动一行 28 public boolean rowDelete()throws SQLException 普通 判断是否已删除某行 29 public booelan rowIntsert()throws SQLException 普通 判断当前行是否已有插入 30 public boolean rowUpdate()throws SQLException 普通 判断是否已更新当前行 31 public void setFetchSize(int rows)throws SQLException 普通 为JDBC驱动程序设置此ResultSet对象需要更多行时应该从数据库获取行数 32 public void updateBoolean(int col,boolean x)throws SQLException 普通 用指定的boolean值更新指定列，可重写为byte,Date,double,float,int,long，Object,short,String.Time 33 public void updateLong(String columnLabel,long x)throws SQLException 普通 用指定的long更新指定列 34 public void updateNull(int col)throws SQLException 普通 用null值更新指定列 35 public void updateRow()throws SQLException 普通 将当前行的内容更新到数据表中 36 public boolean wasNull()throws SQLException 普通 报告最后一个读取的列是否为NULL ​ JDBC API中除了上面的类和接口之外，还含有多个其他的类和接口。开发人员可以直接使用这些类库来开发数据库应用程序，其他类和接口如下。 CallableStatement 接口：用于执行 SQL 存储过程的接口。 DatabaseMetaData 接口：此接口由驱动程序供应商实现，让用户了解 DBMS 在与驱动程序相结合时的能力，与 ResultSetMetaData 一同用于访问数据库的元信息。 Driver 接口：是数据库驱动程序的接口，每个驱动程序都应该提供一个实现 Driver 接口的类。 PreparedStatement 接口：表示预编译的 SQL 语句的对象。SQL 语句被预编译并存储在 PreparedStatement 对象中，然后可以使用此对象多次高效地执行该语句。 Date 类：该类是 java.util.Date 的子类，为了与 SQL DATE 的定义一致，但日期不包括时间。 Time 类：该类是 java.util.Date 的子类，用于表示时、分、秒。 Timestamp 类：该类是 java.util.Date 的子类，扩展了 java.util.Date 类，用于表示 SQL 时间戳，还可以表示纳秒的时间域 Types 类：定义用于标识一般 SQL 类型的常量的类。 SQLException 类：该类是异常类，提供关于数据库访问错误或其他错误信息的异常。 SQLWarning 类：该类是异常类，提供关于数据库访问警告信息的异常，这些警告直接链接到导致报告警告的方法所在的对象。 参考链接：详解JDBC的四种驱动类型 - ericxu1116的个人空间 - OSCHINA - 中文开源技术交流社区 参考书目： 《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"图文详解Java对象内存布局","slug":"java/深入java/图文详解Java对象内存布局","date":"2021-09-07T08:15:43.000Z","updated":"2021-10-27T04:51:28.935Z","comments":true,"path":"2021/09/07/java/深入java/图文详解Java对象内存布局/","link":"","permalink":"https://silenthly.github.io/2021/09/07/java/%E6%B7%B1%E5%85%A5java/%E5%9B%BE%E6%96%87%E8%AF%A6%E8%A7%A3Java%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/","excerpt":"转自：图文详解Java对象内存布局 (qq.com) 作者：Dr Hydra 作为一名Java程序员，我们在日常工作中使用这款面向对象的编程语言时，做的最频繁的操作大概就是去创建一个个的对象了。对象的创建方式虽然有很多，可以通过new、反射、clone、反序列化等不同方式来创建，但最终使用时对象都要被放到内存中，那么你知道在内存中的java对象是由哪些部分组成、又是怎么存储的吗？","text":"转自：图文详解Java对象内存布局 (qq.com) 作者：Dr Hydra 作为一名Java程序员，我们在日常工作中使用这款面向对象的编程语言时，做的最频繁的操作大概就是去创建一个个的对象了。对象的创建方式虽然有很多，可以通过new、反射、clone、反序列化等不同方式来创建，但最终使用时对象都要被放到内存中，那么你知道在内存中的java对象是由哪些部分组成、又是怎么存储的吗？ 本文将基于代码进行实例测试，详细探讨对象在内存中的组成结构。全文目录结构如下： 1、对象内存结构概述 2、JOL 工具简介 3、对象头 4、实例数据 5、对齐填充字节 6、总结 文中代码基于 JDK 1.8.0_261，64-Bit HotSpot 运行 1、对象内存结构概述 在介绍对象在内存中的组成结构前，我们先简要回顾一个对象的创建过程： 1、jvm将对象所在的class文件加载到方法区中 2、jvm读取main方法入口，将main方法入栈，执行创建对象代码 3、在main方法的栈内存中分配对象的引用，在堆中分配内存放入创建的对象，并将栈中的引用指向堆中的对象 所以当对象在实例化完成之后，是被存放在堆内存中的，这里的对象由3部分组成，如下图所示： 对各个组成部分的功能简要进行说明： 对象头：对象头存储的是对象在运行时状态的相关信息、指向该对象所属类的元数据的指针，如果对象是数组对象那么还会额外存储对象的数组长度 实例数据：实例数据存储的是对象的真正有效数据，也就是各个属性字段的值，如果在拥有父类的情况下，还会包含父类的字段。字段的存储顺序会受到数据类型长度、以及虚拟机的分配策略的影响 对齐填充字节：在java对象中，需要对齐填充字节的原因是，64位的jvm中对象的大小被要求向8字节对齐，因此当对象的长度不足8字节的整数倍时，需要在对象中进行填充操作。注意图中对齐填充部分使用了虚线，这是因为填充字节并不是固定存在的部分，这点在后面计算对象大小时具体进行说明 2、JOL 工具简介 在具体开始研究对象的内存结构之前，先介绍一下我们要用到的工具，openjdk官网提供了查看对象内存布局的工具jol (java object layout)，可在maven中引入坐标： 12345&lt;dependency&gt; &lt;groupId&gt;org.openjdk.jol&lt;/groupId&gt; &lt;artifactId&gt;jol-core&lt;/artifactId&gt; &lt;version&gt;0.14&lt;/version&gt;&lt;/dependency&gt; 在代码中使用jol提供的方法查看jvm信息： 1System.out.println(VM.current().details()); 通过打印出来的信息，可以看到我们使用的是64位 jvm，并开启了指针压缩，对象默认使用8字节对齐方式。通过jol查看对象内存布局的方法，将在后面的例子中具体展示，下面开始对象内存布局的正式学习。 3、对象头 首先看一下对象头（Object header）的组成部分，根据普通对象和数组对象的不同，结构将会有所不同。只有当对象是数组对象才会有数组长度部分，普通对象没有该部分，如下图所示： **在对象头中mark word 占8字节，默认开启指针压缩的情况下klass pointer 占4字节，数组对象的数组长度占4字节。**在了解了对象头的基础结构后，现在以一个不包含任何属性的空对象为例，查看一下它的内存布局，创建User类： 12public class User &#123;&#125; 使用jol查看对象头的内存布局： 12345public static void main(String[] args) &#123; User user=new User(); //查看对象的内存布局 System.out.println(ClassLayout.parseInstance(user).toPrintable());&#125; 执行代码，查看打印信息： OFFSET：偏移地址，单位为字节 SIZE：占用内存大小，单位为字节 TYPE：Class中定义的类型 DESCRIPTION：类型描述，Obejct header 表示对象头，alignment表示对齐填充 VALUE：对应内存中存储的值 当前对象共占用16字节，因为8字节标记字加4字节的类型指针，不满足向8字节对齐，因此需要填充4个字节： 18B (mark word) + 4B (klass pointer) + 0B (instance data) + 4B (padding) 这样我们就通过直观的方式，了解了一个不包含属性的最简单的空对象，在内存中的基本组成是怎样的。在此基础上，我们来深入学习对象头中各个组成部分。 3.1 Mark Word 标记字 在对象头中，mark word 一共有64个bit，用于存储对象自身的运行时数据，标记对象处于以下5种状态中的某一种： 3.1.1 基于mark word的锁升级 在jdk6 之前，通过synchronized关键字加锁时使用无差别的的重量级锁，重量级锁会造成线程的串行执行，并且使cpu在用户态和核心态之间频繁切换。随着对synchronized的不断优化，提出了锁升级的概念，并引入了偏向锁、轻量级锁、重量级锁。在mark word中，锁（lock）标志位占用2个bit，结合1个bit偏向锁（biased_lock）标志位，这样通过倒数的3位，就能用来标识当前对象持有的锁的状态，并判断出其余位存储的是什么信息。 基于mark word的锁升级的流程如下： 1、**锁对象刚创建时，没有任何线程竞争，对象处于无锁状态。**在上面打印的空对象的内存布局中，根据大小端，得到最后8位是00000001，表示处于无锁态，并且处于不可偏向状态。这是因为在jdk中偏向锁存在延迟4秒启动，也就是说在jvm启动后4秒后创建的对象才会开启偏向锁，我们通过jvm参数取消这个延迟时间： 1-XX:BiasedLockingStartupDelay=0 这时最后3位为101，表示当前对象的锁没有被持有，并且处于可被偏向状态。 2、在没有线程竞争的条件下，第一个获取锁的线程通过CAS将自己的threadId写入到该对象的mark word中，若后续该线程再次获取锁，需要比较当前线程threadId和对象mark word中的threadId是否一致，如果一致那么可以直接获取，并且锁对象始终保持对该线程的偏向，也就是说偏向锁不会主动释放。 使用代码进行测试同一个线程重复获取锁的过程： 12345678910public static void main(String[] args) &#123; User user=new User(); synchronized (user)&#123; System.out.println(ClassLayout.parseInstance(user).toPrintable()); &#125; System.out.println(ClassLayout.parseInstance(user).toPrintable()); synchronized (user)&#123; System.out.println(ClassLayout.parseInstance(user).toPrintable()); &#125;&#125; 执行结果： 可以看到一个线程对一个对象加锁、解锁、重新获取对象的锁时，mark word都没有发生变化，偏向锁中的当前线程指针始终指向同一个线程。 3、**当两个或以上线程交替获取锁，但并没有在对象上并发的获取锁时，偏向锁升级为轻量级锁。**在此阶段，线程采取CAS的自旋方式尝试获取锁，**避免阻塞线程造成的cpu在用户态和内核态间转换的消耗。**测试代码如下： 1234567891011121314public static void main(String[] args) throws InterruptedException &#123; User user=new User(); synchronized (user)&#123; System.out.println(&quot;--MAIN--:&quot;+ClassLayout.parseInstance(user).toPrintable()); &#125; Thread thread = new Thread(() -&gt; &#123; synchronized (user) &#123; System.out.println(&quot;--THREAD--:&quot;+ClassLayout.parseInstance(user).toPrintable()); &#125; &#125;); thread.start(); thread.join(); System.out.println(&quot;--END--:&quot;+ClassLayout.parseInstance(user).toPrintable());&#125; 先直接看一下结果： 整个加锁状态的变化流程如下： 主线程首先对user对象加锁，首次加锁为101偏向锁 子线程等待主线程释放锁后，对user对象加锁，这时将偏向锁升级为00轻量级锁 轻量级锁解锁后，user对象无线程竞争，恢复为001无锁态，并且处于不可偏向状态。如果之后有线程再尝试获取user对象的锁，会直接加轻量级锁，而不是偏向锁。 4、**当两个或以上线程并发的在同一个对象上进行同步时，为了避免无用自旋消耗cpu，轻量级锁会升级成重量级锁。**这时mark word中的指针指向的是monitor对象（也被称为管程或监视器锁）的起始地址。测试代码如下： 1234567891011121314151617181920212223public static void main(String[] args) &#123; User user = new User(); new Thread(() -&gt; &#123; synchronized (user) &#123; System.out.println(&quot;--THREAD1--:&quot; + ClassLayout.parseInstance(user).toPrintable()); try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); new Thread(() -&gt; &#123; synchronized (user) &#123; System.out.println(&quot;--THREAD2--:&quot; + ClassLayout.parseInstance(user).toPrintable()); try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start();&#125; 查看结果： 可以看到，在两个线程同时竞争user对象的锁时，会升级为10重量级锁。 3.1.2 其他信息 对mark word 中其他重要信息进行说明： hashcode：无锁态下的hashcode采用了延迟加载技术，**在第一次调用hashCode()方法时才会计算写入。**对这一过程进行验证： 123456789public static void main(String[] args) &#123; User user=new User(); //打印内存布局 System.out.println(ClassLayout.parseInstance(user).toPrintable()); //计算hashCode System.out.println(user.hashCode()); //再次打印内存布局 System.out.println(ClassLayout.parseInstance(user).toPrintable());&#125; 可以看到，在没有调用hashCode()方法前，31位的哈希值不存在，全部填充为0。在调用方法后，根据大小端，被填充的数据为： 11011001001101100011010010101101 将2进制转换为10进制，对应哈希值1496724653。需要注意，只有在调用没有被重写的Object.hashCode()方法或System.identityHashCode(Object)方法才会写入mark word，执行用户自定义的hashCode()方法不会被写入。 大家可能会注意到，当对象被加锁后，mark word中就没有足够空间来保存hashCode了，这时hashcode会被移动到重量级锁的Object Monitor中。 epoch：偏向锁的时间戳 分代年龄（age）：在jvm的垃圾回收过程中，每当对象经过一次Young GC，年龄都会加1，这里4位来表示分代年龄最大值为15，这也就是为什么对象的年龄超过15后会被移到老年代的原因。在启动时可以通过添加参数来改变年龄阈值： 1-XX:MaxTenuringThreshold 当设置的阈值超过15时，启动时会报错： 3.2 Klass Pointer 类型指针 Klass Pointer是一个指向方法区中Class信息的指针，虚拟机通过这个指针确定该对象属于哪个类的实例。在64位的JVM中，支持指针压缩功能，根据是否开启指针压缩，Klass Pointer占用的大小将会不同： 未开启指针压缩时，类型指针占用8B (64bit) 开启指针压缩情况下，类型指针占用4B (32bit) 在jdk6之后的版本中，指针压缩是被默认开启的，可通过启动参数开启或关闭该功能： 1234#开启指针压缩：-XX:+UseCompressedOops#关闭指针压缩：-XX:-UseCompressedOops 还是以刚才的User类为例，关闭指针压缩后再次查看对象的内存布局： 对象大小虽然还是16字节，但是组成发生了改变，8字节标记字加8字节类型指针，已经能满足对齐条件，因此不需要填充。 18B (mark word) + 8B (klass pointer) + 0B (instance data) + 0B (padding) 3.2.1 指针压缩原理 在了解了指针压缩的作用后，我们来看一下指针压缩是如何实现的。首先在不开启指针压缩的情况下，一个对象的内存地址使用64位表示，这时能描述的内存地址范围是： 10 ~ 2^64-1 在开启指针压缩后，使用4个字节也就是32位，可以表示2^32 个内存地址，如果这个地址是真实地址的话，由于CPU寻址的最小单位是Byte，那么就是4GB内存。这对于我们来说是远远不够的，但是之前我们说过，java中对象默认使用了8字节对齐，也就是说1个对象占用的空间必须是8字节的整数倍，这样就创造了一个条件，使jvm在定位一个对象时不需要使用真正的内存地址，而是定位到由java进行了8字节映射后的地址（可以说是一个映射地址的编号）。 映射过程也非常简单，由于使用了8字节对齐后每个对象的地址偏移量后3位必定为0，所以在存储的时候可以将后3位0抹除（转化为bit是抹除了最后24位），在此基础上再去掉最高位，就完成了指针从8字节到4字节的压缩。而在实际使用时，在压缩后的指针后加3位0，就能够实现向真实地址的映射。 完成压缩后，现在指针的32位中的每一个bit，都可以代表8个字节，这样就相当于使原有的内存地址得到了8倍的扩容。所以在8字节对齐的情况下，32位最大能表示2^32*8=32GB内存，内存地址范围是： 10 ~ (2^32-1)*8 由于能够表示的最大内存是32GB，所以如果配置的最大的堆内存超过这个数值时，那么指针压缩将会失效。配置jvm启动参数： 1-Xmx32g 查看对象内存布局： 此时，指针压缩失效，指针长度恢复到8字节。那么如果业务场景内存超过32GB怎么办呢，可以通过修改默认对齐长度进行再次扩展，我们将对齐长度修改为16字节： 1-XX:ObjectAlignmentInBytes=16 -Xmx32g 可以看到指针压缩后占4字节，同时对象向16字节进行了填充对齐，按照上面的计算，这时配置最大堆内存为64GB时指针压缩才会失效。 对指针压缩做一下简单总结： 通过指针压缩，利用对齐填充的特性，通过映射方式达到了内存地址扩展的效果 指针压缩能够节省内存空间，同时提高了程序的寻址效率 堆内存设置时最好不要超过32GB，这时指针压缩将会失效，造成空间的浪费 此外，指针压缩不仅可以作用于对象头的类型指针，还可以作用于引用类型的字段指针，以及引用类型数组指针 3.3 数组长度 如果当对象是一个数组对象时，那么在对象头中有一个保存数组长度的空间，占用4字节（32bit）空间。通过下面代码进行测试： 12345public static void main(String[] args) &#123; User[] user=new User[2]; //查看对象的内存布局 System.out.println(ClassLayout.parseInstance(user).toPrintable());&#125; 运行代码，结果如下： 内存结构从上到下分别为： 8字节mark word 4字节klass pointer 4字节数组长度，值为2，表示数组中有两个元素 开启指针压缩后每个引用类型占4字节，数组中两个元素共占8字节 需要注意的是，在未开启指针压缩的情况下，在数组长度后会有一段对齐填充字节： 通过计算： 18B (mark word) + 8B (klass pointer) + 4B (array length) + 16B (instance data)=36B 需要向8字节进行对齐，这里选择将对齐的4字节添加在了数组长度和实例数据之间。 4、实例数据 实例数据（Instance Data）保存的是对象真正存储的有效信息，保存了代码中定义的各种数据类型的字段内容，并且如果有继承关系存在，子类还会包含从父类继承过来的字段。 基本数据类型： Type Bytes byte，boolean 1 char，short 2 int，float 4 long，double 8 引用数据类型： 开启指针压缩情况下占8字节，开启指针压缩后占4字节。 4.1 字段重排序 给User类添加基本数据类型的属性字段： 123456public class User &#123; int id,age,weight; byte sex; long phone; char local;&#125; 查看内存布局： 可以看到，在内存中，属性的排列顺序与在类中定义的顺序不同，这是因为jvm会采用字段重排序技术，对原始类型进行重新排序，以达到内存对齐的目的。具体规则遵循如下： 按照数据类型的长度大小，从大到小排列 具有相同长度的字段，会被分配在相邻位置 如果一个字段的长度是L个字节，那么这个字段的偏移量（OFFSET）需要对齐至nL（n为整数） 上面的前两条规则相对容易理解，这里通过举例对第3条进行解释： 因为long类型占8字节，所以它的偏移量必定是8n，再加上前面对象头占12字节，所以long类型变量的最小偏移量是16。通过打印对象内存布局可以发现，当对象头不是8字节的整数倍时（只存在8n+4字节情况），会按从大到小的顺序，使用4、2、1字节长度的属性进行补位。为了和对齐填充进行区分，可以称其为前置补位，如果在补位后仍然不满足8字节整数倍，会进行对齐填充。在存在前置补位的情况下，字段的排序会打破上面的第一条规则。 因此在上面的内存布局中，先使用4字节的int进行前置补位，再按第一条规则从大到小顺序进行排列。如果我们删除3个int类型的字段，再查看内存布局： char和byte类型的变量被提到前面进行前置补位，并在long类型前进行了1字节的对齐填充。 4.2 拥有父类情况 当一个类拥有父类时，整体遵循在父类中定义的变量出现在子类中定义的变量之前的原则 123456789public class A &#123; int i1,i2; long l1,l2; char c1,c2;&#125;public class B extends A&#123; boolean b1; double d1,d2;&#125; 查看内存结构： 如果父类需要后置补位的情况，可能会将子类中类型长度较短的变量提前，但是整体还是遵循子类在父类之后的原则 12345678public class A &#123; int i1,i2; long l1;&#125;public class B extends A &#123; int i1,i2; long l1;&#125; 查看内存结构： 可以看到，子类中较短长度的变量被提前到父类后进行了后置补位。 父类的前置对齐填充会被子类继承 1234567public class A &#123; long l;&#125;public class B extends A&#123; long l2; int i1;&#125; 查看内存结构： 当B类没有继承A类时，正好满足8字节对齐，不需要进行对齐填充。当B类继承A类后，会继承A类的前置补位填充，因此在B类的末尾也需要对齐填充。 4.3 引用数据类型 在上面的例子中，仅探讨了基本数据类型的排序情况，那么如果存在引用数据类型时，排序情况是怎样的呢？在User类中添加引用类型： 123456public class User &#123; int id; String firstName; String lastName; int age;&#125; 查看内存布局： 可以看到默认情况下，基本数据类型的变量排在引用数据类型前。这个顺序可以在jvm启动参数中进行修改： 1-XX:FieldsAllocationStyle=0 重新运行，可以看到引用数据类型的排列顺序被放在了前面： 对FieldsAllocationStyle的不同取值简要说明： 0：先放入普通对象的引用指针，再放入基本数据类型变量 1：默认情况，表示先放入基本数据类型变量，再放入普通对象的引用指针 4.4 静态变量 在上面的基础上，在类中加入静态变量： 1234public class User &#123; int id; static byte local;&#125; 查看内存布局： 通过结果可以看到，静态变量并不在对象的内存布局中，它的大小是不计算在对象中的，因为静态变量属于类而不是属于某一个对象的。 5、对齐填充字节 在Hotspot的自动内存管理系统中，要求对象的起始地址必须是8字节的整数倍，也就是说对象的大小必须满足8字节的整数倍。因此如果实例数据没有对齐，那么需要进行对齐补全空缺，补全的bit位仅起占位符作用，不具有特殊含义。 在前面的例子中，我们已经对对齐填充有了充分的认识，下面再做一些补充： 在开启指针压缩的情况下，如果类中有long/double类型的变量时，会在对象头和实例数据间形成间隙（gap），为了节省空间，会默认把较短长度的变量放在前边，这一功能可以通过jvm参数进行开启或关闭： 1234# 开启-XX:+CompactFields# 关闭-XX:-CompactFields 测试关闭情况，可以看到较短长度的变量没有前移填充： 在前面指针压缩中，我们提到了可以改变对齐宽度，这也是通过修改下面的jvm参数配置实现的： 1-XX:ObjectAlignmentInBytes 默认情况下对齐宽度为8，这个值可以修改为2~256以内2的整数幂，一般情况下都以8字节对齐或16字节对齐。测试修改为16字节对齐： 上面的例子中，在调整为16字节对齐的情况下，最后一行的属性字段只占了6字节，因此会添加10字节进行对齐填充。当然普通情况下不建议修改对齐长度参数，如果对齐宽度过长，可能会导致内存空间的浪费。 6、总结 本文通过使用jol 对java对象的结构进行调试，学习了对象内存布局的基本知识。通过学习，能够帮助我们： 掌握对象内存布局，基于此基础进行jvm参数调优 了解对象头在synchronize 的锁升级过程中的作用 熟悉 jvm 中对象的寻址过程 通过计算对象大小，可以在评估业务量的基础上在项目上线前预估需要使用多少内存，防止服务器频繁gc","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"数据库的基本操作语句","slug":"java/数据库/数据库的基本操作语句","date":"2021-09-07T04:23:43.000Z","updated":"2021-10-27T04:40:38.952Z","comments":true,"path":"2021/09/07/java/数据库/数据库的基本操作语句/","link":"","permalink":"https://silenthly.github.io/2021/09/07/java/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E8%AF%AD%E5%8F%A5/","excerpt":"​ SQL（Structured Query Langue，结构化查询语言）是关系数据库的标准语言，也是一种数据库查询和程序设计语言，用于存取数据及查询、更新和管理关系数据库系统。","text":"​ SQL（Structured Query Langue，结构化查询语言）是关系数据库的标准语言，也是一种数据库查询和程序设计语言，用于存取数据及查询、更新和管理关系数据库系统。 SQL语句的分类 ​ SQL按其规则可以分为3种，即核心SQL，标准SQL和扩展SQL，其中前者是后者的子集。各个数据库厂商在支持标准的SQL语法的同时，在功能上都做了相应的扩充，在实现上略有不同。 ​ SQL语言包含三个部分： 数据定义语言（Data Definition Language，DDL）：用于建立数据库、表、视图、索引和触发器等，其中， CREATE语句主要用于创建数据库、创建表和创建视图等。 ALTER语句主要用于修改表的定义和视图的定义等。 DBOR语句主要是用于删除数据库、删除表和删除视图等。 数据操作语言（Data Manipulation Language，DML）：用于插入数据、查询数据、更新数据和删除数据等，其中： INSERT语句用于插入数据。 SELECT语句用于更新数据。 DELETE语句用于删除数据。 数据控制语言（Data Controlling Language，DCL）： 用于控制数据库组件的存取允许、存取权限等，其中： GRANT语句用于给用户增加权限。 REVOKE语句用于回收用户的权限。 提示：还有事务控制语言（Transaction Control Language），主要有COMMIT和 ROLLBACK语句。 CREATE 建表语句 创建数据库 ​ 创建数据库是指在数据库系统中划分一块空间，用来存储相应的数据。在MySQL中可以通过CREATE DATABASE实现，其语法格式如下所示： 1CREATE DATABASE 数据库名称； ​ 其中，“数据库名称”表示要创建的数据库名。 提示：若想知道系统中存在哪些数据库，可以使用SHOW DATABASES查看。数据库命令不区分大小写，SQL推荐使用大写，但是使用小写也可以。 代码示例： 1CREATE DATABASE javaTest; 运行结果： 1Query OK, 1 row affected (0.00 sec) ​ 以上SQL语句创建了一个名为javaTest的数据库，如果在安装时没有更改过安装路径的话，数据库的存放路径在C:\\ProgramData\\MySQL\\MySQL Server 5.7\\Data里。 创建数据表 ​ 在MySQL中还可以利用CREATE TABLE创建数据表，其语法格式如下所示。 1234567CREATE TABLE 表名&#123; 属性名1 数据类型 [完整性约束条件], 属性名2 数据类型 [完整性约束条件], ... 属性名n 数据类型 [完整性约束条件],&#125; ​ 其中，&quot;表名&quot;的是要创建的数据表的名称，&quot;属性名&quot;表示数据表的字段名称，&quot;数据类型&quot;表示该字段的数据类型，“完整性约束条件&quot;表示该字段需要满足某些约束条件。在创建表前，需要先使用”USE 数据库名;&quot;进入数据库。 注意：在使用CREATE TABLE创建数据表时，有以下需要注意。 在使用CREATE TABLE数据表前，要执行“USE 数据库名”选择数据库，因为创建表需要在已存在的数据库中建立数据表。若没有选择数据库，则会出现“ERROR 1046（3D000）:NO database selected”错误。 在创建数据表的数据库内，不能存在两个名称相同的数据表，所以创建数据表前可以执行SHOW TABLES查看数据库内的数据表有哪些。 各个属性之间用英文逗号（,）隔开，最后一个不需要逗号。 代码示例：(创建数据表) 12345678CREATE TABLE 学生( 学号 INT(10) NOT NULL, 姓名 VARCHAR(16) DEFAULT NULL, 性别 VARCHAR(4) DEFAULT NULL, 籍贯 VARCHAR(16) DEFAULT NULL, 生日 DATE DEFAULT NULL, 院系 VARCHAR(16) DEFAULT NULL); 运行结果： 1Query OK, 0 rows affected (0.01 sec) ​ 以上SQL语句创建了一个名为&quot;学生&quot;的数据表，包括&quot;学号&quot;、“姓名”、“性别”、“籍贯”、&quot;生日&quot;和&quot;院系&quot;字段，其中&quot;学号&quot;是主键。MySQL中完整性约束条件如下表所示。 序号 约束条件 说明 1 PRIMARY KEY 主键 2 FOREIGN KEY 外键 3 NOT NULL 不能为空 4 UNIQUE 唯一索引 5 AUTO_INCREMENT 自动增加 6 DEFAULT 默认值 INSERT插入语句 ​ 此时已经创建好了一个数据表，可以向表中增加记录。增加记录是数据库操作中最常使用的操作之一。可以有两种形式：一种是一条一条的增加，就是一次添加一条记录；另一种是批量添加，就是一次添加多条记录。 ​ MySQL支持多种增加记录的格式，其语法格式分别如下所示。 格式一：INSERT语句中不指定具体的字段名 1INSERT INTO 表名 VALUES (值1,值2...); 格式二：INSERT语句中列出所有字段 1INSERT INTO 表名 (属性1,属性2...) VALUES (值1,值2...) 格式三：为表的指定字段插入数据 1INSERT INTO 表名 (属性1,属性2...) VALUES (值1,值2...) 格式四：批量插入数据 12345INSERT INTO 表名 (属性1,属性2...) VALUES(值1,值2...),(值1,值2...),...(值1,值2...); ​ 其中，&quot;表名&quot;表示增加的记录插入到哪个表中，&quot;属性&quot;表示表中的字段，&quot;值&quot;表示表中字段的值，这些值与相应的属性相对应。 代码示例：(一次增加多条记录) 12345INSERT INTO 学生 (学号,姓名,性别,籍贯,生日,院系) VALUES(&#x27;01&#x27;,&#x27;小强&#x27;,&#x27;男&#x27;,&#x27;广东&#x27;,&#x27;2000-01-01&#x27;,&#x27;计算机科学与技术学院&#x27;),(&#x27;10&#x27;,&#x27;小明&#x27;,&#x27;男&#x27;,&#x27;海南&#x27;,&#x27;2001-09-02&#x27;,&#x27;艺术学院&#x27;),(&#x27;13&#x27;,&#x27;小红&#x27;,&#x27;女&#x27;,&#x27;湖北&#x27;,&#x27;2001-10-21&#x27;,&#x27;数学学院&#x27;),(&#x27;98&#x27;,&#x27;小晨&#x27;,&#x27;女&#x27;,&#x27;重庆&#x27;,&#x27;2002-12-14&#x27;,&#x27;外语学院&#x27;); 运行结果： 12Query OK, 4 rows affected (0.05 sec)Records: 4 Duplicates: 0 Warnings: 0 ​ 以上程序，可能因为字符编码问题而造成“ERROR 1366 (HY000): Incorrect string value: '\\xE5\\xB0\\x8F\\xE5\\xBC\\xBA' for column '姓名' at row 1”问题，这时就需要修改表属性的编码，可以执行以下命令： 1ALTER TABLE 表名 CHARACTER SET utf8; //修改表的编码 1ALTER TABLE 表名 CHANGE 属性名 属性名 数据类型 CHARACTER SET utf8 完整性约束条件; //修改属性字段的编码 ​ 上面的命令只能修改一个属性，若属性很多，一条一条地更改则操作过于繁杂，可以使用下面命令一次性修改完表中所有属性的编码。 1ALTER TABLE 表名 CONVERT TO CHARACTER SET utf8; //修改表中所有属性字段的编码 SELECT 查询语句 ​ 查询语句可以从一个或多个表汇总检索信息。查询语句是SQL语句中最常使用的、最重要，同时也是最难用好的命令，其语法格式如下。 12345SELECT 属性列表FROM 表名[WHERE 条件表达式1][GROUP BY 属性名1 [HAVING 条件表达式2]][ORDER BY 属性名2[ASC|DESC]] ​ 其中，SELECT是查询语句的关键字，&quot;属性列表&quot;表示需要查询的字段，FROM表示从指定的表中查询，WHERE表示查询条件，ASC表示升序排序，默认为升序排序，DESC表示降序排序。 代码示例：(查询信息) 12SELECT 学号,姓名,性别,籍贯,生日,院系FROM 学生; 运行结果： 123456789+--------+--------+--------+--------+------------+--------------------------------+| 学号 | 姓名 | 性别 | 籍贯 | 生日 | 院系 |+--------+--------+--------+--------+------------+--------------------------------+| 01 | 小强 | 男 | 广东 | 2000-01-01 | 计算机科学与技术学院 || 10 | 小明 | 男 | 海南 | 2001-09-02 | 艺术学院 || 13 | 小红 | 女 | 湖北 | 2001-10-21 | 数学学院 || 98 | 小晨 | 女 | 重庆 | 2002-12-14 | 外语学院 |+--------+--------+--------+--------+------------+--------------------------------+4 rows in set (0.01 sec) ​ 以上的SQL语句查询中，还可以通过&quot;SELECT * FROM 学生&quot;表示查询表中所有的字段信息。 代码示例： 123SELECT 学号,姓名,性别,籍贯,生日,院系FROM 学生WHERE 学号=13; 运行结果： 123456+--------+--------+--------+--------+------------+--------------+| 学号 | 姓名 | 性别 | 籍贯 | 生日 | 院系 |+--------+--------+--------+--------+------------+--------------+| 13 | 小红 | 女 | 湖北 | 2001-10-21 | 数学学院 |+--------+--------+--------+--------+------------+--------------+1 row in set (0.04 sec) DELETE 删除语句 ​ 使用DELETE语句可以删除数据表中已经存在的记录，DELETE语句的语法格式如下。 1DELETE FROM 表名 [WHERE 条件表达式]; ​ 其中，&quot;表名&quot;表示从哪个包中删除数据，WHERE表示删除满足条件的数据，若没有该条件，将删除表中所有的数据。 代码示例： 1DELETE FROM 学生 WHERE 院系=&#x27;外语学院&#x27;; 运行结果： 1Query OK, 1 row affected (0.03 sec) ​ 执行上述的DELETE语句后，再次查询学生表中的数据如下所示： 123456789mysql&gt; select 学号,姓名,性别,籍贯,生日,院系 from 学生;+------+------+------+------+------------+----------------------+| 学号 | 姓名 | 性别 | 籍贯 | 生日 | 院系 |+------+------+------+------+------------+----------------------+| 01 | 小强 | 男 | 广东 | 2000-01-01 | 计算机科学与技术学院 || 10 | 小明 | 男 | 海南 | 2001-09-02 | 艺术学院 || 13 | 小红 | 女 | 湖北 | 2001-10-21 | 数学学院 |+------+------+------+------+------------+----------------------+3 rows in set (0.01 sec) UPDATE 更新语句 ​ 使用UPDATE语句可以更新数据库中已存在的记录，其语法格式如下： 12345UPDATE 表名SET 属性1=值1,属性2=值2,...属性n=值nWHERE 条件表达式; ​ 其中，&quot;属性&quot;表示表中需要更新的字段，&quot;值&quot;表示字段更改的新值。 代码示例： 123UPDATE 学生SET 姓名=&#x27;王小明&#x27;,籍贯=&#x27;浙江&#x27;;WHERE 学号=&#x27;10&#x27;; 运行结果： 12Query OK, 3 rows affected (0.00 sec)Rows matched: 3 Changed: 3 Warnings: 0 ​ 执行上述的UPDATE语句后，再次查询学生表中的数据。 123456789mysql&gt; select * from 学生;+------+--------+------+------+------------+----------------------+| 学号 | 姓名 | 性别 | 籍贯 | 生日 | 院系 |+------+--------+------+------+------------+----------------------+| 1 | 小强 | 男 | 广东 | 2000-01-01 | 计算机科学与技术学院 || 10 | 王小明 | 男 | 浙江 | 2001-09-02 | 艺术学院 || 13 | 小红 | 女 | 湖北 | 2001-10-21 | 数学学院 |+------+--------+------+------+------------+----------------------+3 rows in set (0.00 sec) ​ 可以发现数据表中学号为&quot;10&quot;的记录已经发生改变。 ALTER 修改表语句 ​ 使用ALTER语句可以修改已存在的表而不需要将表删除后再创建，也不会影响正在进行的服务。ALTER语句可以修改表名、表中的字段名和表中字段的排序等，其语法格式如下。 格式一：修改表名 1ALTER TABLE 旧表名 RENAME [TO] 新表名; 格式二：修改字段的数据类型 1ALTER TABLE 表名 MODIFY 属性名 数据类型; 格式三：增加表中的字段 1ALTER TABLE 表名 ADD 属性1 数据类型 [完整性约束条件] [FIRST|AFTER 属性名2]; 格式四：删除表中的字段 1ALTER TABLE 表名 DROP 属性名; 格式五：修改表中的字段名 1ALTER TABLE 表名 CHANGE 旧属性名 新属性名 新数据类型; 代码示例：(修改表中的字段名) 1ALTER TABLE 学生 CHANGE 院系 学院 VARCHAR(16); 运行结果： 12Query OK, 0 rows affected (0.00 sec)Records: 0 Duplicates: 0 Warnings: 0 ​ 执行上述ALTER语句后，再次查询学生表中的数据。 123456789mysql&gt; select * from 学生;+------+--------+------+------+------------+----------------------+| 学号 | 姓名 | 性别 | 籍贯 | 生日 | 学院 |+------+--------+------+------+------------+----------------------+| 1 | 小强 | 男 | 广东 | 2000-01-01 | 计算机科学与技术学院 || 10 | 王小明 | 男 | 浙江 | 2001-09-02 | 艺术学院 || 13 | 小红 | 女 | 湖北 | 2001-10-21 | 数学学院 |+------+--------+------+------+------------+----------------------+3 rows in set (0.00 sec) ​ 可以发现数据表中&quot;院系&quot;被改成了&quot;学院&quot;。 DROP 删除表语句 ​ 在MySQL中可以通过DROP TABLE语句删除已存在的数据表，在删除表的同时也会删除表中的所有数据，其语法格式如下。 1DROP TABLE 表名; ​ 其中，&quot;表名&quot;表示需要删除的表。注意，此方法仅能删除没有被其他表关联的普通表。 代码示例： 1DROP TABLE 学生; 运行结果： 1Query OK, 0 rows affected (0.01 sec) ​ 执行上述的DROP TABLE语句后，再次查询javaTest数据库中的表，结果如下所示。 12mysql&gt; show tables;Empty set (0.01 sec) ​ 可以发现javaTest数据库为空，不存在数据表，说明学生表被删除成功。 MySQL 中的数据类型 ​ MySQL数据库提供了多种数据类，其中包括整数类型、浮点类型、定点数类型、日期时间类型、字符串类型和二进制类型。每一行数据类型都有各自的特性，其取值范围、存储的方式都不同。MysQL数据库数据类型如下表所示。 序号 类别 数据类型 长度(字节数) 说明 1 整数类型 TINYINT 1 如果为无符号数，其取值范围为 0～225；若为符号数， 则取值范围为-128～127 2 SMALLINT 2 如果为无符号数，其取值范围为 0～65535；若为符号 数，则取值范围为-32768~32767 3 MEDIUMINT 3 如果为无符号数，其取值范围为 0～16777215；若为 符号数，则取值范围为-8388638～8388637 4 INT 4 如果为无符号数，其取值范围为 0～4294967295；若 为符号数，则取值范围为-2147483648～2147483647 5 INTEGER 4 如果为无符号数，其取值范围为 0～4294967295；若 为符号数，则取值范围为-2147483648～2147483647 6 BIGINT 8 如果为无符号数，其取值范围为 0 ～ 18446744073709551615；若为符号数，则取值范围为 -9223372036854775808～9223372036854775807 7 浮点型和定点型 FOLAT 4 4 如果为负数，其取值范围为-3.402823466E+38～ -1.175494351E-38；若为非负数，则取值范围 0 和 1.175494351E-38～3.402823466E+38 8 DOUBLE 8 如果为负数，其取值范围为-1.7976931348623157E+308～ -2.2250738585072014E-308；若为非负数，则取值范围为 0和2.2250738585072014E-308～1.7976931348623157E+308 9 MECIMAL(M,D)或DEC(M,D) M+2 如果为负数，其取值范围为-1.7976931348623157E+ 308～-2.2250738585072014E-308；若为非负数，则取 值范围为 0 和 2.2250738585072014E-308 ～ 1.7976931348623157E+308 10 日期与时间类型 YEAR 1 其取值范围为 1901～2155，0 值为 0000 11 DATE 4 其取值范围为 1000-01-01 ～ 9999-12-31 ， 0 值为 0000:00:00 12 TIME 3 其取值范围为-838:59:59～838:59:59，0 值为 00:00:00 13 DATETIME 8 其取值范围为 1000-01-01 00:00:00 ～ 9999-12-31 23:59:59，0 值为 0000-00-00 00:00:00 14 TIMESTAMP 4 其取值范围为 19700101080001～20380119111407，0 值为 00000000000000 15 字符串类型 char(M) M 定长字符串 16 varchar(M) 最大为M 变长字符串 17 TEXT(文本)类型 TINYTEXT 最大255 允许的长度为 0～255 字节，存储空间为：值的长度 +2 个字节 18 TEXT 最大为64KB 允许的长度为 0～65535 字节，存储空间为：值的长 度+2 个字节 19 MEDIUMTEXT 最大为16MB 允许的长度为 0～167772150 字节，存储空间为：值 的长度+3 个字节 20 LONGTEXT 最大为4GB 允许的长度为 0～42949667295 字节，存储空间为： 值的长度+4 个字节 21 ENUM(枚举)类型 ENUM 1或2 最多可以取 65535 个值 22 SET类型 SET 8 最大可为64个不同的值 23 二进制类型 BINARY(M) 最大为M 定长二进制，字节数为 M，允许长度为 0～M 24 VARBINARY(M) 最大为M 可变二进制，允许长度为 0～M，字节数为值的长度 加 1 25 BIT(M) 最大为M M 最大为 64 26 TINYBLOB 最多为225 TINYBLOB 为大小写敏感，为可变二进制 27 BLOB 最大为64K BLOB 为大小写敏感，为可变二进制 28 MEDIUMBLOB 最大为16MB MEDIUMBLOB 为大小写敏感，为可变二进制 29 LONGBLOB 最大为4GB LONGBLOB 为大小写敏感，为可变二进制 ​ 读者可以根据自身的需求选择合适的数据类型，一般常用的数据类型有 INT、FLOAT、VARCHAR(M)、TEXT、DATE、TIME 和 BLOB。 参考书目： 《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"数据库概念","slug":"java/数据库/数据库概念","date":"2021-09-06T06:23:54.000Z","updated":"2021-10-27T04:43:35.368Z","comments":true,"path":"2021/09/06/java/数据库/数据库概念/","link":"","permalink":"https://silenthly.github.io/2021/09/06/java/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E5%BF%B5/","excerpt":"​ 数据库在程序开发中占有非常重要的地位，现在常用的数据库有Oracle、SQL Server和MySQL等，这些数据库主要是关系数据库。 ​ 目前关于数据库的概念，还没有一个明确的定义，主要原因是数据库是一门新兴的学科，它的概念、原理和方法都在不断的变化中发展。数据库的设计领域非常广泛，不同的学科给出了不同的定义。最为通用的定义为：数据库是指在计算机的存储设备上合理存放相关联、有结构的数据集合。","text":"​ 数据库在程序开发中占有非常重要的地位，现在常用的数据库有Oracle、SQL Server和MySQL等，这些数据库主要是关系数据库。 ​ 目前关于数据库的概念，还没有一个明确的定义，主要原因是数据库是一门新兴的学科，它的概念、原理和方法都在不断的变化中发展。数据库的设计领域非常广泛，不同的学科给出了不同的定义。最为通用的定义为：数据库是指在计算机的存储设备上合理存放相关联、有结构的数据集合。 ​ 以上的定义有如下定义： （1）数据库是在计算机上存放并运行的，属于计算机领域。 （2）数据库是一个数据集合。 （3）数据集合是有一定的结构的、相关联的数据集合。 （4）数据集合需要合理存放，也就是数据库的规范和优化。 ​ 数据库系统是一个比较复杂的系统，包括计算机的软件、硬件环境，以及数据库、数据库管理系统和数据库管理员等相互关联的多个部分。 注意：数据库不是数据库系统。 数据库系统的特点 ​ 自 20 世纪 60 年代后期以来，为了克服文件系统存在的问题，同时适应数据的处理需求，数据库技术因此应运而生。经过多年的发展，数据库系统一般具有以下主要的特点。 （1）数据结构化。 ​ 数据结构化是数据库系统与文件系统的根本区别。 ​ 在文件系统中整体上不存在结构化，并且数据的存放只有开发人员了解数据的含义和存放位置等。数据库系统中的数据是按照一定的数据模型来组织、描述和存储的，这个数据模型能够正确描述现实世界中各种数据组织和数据间的联系。 （2）数据冗余度小，共享性高，避免数据的不一致。 ​ 相同的数据在数据库中只会被存储一次，并被多个应用共享，所以大大降低了数据的冗余度，提高了共享性。如果一个数据多个地方存放，若需要修改，则必须修改所有地方的数据。一旦漏掉了一个地方，就会导致数据的不一致。 （3）具有较高的数据独立性。 ​ 数据的独立性是指数据库中的数据与应用程序的无关性。一般数据独立性可以分为数据的逻辑独立性和物理独立性。 ​ 逻辑独立性是指数据的全局逻辑与局部逻辑结构之间的相互独立性。当全局逻辑结构改变时，可以改变全局逻辑结构与局部逻辑结构之间的映射关系。而与某个具体的应用相关的逻辑结构不需要改变，因而应用程序也不需要改变。 ​ 物理独立性是指数据的存储结构与全局逻辑结构之间的相互独立性。当改变数据库中的存储结构时，不影响全局逻辑结构，只要不改变全局逻辑结构就不改变应用程序。 （4）数据由数据库管理系统（DBMS）统一管理和控制。 ​ 数据库管理系统提供了如下几种数据控制功能。 安全性控制，以防止数据的丢失、错误更新和越权使用等问题，而造成的数据泄密和破坏。 完整性控制，是将数据控制在一个有效的范围内或使数据满足一定的关系，以保证数据的正确性、有效性和相容性。 并发控制，使在同一时间周期内，允许对数据实现多路存取，又可以防止用户之间的不正常交互作用。 数据库的故障、发现和恢复。 数据库的分类 ​ 数据库中常用的数据类型有4种，分别是层次模型、网状模型、关系模型和面向对象模型。 层次模型 ​ 层次模型是按照层次结构表示实体集与实体集之间的联系模型。层次模型中用结点表示实体集，结点之间联系基本方式是1：n，如下图所示。 ​ 层次模型一般满足以下条件： 有且只有一个结点没有双亲结点（即根结点）。 根结点以外的其他结点有且只有一个双亲结点。 ​ 层次模型的特点是结点之间的联系通过指针来实现，一般的常用方法有邻接法和链表法。由于采用指针实现记录间的联系，所以层次模型具有查询效率高、结构简单、层次分明和便于在计算机实现的优点。 ​ 但层次模型也是有缺点的，一是层次数据模式缺乏直接表达现实世界中非层次模型结构的复杂联系；二是层次顺序的严格限制，使得对插入或删除操作也带来了较多的限制， 并且查询子结点只能通过双亲结点。 网状结构 ​ 网状模型基本上消除了层次模型的限制，它不但允许一个以上的结点无双亲，而且允许一个结点有多个的双亲。在网状模型中是采用网络结构表示实体类型、实体间联系的数据模型，可以实现多对多的联系，如图所示。 ​ 网状模型的优点是可以直接描述和记录现实世界，记录之间的联系也是通过指针来实现的，查询效率高；缺点是结构和编程复杂，难掌握，不易使用。 关系模型 ​ 关系数据模型最重要的特征就是使用二维表表示现实世界实体之间的联系。关系型数据库也是当前最为流行的数据库模型。 面向对象模型 ​ 面向对象数据模型是面向对象程序设计方法与数据库技术结合的产物。它的目标是以更为接近人类思维的方式，来描述和记录现实世界实体及实体之间的联系。 参考书目： 《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"UDP程序设计","slug":"java/网络编程/UDP程序设计","date":"2021-08-29T13:14:23.000Z","updated":"2021-10-27T04:44:20.245Z","comments":true,"path":"2021/08/29/java/网络编程/UDP程序设计/","link":"","permalink":"https://silenthly.github.io/2021/08/29/java/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/UDP%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/","excerpt":"​ 在 TCP/IP 协议的传输层中，除了前面介绍过的 TCP 协议以外，还可以使用 UDP 协议。 UDP 是一种无连接的客户/服务器（C/S）通信协议，用于不可靠的点对点通信，适合对通信性能要求高但通信可靠性要求低的应用，还支持广播和多播通信方式。","text":"​ 在 TCP/IP 协议的传输层中，除了前面介绍过的 TCP 协议以外，还可以使用 UDP 协议。 UDP 是一种无连接的客户/服务器（C/S）通信协议，用于不可靠的点对点通信，适合对通信性能要求高但通信可靠性要求低的应用，还支持广播和多播通信方式。 UDP 简介 ​ 前面学习的 TCP 是所有操作都必须建立可靠的连接，这样肯定会浪费大量的系统资源。为了减小花销还可以使用另外一种传输协议——UDP。UDP 协议是一种面向非连接的协议，面向非连接指的是在正式通信前不必与对方先建立连接，不管对方状态就直接发送。 至于对方是否可以接收到这些数据内容，则 UDP 协议是无法控制的，因此说 UDP 协议是 一种不可靠的协议。UDP 适用于一次只传送少量数据、对可靠性要求不高的应用环境。 ​ 使用 UDP 发送的信息，对方不一定会接收到，所有的信息使用数据报的形式发送出 去对于基于 UDP 协议的通信双方而言，没有明显的客户端和服务器端的概念。在 Java 中使用 DatagramPacket 类和 DatagramSocket 类完成 UDP 程序的开发。 DatagramPacket 类 ​ java.net 包中的 DatagramPacket 类用来表示数据包。DatagramPacket 类的常用方法如下表所示。 序号 方法 类型 说明 1 public DatagramPacket(byte[] buf,int length) 构造 构造DatagramPacket对象，用来接收长度为length的数据包 2 public DatagramPacket(byte[] bug,int length,InetAddress address,int port) 构造 构造DatagramPacket对象，用来将长度为length的包发送到指定主机上的指定端口 3 public DatagramPacket(byte[] buf,int offset,int length) 构造 构造DatagramPacket对象，用来接收长度为length的包，在缓冲区中指定了偏移量 4 public DatagramPacket(byte[] buf,int offset,int length,InetAddress address,int port) 构造 构造DatagramPacket对象，用来发送长度为length偏移量为offset的包，发送到指定主机上的指定端口号 5 public DatagramPacket(byte[] buf,int offset,int length,SocketAddress address)throws SocketException 构造 构造DatagramPacket对象，用来发送长度为length偏移量为offset的包，发送到指定主机上的指定端口号 6 public DatagramPacket(byte[] bug,int length,SocketAddress address)throws SocketException 构造 构造DatagramPacket对象，用来将长度为 length 的包 发送到指定主机上的指定端口号 7 public InetAddress getAddress() 普通 获取将要发往机器或从该机器接收到的IP地址 8 public byte[] getData() 普通 获取数据缓冲区信息 9 public int getLength() 普通 获取将要发送或接收到的数据长度 10 public int getOffset() 普通 获取将要发送或接收到的数据偏移量 11 public int getPort() 普通 获取将要发往该主机或者是从该主机接收到的端口号 12 public SocketAddress getSocketAddress() 普通 获取要将此包发送到的或发出此数据报的远程主机的SocketAddress（通常为IP地址 + 端口号） 13 public void setAddress(InetAddress iaddr) 普通 设置接收数据包的远程主机的IP地址 14 public void setData(byte[] buf) 普通 为此包设置数据缓冲区 15 public void setData(byte[] buf, int offset, int length) 普通 为此包设置数据缓冲区 16 public void setLength(int length) 普通 为此包设置长度 17 public void setPort(int iport) 普通 设置接收数据包的远程主机的端口号 18 public void setSocketAddress(SocketAddress address) 普通 设置要将此数据报发往的远程主机的 SocketAddress（通常为 IP 地址+端口号） DatagramSocket 类 ​ DatagramSocket 类用于创建接收或发数据报的 Socket 对象。在 C/S 程序中使用 UDP 协议时，实际上并没有明显的服务端与客户端的区别。因为通信双方都需要先建立一个 DatagramSocket 对象，用来接收或发送数据报，然后使用 DatagramPacket 对象作为传输数据的载体。DatagramSocket 类的常用方法如下表所示。 序号 方法 类型 说明 1 public DatagramSocket() throws Socket Exception 构造 创建一个 DatagramSocket 对象并将其绑定到本地主机上任何可用的端口 2 public DatagramSocket(int port) throws SocketException 构造 创建一个 DatagramSocket 对象并将其绑定到本地主机上的指定端口 3 public DatagramSocket(int port,InetAddress laddr)throws SocketException 构造 创建一个 DatagramSocket 对象，将其绑定到指定的本地地址 4 public DatagramSocket(SocketAddress bindaddr) throws SocketException 构造 创建一个 DatagramSocket 对象，将其绑定到指定的本地套接字地址 5 public void bind(SocketAddress addr) throws SocketException 普通 将此 DatagramSocket 绑定到特定的SocketAddress（通常为 IP 地址+端口号） 6 public void close() 普通 关闭此数据报套接字 7 public void connect(InetAddress address, int port) 普通 将套接字连接到远程主机的地址和端口 8 public void connect(SocketAddress addr) throws SocketException 普通 将此套接字连接到远程套接字地址（IP 地 址+端口号） 9 public void disconnect() 普通 断开套接字的连接 10 public InetAddress getInetAddress() 普通 获取 DatagramSocket 对象连接的地址 11 public InetAddress getLocalAddress() 普通 获取此 DatagramSocket 对象绑定的本地 地址 12 public int getLocalPort() 普通 获取此 DatagramSocket 对象绑定的本地 主机上的端口号 13 public int getPort() 普通 获取此 DatagramSocket 对象的端口 14 public int getTrafficClass() throws Socket Exception 普通 为从此 DatagramSocket 上发送的包获取 IP 数据报头中的流量类别或服务类型 15 public boolean isBound() 普通 判断此 DatagramSocket 绑定状态。若成功地绑定到一个地址，则返回 true，否则返回 false 16 public boolean isClosed() 普通 判断此 DatagramSocket 是否已关闭。 17 public boolean isConnected() 普通 判断此 DatagramSocket 的连接状态。若成功地连接到服务器，则返回 true，否则返回 false 18 public void receive(DatagramPacket p) throws IOException 普通 从此 DatagramSocket 对象接收数据报包 19 public void send(DatagramPacket p) throws IOException 普通 从此 DatagramSocket 对象发送数据报包 UDP 程序实现 客户端： 1234567891011121314151617181920212223242526272829import java.io.*;import java.net.*;import java.util.*;public class UDPTest01&#123; public static void main(String[] args) &#123; DatagramPacket dpack=null; DatagramSocket dsocket=null; byte b[]=new byte[512]; //定义接收数据的大小 try &#123; dsocket=new DatagramSocket(8000); //绑定本地端口 dpack=new DatagramPacket(b,512); //创建数据包 System.out.println(&quot;等待数据......&quot;); while(true) &#123; dsocket.receive(dpack); //接收数据包 String msg=new String(dpack.getData(),0,dpack.getLength()); System.out.println(&quot;远程计算机的IP地址：&quot;+dpack.getAddress().getHostAddress()); //获取发送数据包的主机IP System.out.println(&quot;远程计算机的端口：&quot;+dpack.getPort()); System.out.println(&quot;接收到的信息：&quot;+msg); &#125; &#125;catch(Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; ​ 以上程序运行之后，客户端就会打开指定的端口进行监听，等待服务端发送来的数据。下面再编写服务端程序。 服务端： 123456789101112131415161718192021222324252627282930import java.net.*;import java.util.*;public class UDPTest02&#123; public static void main(String[] args) &#123; DatagramSocket dsocket=null; DatagramPacket dpack=null; Scanner scan=new Scanner(System.in); try &#123; InetAddress local=InetAddress.getLocalHost(); //获取本地IP地址 dsocket=new DatagramSocket(8001); //绑定本地端口 String mag=null; byte b[]=null; while(true) &#123; System.out.println(&quot;发送消息：&quot;); mag=scan.next(); b=mag.getBytes(); dpack=new DatagramPacket(b,b.length,local,8000); /*创建发送数据包*/ dsocket.send(dpack); &#125; &#125;catch(Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; ​ 服务端运行后可以向客户端发送消息，客户端接收到消息后将其显示，运行结果如下： 参考链接： UDP接受数据时候缺失_weixin_45836865的博客-CSDN博客 参考书目： 《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"TCP 程序设计","slug":"java/网络编程/TCP-程序设计","date":"2021-08-28T04:54:31.000Z","updated":"2021-10-27T04:44:25.821Z","comments":true,"path":"2021/08/28/java/网络编程/TCP-程序设计/","link":"","permalink":"https://silenthly.github.io/2021/08/28/java/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/TCP-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/","excerpt":"​ TCP/IP 协议是一种可靠的网络协议，它在通信的两端分别建立一个 Socket，从而在通信的两端形成网路虚拟链路。只有虚拟的网络链路建立了，双方才可以进行通信。进行 TCP 网络编程需要使用两个类，一个是服务器套接字 ServerSocket 类，另一个是客户端套接字 Socket 类。","text":"​ TCP/IP 协议是一种可靠的网络协议，它在通信的两端分别建立一个 Socket，从而在通信的两端形成网路虚拟链路。只有虚拟的网络链路建立了，双方才可以进行通信。进行 TCP 网络编程需要使用两个类，一个是服务器套接字 ServerSocket 类，另一个是客户端套接字 Socket 类。 ServerSocket 类 ​ ServerSocket 类用来为服务端建立套接字，它的主要功能是等到来自网络中其他客户端的请求。ServerSocket 类可以指定端口等待连接的套接字，服务器的套接字一次只能与一个客户端套接字相连。 ​ 如果多态客户端同时请求连接，服务器会将请求连接的客户端放入队列中，然后从中取出一个套接字与服务器的套接字相连。若请求数大于最大的容纳数，则多余出来的请求就会被拒绝，最大容纳数默认为 50。ServerSocket 类的常用方法如下表所示。 序号 方法 类型 说明 1 public ServeSocket()throws IOException 构造 创建非绑定服务器套接字 2 public ServeSocket(int port)throws IOException 构造 创建绑定到特定端口的服务器套接字 3 public ServeSocket(int port,int backing)throws IOException 构造 利用指定的 backlog 创建服务器套接字并 将其绑定到指定的本地端口号 4 public ServeSocket(int port,int backing,InetAddress bindAddr)throws IOException 构造 使用指定的端口、侦听backlog和要绑定到的本地IP地址创建服务器。这个情况适应于计算机上存在多个网卡多个IP地址的时候，使用该构造方法可以明确规定ServerSocket在哪块网卡或哪个IP地址等待连接请求 5 public void bind(SocketAddress endpoint)throws IOException 普通 将ServerSocket绑定到特定地址（IP地址和端口号） 6 public void bind(SocketAddress endpoint,int bocklog)throws IOException 普通 将ServerSocket绑定到特定地址（IP地址和端口号） 7 public void close()throws IOException 普通 关闭此套接字 8 public ServerSocketChannel getChannel() 普通 返回与此套接字关联的唯一 ServerSocketChannel 对象 9 public InetAddress getInetAddress() 普通 返回此服务器套接字的本地地址 10 public int getLocalPort() 普通 返回此套接字上侦听的端口 11 public SocketAddress getLocalSocketAddress() 普通 返回此套接字绑定的端点地址，如果尚未绑定，则返回 null 12 public boolean isBound() 普通 返回 ServerSocket 的绑定状态 13 public boolean isClosed() 普通 判断 ServerSocket 是否关闭；若已经关闭了套接字，则返回 true，否则返回 false 14 public static void setSocketFactory(Socket ImplFactory fac) 静态 设置应用程序的服务端套接字实现工厂 15 public Socket accept() throws IOException 普通 侦听并接受客户端的连接。若连接成功， 则创建一个套接字 16 public String toString() 普通 作为 String 返回此套接字的实现地址和实现端口 ​ 当 ServerSocket 类的对象创建后，调用 accept()方法接收客户端发来的连接请求。accept() 方法采用的是“阻塞”方式监听，直到客户端连接之后程序才可以向下继续执行并返回一个与客户端 Socket 对象相连的 Socket 对象。服务器端的 Socket 对象使用 getOutputStream() 方法获得的输出流，将指向客户端Socket对象使用getInputStream()方法获得的那个输入流。 同样地，服务器端的 Socket 对象使用 getInputStream()方法获得的输入流，将指向客户端 Socket 对象使用 getOutputStream()方法获得的那个输出流。 Socket 类 ​ 在 Java 中，有专门的 Socket 类来处理用户的请求和响应。利用 Socket 类的方法，就可以实现两台计算机之间的通信。客户端创建 Socket 对象之后，会向指定的 IP 地址即端口尝试连接。服务端的 Socket 接到连接请求后创建新的 Socket 与客户端的 Socket 进行连接。若服务端 Socket 与客户端 Socket 连接成功之后，就可以获取 Socket 中的输入/输出流。 Socket 类的常用方法如下表所示。 序号 方法 类型 说明 1 public Socket() 构造 创建非绑定服务器套接字 2 public Socket(InetAddress address,int port)throws IOException 构造 创建一个流套接字并将其连接到指定 IP 地址的指定端口号 3 public Socket(InetAddress address,int port,InetAddress localAddr,int localport)throws IOException 构造 创建一个套接字并将其连接到指定远程地址上的指定远程端口 4 public Socket(Porxy proxy) 构造 创建一个未连接的套接字并指定代理类型（如果有），该代理不管其他设置如何都应被使用 5 public Socket(String host, int port) throws UnknownHostException,IOException 构造 创建一个流套接字并将其连接到指定主机上的指定端口号 6 public Socket(String host, int port, InetAddress localAddr, int localPort) throws IOException 构造 创建一个套接字并将其连接到指定远程主机上的指定远程端口 7 public void bind(SocketAddress bindpoint)throws IOException 普通 将套接字绑定到本地地址 8 public void close() throws IOException 普通 关闭此套接字 9 public void connect(SocketAddress endpoint)throws IOException 普通 将此套接字连接到服务器 10 public void connect(SocketAddress endpoint, int timeout) throws IOException 普通 将此套接字连接到服务器，并指定一个超时值 11 public InetAddress getInetAddress() 普通 返回套接字连接的地址 12 public InetAddress getLocalAddress() 普通 获取套接字绑定的本地地址 13 public InputStream getInputStream() throws IOException 普通 返回此套接字的输入流 14 public OutputStream getOutputStream() throws IOException 普通 返回此套接字的输出流 15 public int getLocalPort() 普通 返回此套接字绑定到的本地端口 16 public SocketAddress getLocalSocketAddress() 普通 返回此套接字绑定的端点地址，如果尚未绑定则返回 null 17 public int getPort() 普通 返回此套接字连接到的远程端口 18 public SocketAddress getRemoteSocketAddress() 普通 返回此套接字连接的端点地址，如果未连接则返回 null 19 public int getTrafficClass() throws Socket Exception 普通 为从此 Socket 上发送的包获取 IP 头中的流量类别或服务类型 20 public boolean isBound() 普通 判断套接字是否绑定，若套接字成功地绑定到一个地址，则返回 true，否则返回 false 21 public boolean isClosed() 普通 判断 Socket 是否关闭，若已经关闭了套接字，则返回 true，否则返回 false 22 public boolean isConnected() 普通 判断套接字是否连接上服务器，若套接字成功地连接到服务器，则为 true，否则返回 false 23 public void sendUrgentData(int data) throws IOException 普通 在套接字上发送一个紧急数据字节 24 public static void setSocketImplFactory (SocketImplFactory fac) throws IOException 普通 设置应用程序的客服端套接字实现工厂 25 public void shutdownInput() throws IOException 普通 此套接字的输入流置于“流的末尾” 26 public void shutdownOutput() throws IOException 普通 禁用此套接字的输出流 27 public String toString() 普通 将此套接字转换为 String ​ 在 Socket 类中的诸多方法中，最常用的是 getInputStream()和 getOutputStream()方法，这两个是实际通信中必须使用的方法。 Socket 通信过程：一对一的 TCP 程序 ​ 下面使用 ServerSocket 类和 Socket 类来完成一个服务端的程序开发，代码如下。 服务端程序： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.io.*;import java.net.*;import java.util.*;public class ServerTest&#123; public static void main(String[] args) &#123; ServerSocket server=null; Socket socket=null; DataInputStream din=null; DataOutputStream dout=null; try &#123; server=new ServerSocket(8000); //创建一个绑定8000端口的服务套接字 System.out.println(&quot;等待客服连接上......&quot;); socket=server.accept(); //阻塞等待客服端的连接 System.out.println(&quot;客户端连接上......\\n客户端来自：&quot;+socket.getInetAddress().getHostAddress()); //获取客户端的IP地址 din=new DataInputStream(socket.getInputStream()); //获取客户端的输入流 dout=new DataOutputStream(socket.getOutputStream()); //获取客户端的输出流 String strMassage=null; Scanner scan=new Scanner(System.in); boolean flag=true; //标记位 while(flag) &#123; strMassage=din.readUTF(); //读取客户端发送的信息 if(!strMassage.equals(&quot;bye&quot;)) //若消息为bye则退出，否则继续 &#123; System.out.println(&quot;客户端消息：\\n&quot;+strMassage); System.out.println(&quot;回复客户端：&quot;); strMassage=scan.next(); //输入信息 dout.writeUTF(strMassage); //向客户端发送消息 dout.flush(); &#125;else &#123; din.close(); dout.close(); flag=false; &#125; &#125; server.close(); //关闭服务端 System.out.println(&quot;服务器退出......&quot;); &#125;catch(Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; ​ 在以上程序中服务端运行之后要等待客户端的连 接，采用的是阻塞方式。下面编写客户端的程序，代码如下。 客户端： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.io.*;import java.net.*;import java.util.*;public class ClientTest&#123; public ClientTest()&#123;&#125; public static void main(String[] args) &#123; Socket socket=null; DataInputStream din=null; DataOutputStream dout=null; try &#123; System.out.println(&quot;尝试连接服务器......&quot;); socket=new Socket(&quot;127.0.0.1&quot;,8000); System.out.println(&quot;连接服务器成功......&quot;); din=new DataInputStream(socket.getInputStream()); dout=new DataOutputStream(socket.getOutputStream()); String strMassage=null; Scanner scan=new Scanner(System.in); boolean flag=true; while(flag) &#123; System.out.println(&quot;发送消息：&quot;); strMassage=scan.next(); dout.writeUTF(strMassage); //向服务端发送消息 dout.flush(); strMassage=din.readUTF(); //读取服务器消息 if(!strMassage.equals(&quot;bye&quot;)) &#123; System.out.println(&quot;接收信息：\\n&quot;+strMassage); &#125;else &#123; din.close(); dout.close(); flag=false; &#125; &#125; socket.close(); //关闭客户端 System.out.println(&quot;服务器退出......&quot;); &#125;catch(Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 客户端运行并连接上服务端后，可以向服务端发送消息，服务端接收到消息后也可以向客户端发送消息。运行结果如图所示： ​ 可以看到，先输入&quot;bye&quot;结束对话的一端，会因为另一端的结束而抛出异常。在以上程序中存在一个很大的缺点，就是服务端一次只能与一个客户端相连，因为该程序属于单线程的处理机制。为了让服务端可以同时连接多个客户端，可以加入多线程处理机制。 Socket 通信过程：一对多的 TCP 程序 ​ 在服务端加入多线程之后，当每一个客户端连接上服务端时，就启动一个新的线程。这样的好处是每一个 Socket 对象执行完成之后，只有包含该 Socket 对象的线程终止，而不会对其他的线程产生影响。开启多线程也会消耗更多的计算机资源，因为服务端可以连接的客户端数量是有限的。下面编写一个 ServerThread 类专门处理多线程操作，代码如下。 处理多线程： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.io.*;import java.net.*;import java.util.*;public class ServerThread implements Runnable&#123; private Socket socket; public ServerThread()&#123;&#125; public ServerThread(Socket socket) &#123; this.socket=socket; &#125; public void run() &#123; DataInputStream din=null; DataOutputStream dout=null; try &#123; System.out.println(&quot;客户端连接上......\\n客户端来自：&quot;+socket.getInetAddress().getHostAddress()); din=new DataInputStream(socket.getInputStream()); dout=new DataOutputStream(socket.getOutputStream()); String strMassage=null; Scanner scan=new Scanner(System.in); boolean flag=true; while(flag) &#123; strMassage=din.readUTF(); //读取客户端发送的消息 if(!strMassage.equals(&quot;bye&quot;)) &#123; System.out.println(&quot;客户端信息：&quot;+strMassage); System.out.println(&quot;回复客户端：&quot;); strMassage=scan.next(); dout.writeUTF(strMassage); dout.flush(); &#125;else &#123; din.close(); dout.close(); flag=false; &#125; &#125; socket.close(); //关闭服务器 System.out.println(&quot;服务器退出......&quot;); &#125;catch(Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 再编写一个主类来使用 ServerThread 类，范例如下。 123456789101112131415161718192021222324import java.io.*;import java.net.*;import java.util.*;public class ServerTest01&#123; public static void main(String[] args) &#123; ServerSocket server=null; Socket socket=null; try &#123; server=new ServerSocket(8000); System.out.println(&quot;等待客户端连接......&quot;); while(true) &#123; socket=server.accept(); new Thread(new ServerThread(socket)).start(); &#125; &#125;catch(Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; ​ 客户端就是前面的范例，无须任何修改.在 ServerTest01 运行时，可以同时与多个客户端进行通信，每一个客户端的 Socket 都会以一个线程的方式运行。运行结果如下： ​ 从程序运行结果发现，服务端的确可以连接多个客户端，但如果多个客户端同时发送消息时，需要按照客户端消息发送顺序回复。 牛刀小试 请编写一个简单的端口扫描程序。要求： 可以指定扫描的 IP。 可以指定扫描的 IP。 ​ 通过 Socket 类尝试与指定主机的指定端口建立连接，以检查该主机的某些端口是否活动。如果在建立与一个端口的连接时未抛出任何异常，则表明该端口是活动的，代码如下。 1234567891011121314151617181920212223242526272829303132333435import java.io.*;import java.net.*;import java.util.*;public class Test&#123; public static void main(String[] args) throws Exception &#123; Scanner scan=new Scanner(System.in); System.out.println(&quot;请输入IP地址：&quot;); String ip=scan.next(); System.out.println(&quot;请输入起始端口号：&quot;); int from=scan.nextInt(); System.out.println(&quot;请输入终止端口号：&quot;); int end=scan.nextInt(); Socket socket=null; int port=0; System.out.println(&quot;扫描中......&quot;); for(port=from;port&lt;=end;port++) &#123; try &#123; socket=new Socket(ip,port); System.out.println(&quot;活动端口：&quot;+port); &#125;catch(ConnectException e) &#123; System.out.println(port+&quot;端口关闭&quot;); &#125; if(socket!=null) &#123; socket.close(); &#125; &#125; System.out.println(&quot;扫描结束......&quot;); &#125;&#125; 运行结果： 123456789101112131415请输入IP地址：14.215.177.38请输入起始端口号：78请输入终止端口号：84扫描中......78端口关闭79端口关闭活动端口：8081端口关闭82端口关闭83端口关闭84端口关闭扫描结束...... ​ 以上用于测试的IP地址为百度的IP地址。 参考书目： 《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com) 相关链接： backlog参数对TCP连接建立的影响 - SegmentFault 思否","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"URL类和URLConnection类","slug":"java/网络编程/URL类和URLConnection类","date":"2021-08-27T00:23:45.000Z","updated":"2021-10-27T04:44:31.368Z","comments":true,"path":"2021/08/27/java/网络编程/URL类和URLConnection类/","link":"","permalink":"https://silenthly.github.io/2021/08/27/java/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/URL%E7%B1%BB%E5%92%8CURLConnection%E7%B1%BB/","excerpt":"​ IP 地址可以唯一地标识网络中的主机，而 URL 可以标识网络中服务器上的资源。java 中提供了 URL 类来访问封装 URL 相关的数据信息。使用 URL 类和 URLConnection 类都能实现对一个服务器的访问，并获取服务器上的资源。","text":"​ IP 地址可以唯一地标识网络中的主机，而 URL 可以标识网络中服务器上的资源。java 中提供了 URL 类来访问封装 URL 相关的数据信息。使用 URL 类和 URLConnection 类都能实现对一个服务器的访问，并获取服务器上的资源。 URL 类 ​ URL 类代表一个统一资源定位符，它是指向互联网“资源”的指针。资源可以是简单的文件或目录，也可以是对更为复杂的对象引用，例如对数据库或搜索引擎的查询。每一 个 URL 对象都封装了资源标识符和协议处理程序。获得 URL 对象的方式有多种，一种是 调用 URI 的 toURL()方法，另一种是直接调用 URL 的构造方法来建立 URL 对象。URL 类 的常用方法如下表所示。 序号 方法 类型 说明 1 public URL(String spce)throws Malformed URLException 构造 根据指定的地址创建 URL 对象 2 public URL(String protocol,String host,int port,String file)throws Malformed URLException 构造 根据指定 protocol、host、port 号和 file 创 建 URL 对象 3 public URL(String protocol,String host,String file)throws Malformed URLException 构造 根据指定的 protocol 名称、host 名称和 file 名称创建 URL 对象 4 public URL(URL context,String spce)throws Malformed URLException 构造 使用指定的 URL 对象 context 作为基本地址，使用参数 spec 作为相对路径来创建 URL 对象 5 public Object getContent()throws Exception 普通 获取此 URL 的内容 6 public Object getContent(Class[] classes)throws Exception 普通 获取此 URL 的内容 7 public int getDefaultPort() 普通 获取与此 URL 关联协议的默认端口号 8 public String getFile() 普通 获取此 URL 的文件名 9 public String getHost() 普通 获取此 URL 的主机名 10 public String getPath() 普通 获取此 URL 的路径部分 11 public int getPort() 普通 获取此 URL 的端口号，如果未设置端口号，则返回 -1 12 public String getProtocol() 普通 获取此 URL 的协议名称 13 public String getQuery() 普通 获取此 URL 的查询组成 14 public String getRef() 普通 获取此 URL 的锚点（也称为“引用”） 15 public String getUserInfo() 普通 获取此 URL 的用户信息 16 public InputStream openStream() throws IOException 普通 打开到此 URL 的连接并返回一个用于从该连接读入的 InputStream 17 public boolean sameFile(URL other) 普通 比较两个 URL，不包括片段部分 18 protected void set(String protocol,String host,int port,String file,String ref) 普通 设置 URL 的字段 19 protected void set(String protocol, String host, int port, String authority, String userInfo, String path, String query, String ref) 普通 设置 URL 的指定的 8 个字段 20 public String toString() 普通 构造此 URL 的字符串表示形式 21 public URI toURI() throws URISyntax Exception 普通 返回与此 URL 等效的 URI 22 public URLConnection openConnection() 普通 返回一个URLConnection实例，该实例表示与URL引用的远程对象的连接。。 ​ 详细解释可查看API帮助文档，下面通过一个范例来演示 URL 类的应用。 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.net.URL;import java.net.UnknownHostException;import java.util.Scanner;import java.io.InputStream;import java.io.InputStreamReader;import java.io.BufferedReader;public class Test&#123; public static void main(String[] args) &#123; System.out.println(&quot;请输入URL：&quot;); Scanner scan=new Scanner(System.in); String urls=scan.next(); URL url=null; try &#123; url=new URL(urls); &#125;catch(Exception e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;主机：&quot;+url.getHost()); System.out.println(&quot;路径：&quot;+url.getPath()); System.out.println(&quot;端口号：&quot;+url.getPort()); System.out.println(&quot;协议：&quot;+url.getProtocol()); System.out.println(&quot;用户信息：&quot;+url.getUserInfo()); System.out.println(&quot;查询组成：&quot;+url.getQuery()); System.out.println(&quot;网页内容：&quot;); try &#123; InputStream in=url.openStream(); BufferedReader bin=new BufferedReader(new InputStreamReader(in)); String strLine=null; while((strLine=bin.readLine())!=null) &#123; System.out.println(strLine); &#125; bin.close(); &#125;catch(Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 运行结果： 123456789101112131415161718192021请输入URL：https://gitee.com/silenthty/silenthty.git主机：gitee.com路径：/silenthty/silenthty.git端口号：-1协议：https用户信息：null查询组成：null网页内容：&lt;!DOCTYPE html&gt;&lt;html lang=&#x27;zh-CN&#x27;&gt;&lt;head&gt;&lt;title&gt;silenthty/silenthty&lt;/title&gt;&lt;meta content=&#x27;on&#x27; http-equiv=&#x27;x-dns-prefetch-control&#x27;&gt;&lt;link href=&#x27;//e.gitee.com&#x27; rel=&#x27;dns-prefetch&#x27;&gt;&lt;link href=&#x27;//files.gitee.com&#x27; rel=&#x27;dns-prefetch&#x27;&gt;&lt;link href=&#x27;//toscode.gitee.com&#x27; rel=&#x27;dns-prefetch&#x27;&gt;&lt;link href=&#x27;https://assets.gitee.com&#x27; rel=&#x27;dns-prefetch&#x27;&gt;&lt;link href=&#x27;https://portrait.gitee.com&#x27; rel=&#x27;dns-prefetch&#x27;&gt;&lt;link href=&quot;https://assets.gitee.com/assets/favicon-9007bd527d8a7851c8330e783151df58.ico&quot; rel=&quot;shortcut icon&quot; type=&quot;image/vnd.microsoft.icon&quot; /&gt;......(以下省略) ​ 以上程序中输出的网页内容是网页的源代码，而不是显示的内容。 URLConnection 类 ​ URLConnection 类的对象可以与指定 URL 建立动态的连接。同时使用 URLConnection 类的对象可以实现向服务器发送请求，将数据送回服务器并检查远程资源的一些属性。一 般创建 URLConnection 类对象使用的是 URL 的 openConnection()方法。URLConnection 类的常用方法如下表所示。 序号 方法 类型 说明 1 public int getConnectTimeout() 普通 返回连接超时设置 2 public Object getContent() throws IOException 普通 获取此 URL 连接的内容 3 public Object getContent(Class[] classes) throws IOException 普通 获取此 URL 连接的内容 4 public String getContentEncoding() 普通 获取文件的编码 5 public int getContentLength() 普通 获取文件的大小 6 public String getContentType() 普通 获取文件的类型 7 public long getDate() 普通 获取文件的日期 8 public InputStream getInputStream() 普通 返回从此打开的连接读取的输入流 9 public long getLastModified() 普通 获取文件最后修改的时间 10 public OutputStream getOutputStream() 普通 返回写入到此连接的输出流 11 public int getReadTimeout() 普通 返回读入超时设置 12 public URL getURL() 普通 返回此 URLConnection 的 URL 字段的值 13 public void setConnectTimeout(int timeout) 普通 设置一个指定的超时值（以 ms 为单位）， 该值将在打开到此 URLConnection 引用的资源的通信链接时使用 ​ 下面通过 URLConnection 类来演示如何获取指定 URL 的基本信息。 1234567891011121314151617181920212223242526272829303132333435363738394041import java.net.URL;import java.net.URLConnection;import java.io.*;public class Test&#123; public static void main(String[] args) &#123; URL url=null; URLConnection urlc=null; try &#123; url=new URL(&quot;http://www.baidu.com/index.html&quot;); urlc=url.openConnection(); &#125;catch(Exception e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;文件大小：&quot;+urlc.getContentLength()); System.out.println(&quot;文件类型：&quot;+urlc.getContentType()); try &#123; InputStream in=urlc.getInputStream(); BufferedInputStream bin=new BufferedInputStream(in); FileOutputStream fout=new FileOutputStream(&quot;index.html&quot;); int len=0; byte b[]=new byte[1024]; System.out.println(&quot;=====下载页面=====&quot;); while((len=bin.read(b,0,1024))!=-1) &#123; fout.write(b,0,len); &#125; fout.close(); bin.close(); in.close(); System.out.println(&quot;-----下载结束-----&quot;); &#125;catch(Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 运行结果： 1234文件大小：2381文件类型：text/html=====下载页面=====-----下载结束----- ​ 下载结果可以在与程序的同一目录中查看。以上程序中可以获取远程资源的一些基本信息，如文件的大小和文件类型，还可以将文件下载 到本机上，当然，有些网站需要先提出请求，才能获取资源信息。 参考链接： java 网络编程（四） InetAddress类 - 圣骑士wind - 博客园 (cnblogs.com) 参考书目： 《java编程手记——从实践中学习java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com) 实战java程序设计 - 北京尚学堂科技有限公司 编著 | 豆瓣阅读 (douban.com) 《疯狂java讲义(第3版)(含光盘)》【摘要 书评 试读】- 京东图书 (jd.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Inetaddress类","slug":"java/网络编程/Inetaddress类","date":"2021-08-26T13:14:23.000Z","updated":"2021-10-27T04:44:44.355Z","comments":true,"path":"2021/08/26/java/网络编程/Inetaddress类/","link":"","permalink":"https://silenthly.github.io/2021/08/26/java/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Inetaddress%E7%B1%BB/","excerpt":"​ 在 Internet 上的主机（服务器）地址有两种表示方式，一种是 IP 地址，另一种是域名。有时使用 IP 地址来查找域名，有时使用域名来查找 IP 地址。在 java。net 包中提供了 Ineraddress 类来完成这个任务。","text":"​ 在 Internet 上的主机（服务器）地址有两种表示方式，一种是 IP 地址，另一种是域名。有时使用 IP 地址来查找域名，有时使用域名来查找 IP 地址。在 java。net 包中提供了 Ineraddress 类来完成这个任务。 ​ Inetaddress 类可以用来表示 IP 地址，该类有两个子类 Inet4Address 和 Inet6Address，分别表示 IPv4 和 IPv6。InetAddress 类没有提供构造方法，但可以通过类中的静态方法getAllByName()、getByAddress()、getByName()和 getLocalHost()获取 InetAddress 类的实例，其常用方法如下表所示。 序号 方法 类型 说明 1 public byte[] getAddress() 普通 返回此InetAddress对象的IP地址 2 public static InetAddress[] getAllByName(String host)throws UnknownHostException 静态 在给定主机名的情况下，根据系统上配置的名称服务返回其 IP 地址所组成的数组 3 public static InetAddress getByAddress(byte[] addr) 静态 根据给定原始IP地址返回InetAddress对象。 4 public static InetAddress getByAddress(String host,byte[] addr)throws UnknownHostException 静态 根据提供的主机名和IP地址创建InetAddress对象 5 public static InetAddress getByName(String host)throws UnknownHostException 静态 根据主机获取对应的InetAddress对象 6 public String getCanonicalHostName() 普通 获取此IP地址的完全限定域名 7 public String getHostAddress() 普通 返回IP地址字符串 8 public String getHostName() 普通 获取此IP地址的主机名 9 public static InetAddress getLocalHost()throws UnknownHostException 静态 获取本地IP地址对应的InetAddress对象 10 public boolean isLoopbackAddress() 普通 检查InetAddress是否为回送地址 11 public boolean isReachable(int timeout) 普通 判断在限定时间内是否可以访问该地址，若可达到，则返回true，否则返回false 12 public boolean isReachable(NetworkInterface netif,int ttl,int timeout) 普通 判断是否可以达到该地址，若可达到，则返回true，否则返回false 13 public boolean isSiteLocalAddress() 普通 检查InetAddress是否为站点本地地址 14 public String toString() 普通 将此IP地址转换为String ​ 以上主机名可以是IP地址，也可以是域名，下面通过范例来演示 InetAddress 类的应用。 ​ InetAddress 类提供了多个静态方法获取InetAddress对象，下面将介绍其中几个： getLocalHost()，仅返回象征本地主机的InetAddress对象 getByName()，返回一个传给它的主机名的InetAddress对象。 getAllByName()，在Internet上，用一个名称来代表多个机器是常有的事，此方法返回代表由一个特殊名称分解的所有地址的InetAddresses类数组。 代码示例： 123456789101112131415161718192021222324252627282930import java.net.InetAddress;import java.net.UnknownHostException;public class Test&#123; public static void main(String[] args) &#123; InetAddress localIP=null; InetAddress address1=null; InetAddress address2[]=null; try &#123; localIP=InetAddress.getLocalHost(); //获取本地主机地址 address1=InetAddress.getByName(&quot;www.baidu.com&quot;); address2=InetAddress.getAllByName(&quot;www.baidu.com&quot;); &#125;catch(UnknownHostException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;本地IP：&quot;+localIP.getHostAddress()); System.out.println(&quot;本地主机名：&quot;+localIP.getHostName()); System.out.println(&quot;address1的IP：&quot;+address1.getHostAddress()); System.out.println(&quot;address1的主机名：&quot;+address1.getHostName()); for(int i=0;i&lt;address2.length;i++) &#123; System.out.println(&quot;----------------------------&quot;); System.out.println(&quot;IP：&quot;+address2[i].getHostAddress()); System.out.println(&quot;主机名：&quot;+address2[i].getHostName()); &#125; &#125;&#125; 运行结果： 12345678910本地IP：192.168.3.24本地主机名：DESKTOP-IKTDJ54address1的IP：14.215.177.38address1的主机名：www.baidu.com----------------------------IP：14.215.177.38主机名：www.baidu.com----------------------------IP：14.215.177.39主机名：www.baidu.com ​ 在运行以上程序时，需要正常连入 Internet 中，否则是不能获取指定域名的 IP 的。","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"java网络编程","slug":"java/网络编程/java网络编程","date":"2021-08-25T00:32:03.000Z","updated":"2021-10-27T04:44:50.156Z","comments":true,"path":"2021/08/25/java/网络编程/java网络编程/","link":"","permalink":"https://silenthly.github.io/2021/08/25/java/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/","excerpt":"​ Java 最初是作为一种网络编程的语言出现的，因此 Java 具有强大的网络编程功能。为 了让 Java 开发人员能够方便快捷地进行网络程序设计，Java 的 JDK 中加入了大量与网络相关的类和接口。这些类和接口将多种 Internet 协议封装在其中，与其他的编程语言相比， Java 网络编程是更容易的。 ​ Java 编写的网络程序可以使用网络上的各种资源和数据，能够与服务器建立各类形式的连接和传输方式，能够让计算机之间实现通信。","text":"​ Java 最初是作为一种网络编程的语言出现的，因此 Java 具有强大的网络编程功能。为 了让 Java 开发人员能够方便快捷地进行网络程序设计，Java 的 JDK 中加入了大量与网络相关的类和接口。这些类和接口将多种 Internet 协议封装在其中，与其他的编程语言相比， Java 网络编程是更容易的。 ​ Java 编写的网络程序可以使用网络上的各种资源和数据，能够与服务器建立各类形式的连接和传输方式，能够让计算机之间实现通信。 网络编程的基础知识 ​ 在介绍网络程序设计之前，首先要对网络有一个基本的认识，了解一些网络的相关概念，如各种网络协议、IP 地址和端口等。 TCP/IP 协议——常用的传输协议 ​ 网络编程的主要目的就是为了实现直接或间接地通过网络与其他计算机进行通信。因此有两个问题需要解决：一是如何准确地定位网络上的一台或多台计算机；二是找到特定的计算机后如何快速、高效地进行数据传输。这就需要使用 TCP/IP 协议，它是 Internet 的主要协议，也是最常用的协议，定义了计算机和外部设备之间进行通信所使用的规则。 提示：按照网络覆盖的地理范围可将网络可以分为以下几类。 局域网（LAN）：作用范围一般为几米到几十公里。 城域网（MAN）：界于 WAN 与 LAN 之间。 广域网（WAN）：作用范围一般为几十到几千公里。 ​ TCP/IP 是 Transmission Control Protocol/Internet Protocol 的简写，中文含义是传输控制协议/因特网互联协议，亦称网络通信协议。TCP/IP 协议是 Internet 最基本的协议、Internet 国际互联网络的基础，由网络层的 IP 协议和传输层的 TCP 协议组成。与 OSI 开放式系统互联的参考模型不同，TCP/IP 协议只有 4 层而不是 7 层，如下图所示。 ​ TCP 传输控制协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。通过 TCP 协议传输得到一个顺序的无差错的数据流。在通信开始时，需要进行“三次握手”的 方式建立连接。连接一旦建立起来就可以进行双向数据传输，发送方和接收方都可以进行发送和接收操作。 ​ UDP 是 User Datagram Protocol 的简称，其中文含义是用户数据报协议，一种无连接的传输层协议，可以与 IP 协议一起使用。但 UDP 协议提供的是面向非连接的、简单的、不可靠的信息传送服务，它不对连接状态和数据丢失做检查，只是保证数据发送出去，就像平时使用的 QQ 或 MSM 一样，只是把消息发送出去不管对方是否在线。而使用 TCP 协议的连接是需要双方建立起连接，如视频的时候需要双方都在线。 IP 地址——计算机的标识 ​ 在 Internet 上，每一台通信实体（这个通信实体可以是路由器的某一端口、计算机和服务器等设备）都有一个唯一标识的 IP 地址。所有的 IP 地址都由国际组织 NIC（Network Information Center）负责统一分配。目前使用的主要还是 IPv4，是一种层次性地址，由网络号和主机号组成，如下图所示。 ​ 每个IP地址有32b，也就是4个字节，由4个小于256的正整数组成，数字之间使用&quot;.&quot;分隔。为了方便记忆，一般采用十进制的形式，这种方法称为“点分十进制记法”。 IP 地址被分成 A、B、C、D、E 这 5 个类别，每一个类别都有各自的规则，即网络号和主机号所在的位数。 A 类：地址范围为 1.0.0.1~126.255.255.255（二进制表示为：00000001 00000000 00000000 00000001 ~ 01111110 11111111 11111111 11111111）。 B 类：地址范围为 128.0.0.1~191.255.255.255（二进制表示为 10000000 00000001 00000000 00000001~10111111 11111111 11111111 11111111）。 C 类：地址范围为 192.0.0.0~223.255.255.255（二进制表示为 11000000 00000000 00000000 00000000 ~ 11011111 11111111 11111111 11111111）。 D 类：D 类 IP 地址是组播地址，地址范围为 224.0.0.0～239.255.255.255（二进制 表示为 11100000 00000000 00000000 00000000~11101111 11111111 11111111 11111111）。 E 类：主要用于 Internet 试验和开发，地址范围为 240.0.0.0~255.255.255.255（二进 制表示为 11110000 00000000 00000000 00000000~11111111 11111111 11111111 11111111）。 提示：原本属于 A 类地址范围内的 IP 地址 127.0.0.0~127.255.255.255 并不在 A 类地址内，因为任意以 127 开头的 IP 地址是回送地址，它是一个保留地址，最常见的为 127.0.0.1 。 C 类地址中的私有地址： 192.168.X.X 是私有地址 （192.168.0.0—192.168.255.255）。 ​ 一般来说，A类地址保留给政府机构，B类地址分配给中等规模的公司，C类地址分配给任何需要的人，D类用于组播，E类用于实验，各类可容纳的地址数目不同。A类、B类、和C类这三类地址用于TCP/IP节点，其它两类D类和E类被用于特殊用途。 端口——通信的窗口 ​ IP 地址可以准确地标识网络上唯一的一个通信实体。但通信实体上可以使用多个提供网络通信的程序，此时还需要使用端口。如在计算机上，有即时聊天工具、浏览器和下载工具等需要网络的程序，使用端口可以明确地知道需要网络连接的是计算机上的哪一个服务，如下图所示。 ​ 端口并非真实的物理存在，TCP 和 UDP 都使用了应用层接口处的端口与上层的应用进程进行通信，可以认为是计算机与外界通信的出口。端口是一个 16 位的整数，用于标识不同的应用进程。同一台计算机上不能存在两个应用进程使用同一个端口，端口号的取值范围为 0~65535，通常可以分为以下 3 类。 公认端口：亦称熟知端口，取值范围为 0~1023，它们紧密绑定于一些服务。通常这些端口的通信明确表明了某种服务的协议。常见的公认端口如下表所示。 服务协议 FTP TELNET SMTP DNS TFTP HTTP POP3 SNMP 公认端口 21 23 25 53 69 80 110 162 注册端口：取值范围为 1024~49151，它们松散地绑定于一些服务。 动态和/或私有端口：取值范围为 49152~65535。这些端口号一般不固定分配给某个服务，只要运行的程序向系统提出访问网络的申请，那么系统就可以从这些端口号中分配一个供该程序使用。 ​ 可以把 IP 地址理解为教授 Java 课程的老师的办公室所在的地址，如哪个学院，但是仅有这个地址是不能找到老师的，还需要知道这位老师的办公室牌号，这个牌号就是端口号。 套接字——应用程序与端口的桥梁 ​ 网络上具有唯一标识的 IP 地址和端口号相结合在一起，才能构成唯一能识别的标识符套接字（Socket）。Socket 用于将应用程序与端口连接起来，一个 TCP 连接由通信双方的 Socket 确定。而且 Socket 为通信双方的输入和输出所有，实现全双工式的通信。 ​ Socket 负责将 TCP/IP 包发送到指定的 IP 地址，可以当成在两个程序进行通信连接中的一个端点。一个程序将数据写入 Socket 中，并将该数据发送到另一个 Socket 中，使得这个数据得以传送到其他程序，如下图所示。其中，这两个程序可以是在同一台计算机上，也可以是在 Internet 上的两台计算机。 URL——Internet 资源的门牌号 ​ URL 是 Uniform Resource Locator 的简写，中文含义是统一资源定位符，俗称“网址”。 URL 是用于完整地描述 Internet 上网页和其他资源的地址的一种标识方法。 ​ 统一资源定位符 URL 一般由以下几部分组成。 协议（protocol）：指定使用的传输协议。最常用的是 HTTP 协议，如 http://表示 WWW 服务器，还有 file://表示通过 FTP 访问资源。https://表示通过安全的 https 访问该资源。 主机名（hostname）：是指存放资源服务器的域名系统（DNS）主机名或 IP 地址。 端口号（port）：为整数，可选选项，省略时使用方案的默认端口。各种传输协议都有默认的端口号，如 http 的默认端口为 80，ftp 的默认端口为 21。有时候出于 安全或其他考虑，可以在服务器上对端口进行重定义，即采用非标准端口号，此时，URL 中就不能省略端口号这一项。 路径（path）：由 0 或多个“/”符号隔开的字符串，一般用来表示主机上的一个目录或文件地址，通用格式为“目录/子目录/文件名”。与端口号一样，路径有时是一 个可选选项，如 http://www.baidu.com:80/index.html 可简写为 http://www.baidu.com/。 知识扩展 ​ 以下内容仅作记录。 “三次握手”协议 ​ TCP 是通过“三次握手”实现端到端可靠连接控制的，其过程如下。 （1）第一次握手：A 的 TCP 向 B 发出连接请求报文段，其首部中的同步位 SYN=1， 并选择序号 seq=x，表明传送数据时的第一个数据字节的序号是 x。 （2）第二次握手：B 的 TCP 收到连接请求报文段后，如同意，则发回确认。B 在确认报文段中应使 SYN=1，使 ACK=1，其确认号 ack=x+1，自己选择的序号 seq=y。 （3）第三次握手：A 收到此报文段后向 B 给出确认，其 ACK=1，确认号 ack=y+1。A 的 TCP 通知上层应用进程，连接已经建立。其过程如图所示。 TCP的连接释放 ​ TCP 是通过“四次挥手”实现连接的释放，其过程如下。 （1）第一次挥手：数据传输结束后，通信的双方都可释放连接。现在 A 的应用 第 3 篇 Java 应用程序设计 ·558· 进程先向其 TCP 发出连接释放报文段，并停止再发送数据，主动关闭 TCP 连接。A 把连 接释放报文段首部的 FIN=1，其序号 seq=u，等待 B 的确认。 （2）第二次挥手：B 发出确认，确认号 ack=u+1，而这个报文段自己的序号 seq=v。TCP 服务器进程通知高层应用进程。从 A 到 B 这个方向的连接就释放了，TCP 连接处于半关闭状态。B 若发送数据，A 仍要接收。 （3）第三次挥手：若 B 已经没有要向 A 发送的数据，其应用进程就通知 TCP 释放连接。 （4）第四次挥手：A 收到连接释放报文段后，必须发出确认。在确认报文段中 ACK=1， 确认号 ack=w+1，自己的序号 seq=u+1。TCP 连接必须经过时间 2MSL 后才真正释放掉。 提示：A 必须等待 2MSL 时间的原因如下。 第一，为了保证 A 发送的最后一个 ACK 报文段能够到达 B。 第二，防止“已失效的连接请求报文段”出现在本连接中。A 在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以使本连接持续时间内所产生的所有报文段，都从网 络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。 TCP/IP协议的4层模型 （1）网络接口层，亦称链路层或数据链路层。该层是 TCP/IP 协议的最底层，负 责接收 IP 数据报并通过网络进行发送，或者从网络中接收物理帧，提取出 IP 数据报，交给网络层。网络接口层还通常包括操作系统中的设备驱动程序和计算机中对应的网络接 口卡。 （2）网络层，亦称互联网层，负责相邻计算机之间的通信，主要定义了 IP 地址的格式， 从而能够使不同应用类型的数据可以在 Internet 上传输。在 TCP/IP 协议族中，网络层协议包括： IP 协议（网际协议） ICMP 协议（Internet 互联网控制报文协议） IGMP 协议（Internet 组管理协议） （3）传输层，亦称运输层，主要为两台主机上的应用程序间的通信。在 TCP/IP 协议族中，有两个互不相同的传输协议，即 TCP（传输控制协议）和 UDP（用户数据报协议）。 （4）应用层，负责处理向用户提供的应用程序细节。几乎各种不同的 TCP/IP 实现都会提供下面这些通用的应用程序： Telnet 远程登录； FTP 文件传输协议； SMTP 简单邮件传送协议； SNMP 简单网络管理协议。 参考链接： IP地址共有A、B、C、D、E五类，怎样区分呢？_百度知道 (baidu.com) 参考书目： 《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com) 相关链接： 什么情况下IP地址会相同？ - 知乎 (zhihu.com) 私有ip_百度百科 (baidu.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"java反射机制","slug":"java/基本知识/java反射机制","date":"2021-08-24T01:56:21.000Z","updated":"2021-10-27T04:43:02.296Z","comments":true,"path":"2021/08/24/java/基本知识/java反射机制/","link":"","permalink":"https://silenthly.github.io/2021/08/24/java/%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/","excerpt":"​ 反射机制是 java语言的重要特征之一，虽然反射机制在程序设计中应用地不是很多， 但是在其他的程序设计语言中根本就不存在这一特性，如 Pascal、C/C++语言。java反射机制允许运行中的java程序对自身进行检测，亦称为自审，可以直接操作程序内部的属性。","text":"​ 反射机制是 java语言的重要特征之一，虽然反射机制在程序设计中应用地不是很多， 但是在其他的程序设计语言中根本就不存在这一特性，如 Pascal、C/C++语言。java反射机制允许运行中的java程序对自身进行检测，亦称为自审，可以直接操作程序内部的属性。 ​ 通过java的反射机制，开发人员可以深入地控制程序的运行过程，甚至可以逆向控制程序的执行过程，如通过一个对象找到其所在类的名称。如果想要使用 java的反射机制， 首先要了解 java的 Class 类。Class 类为编写可动态操纵 java代码的程序提供了强大的功能反射。 Class类与java反射 ​ 通过java的反射机制，可以访问程序中已经加载进内存的java对象的描述，可以访问、检测和修改描述java对象本身的信息。java中提供反射机制的包叫java.lang.reflect。 ​ Class 类为编写可动态操纵java代码的程序提供了强大的功能反射，该功能大量运用在 javaBeans 中。Class 类的常用方法如下表所示。 序号 方法 类型 说明 1 public &lt;U&gt; Class&lt;? extends U&gt; asSubclass(Class&lt;U&gt; clazz) 普通 强制转换该Class对象，将该类装换为指定类的一个子类 2 public T cast(Object obj) 普通 将一个对象强制转换成此Class对象所表示的类或接口 3 pulbic static Class&lt;?&gt; forName(String className)throws ClassNotFoundException 静态 将传入的完整的&quot;包类名&quot;名称实例化Class对象 4 pulbic static Class&lt;?&gt; forName(String name,boolean initalize,ClassLoader loader)throws ClassNotFoundException 静态 使用给定的类加载器，将传入的完整的&quot;包类名&quot;名称实例化Class对象 5 public ClassLodar getClassLodar() 普通 返回该类的类加载器 6 public Class&lt;?&gt; getComponentType() 普通 获取数组类型的Class对象 7 public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;…parameterTypes)throws NoSuchException, throws SecurityException 普通 获取此类中指定的public构造方法 8 public Constructor&lt;?&gt;[] getConstructors() throws SecurityException 普通 获取此类中所有的public构造方法，不保证返回顺序 9 public Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;…parameterTypes)throws NoSuchException, throws SecurityException 普通 获取指定的构造方法 10 public Constructor&lt;?&gt;[] getDeclaredConstructors() throws SecurityException 普通 获取所有的构造方法，不保证返回顺序 11 public Field getDeclaredField(String name)throws NoSuchException, throws SecurityException 普通 获取指定的成员变量 12 public Filed[] getDeclaredFields()throws SecurityException 普通 获取所有的成员变量，不保证返回顺序 13 public Method getDeclaredMethod(String name,Class&lt;?&gt;…parameterTypes)throws NoSuchException, throws SecurityException 普通 获取此类中指定的方法 14 public Method[] getDeclaredMethods() throws SecurityException 普通 获取所有的方法，不保证返回顺序。但不包括继承的方法 15 public Class&lt;?&gt; getDeclaeringClass() 普通 如果该类为类A内部类，则返回类A，否则返回null 16 public Class&lt;?&gt;[] getDeclaredClasses() 普通 返回当前类的所有内部类 17 public Field getField(String name)throws NoSuchException, throws SecurityException 普通 获取权限为public的指定成员变量 18 public Field[] getFields()throws SecurityException 普通 获取所有权限为public的成员变量，不保证返回顺序 19 public Class&lt;?&gt;[] getInterfaces()throws SecurityException 普通 获取此类实现的所有接口 20 public Method getMethod(String name,Class&lt;?&gt;…parameterTypes)throws NoSuchException, throws SecurityException 普通 获取此类中指定的public方法 21 public Method[] getMethods() throws SecurityException 普通 获取此类中所有的public方法，不保证返回顺序 22 public String getName() 普通 获取此类的类名称 23 public Package getPackege() 普通 获取此类的包名称 24 public Class&lt;? super T&gt; getSuperclass 普通 获取此类的父类 25 public boolean isArray() 普通 判断此Class对象是否表示一个数组类 26 public boolean isInstance(Object obj) 普通 判断指定的对象是否与此Class所表示的对象赋值兼容 27 public boolean isInterface() 普通 判断指定的Class对象是否表示一个接口类型 28 public boolean isPrimitive() 普通 判定指定的Class对象是否表示一个基本类型 29 public T newInstance()throws InstantiationException,IlleagalAccessException 普通 创建此Class对象所表示的类的一个新实例 30 public String toString() 普通 将对象转换为字符串 提示：通过 Class 类中的 getFields()和 GetMethods()方法分别获取类中 public 的成员变量和方法时，将包含从父类继承来的成员变量和方法。而通过 getDeclaredFields() 和 getDeclaredMethods()方法只是分别获取本类中的 public 的成员变量和方法，不包含从父类继承来的成员变量和方法。 使用 Object 类的 getClass()方法获取类信息 ​ 在 java 中所有的类都直接或间接地继承 Object 类。在 Object 类中有一个 getClass()方 法，其定义如下： 1public final Class&lt;?&gt; getClass() ​ 此方法可以返回一个类型为 Class 的对象。获取该类型后，可以利用 Class 类中的各个方法对对象进行操作。由于所有的类都是 Object 类的子类，所以所有类都可以直接使用 getClass()方法。getClass()方法的使用并不复杂，范例如下。 代码示例： 1234567891011121314151617package org.com.pack;class SuperClass&#123;&#125;class SubClass extends SuperClass&#123;&#125;public class Test&#123; public static void main(String[] args) &#123; SuperClass sup=new SuperClass(); SubClass sub=new SubClass(); Class c1=sup.getClass(); Class c2=sub.getClass(); System.out.println(&quot;类名：&quot;+c1.getName()); System.out.println(&quot;类名：&quot;+c2.getName()); &#125;&#125; 运行结果： 12类名：org.com.pack.SuperClass类名：org.com.pack.SubClass ​ 由以上程序可以发现，通过一个对象可以得到对象所在完整的“包.类名”。使用 Object 类的 getClass()方法速度会比较慢。 用Class类来加载对象 ​ Class 类的构造方法是私有的，所以不能通过 new 关键字实例化 Class 类的对象，但可以通过其提供的静态方法 forName()实例化 Class 对象。下面通过一个范例来演示如何使用 forName()方法加载对象。 代码示例： 1234567891011121314151617181920212223package org.com.pack;class LocaderClass&#123; static &#123; System.out.println(&quot;这是LocaderClass类的静态代码块&quot;); &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; Class c=null; try &#123; c=Class.forName(&quot;org.com.pack.LocaderClass&quot;); //以指定名称实例化Class对象 &#125;catch(ClassNotFoundException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;类名：&quot;+c.getName()); &#125;&#125; 运行结果： 12这是LocaderClass类的静态代码块类名：org.com.pack.LocaderClass ​ 以上程序中，使用 forName()方法和使用 new 关键字创建看起来并没有什么不同之处。 **实际上，使用 new 关键字实例化对象是要经过编译器静态检查的。如果在编译器中 LocaderClass 类并不存在，那么将会无法编译通过。**而使用 forName()方法是动态加载，即使 LocaderClass 类并不存在，编译也是可以通过的，只是在运行时会产生异常。还有一点需要注意的是，forName()方法返回的是 Class 实例，不是所加载类的实例。 ​ 使用 forName()静态方法实例化 Class 对象是比较常用的方法，forName()方法多用于加载驱动程序。 使用类标记 ​ 除了前面使用的Object类的getClass()方法和Class类中的静态方法forName()方法以外， 还有一种更加简便的生成 Class 对象的方法——类标记。使用“类名.class”的形式即可。 代码实例：(使用类标记生成 Class 对象) 12345678910111213141516package org.com.pack;class LocaderClass&#123; static &#123; System.out.println(&quot;这是LocaderClass类的静态代码块&quot;); &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; Class c=LocaderClass.class; System.out.println(&quot;类名：&quot;+c.getName()); &#125;&#125; 运行结果： 1类名：org.com.pack.LocaderClass ​ 以上程序也可以实例化 Class 对象，而且显得更加简洁，运行的效率也比较高。 使用反射机制生成并操作对象 ​ 前面学习了 Class 对象的实例化，那该如何使用 Class 类呢？实际上，Class 类最重要的功能是提供了一组反射调用，以取得该类的构造方法、成员变量和成员方法。 通过无参构造实例化对象 ​ 可以通过使用 Class 类对象的 newInstance()方法来创建该 Class 对象对应类的实例，但是必须保证被实例化的类中存在一个无参构造方法，newInstance()方法是通过利用默认的构造方法来创建该类实例的。 代码示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package org.com.pack;class Student&#123; private String name; private int age; public Student()&#123;&#125; //空白构造方法 public void setName(String name) &#123; this.name=name; &#125; public void setAge(int age) &#123; this.age=age; &#125; public String getName() &#123; return name; &#125; public int getAge() &#123; return age; &#125; public String toString() &#123; return &quot;姓名：&quot;+getName()+&quot;，年龄：&quot;+getAge(); &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; Class&lt;?&gt; c=null; Student stu=null; try &#123; c=Class.forName(&quot;org.com.pack.Student&quot;); &#125;catch(ClassNotFoundException e) &#123; e.printStackTrace(); &#125; try &#123; stu=(Student)c.newInstance(); //向下转型 &#125;catch(InstantiationException e) &#123; e.printStackTrace(); &#125;catch(IllegalAccessException e) &#123; e.printStackTrace(); &#125; stu.setName(&quot;小强&quot;); stu.setAge(18); System.out.println(&quot;对象信息：&quot;+stu); &#125;&#125; 运行结果： 1对象信息：姓名：小强，年龄：18 ​ 以上程序中有两点需要注意：第一，传入 forName() 方法的参数必须是完整的“包.类名称”的形式，就算这两个类都处在同一个目录下也不能省略包名；第二， c.newInstance()需要向下转型为 Student 类。 ​ 若在类中定义了其他的构造方法并且没有显式写出无参构造方法，那么该类的默认无参构造方法就会被隐藏。若再使用 newInstance()方法实例化对象时，将会出错。 代码示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package org.com.pack;class Student&#123; private String name; private int age; public Student(String name,int age) //构造方法 &#123; this.name=name; this.age=age; &#125; public void setName(String name) &#123; this.name=name; &#125; public void setAge(int age) &#123; this.age=age; &#125; public String getName() &#123; return name; &#125; public int getAge() &#123; return age; &#125; public String toString() &#123; return &quot;姓名：&quot;+getName()+&quot;，年龄：&quot;+getAge(); &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; Class&lt;?&gt; c=null; Student stu=null; try &#123; c=Class.forName(&quot;org.com.pack.Student&quot;); &#125;catch(ClassNotFoundException e) &#123; e.printStackTrace(); &#125; try &#123; stu=(Student)c.newInstance(); //向下转型 &#125;catch(InstantiationException e) &#123; e.printStackTrace(); &#125;catch(IllegalAccessException e) &#123; e.printStackTrace(); &#125; stu.setName(&quot;小强&quot;); stu.setAge(18); System.out.println(&quot;对象信息：&quot;+stu); &#125;&#125; 运行结果： 12345678java.lang.InstantiationException: org.com.pack.Student at java.lang.Class.newInstance(Unknown Source) at org.com.pack.Test.main(Test.java:47)Caused by: java.lang.NoSuchMethodException: org.com.pack.Student.&lt;init&gt;() at java.lang.Class.getConstructor0(Unknown Source) ... 2 moreException in thread &quot;main&quot; java.lang.NullPointerException at org.com.pack.Test.main(Test.java:55) ​ 以上程序中不存在无参构造方法，因此不能直接使用 newInstance()方法实例化对象。 为了开发的便捷性，一般在类中定义无参构造方法。 调用有参构造实例化对象 ​ 除了前面Class类的newInstance()方法创建对象以外，java语言还提供了使用 java.lang.reflect. Constructor 类根据类的指定构造方法创建对象。使用 Constructor 类操作时， 只需明确地调用类中的构造方法，并将参数传递进去，即可进行实例化操作，其步骤如下。 （1）获取类的 Class 对象，再通过 Class 类中的 getConstructor()方法取得 Constructor 类的实例。 （2）通过 Constructor 类的实例，调用 newInstance()方法并传入指定构造方法所需要的各个参数完成对象的创建。 ​ Constructor 类的常用方法如下表所示。 序号 方法 类型 说明 1 Class&lt;?&gt;[] getExceptionTypes() 普通 获取构造方法可能抛出的异常 2 int getModifiers() 普通 获取构造方法修饰符 3 String getName() 普通 获取构造方法的名称 4 Class&lt;?&gt;[] getParameterTypes() 普通 获取构造方法各个形参类型 5 boolean is VarArgs() 普通 判断构造方法是否可以带可变数量的参数。若是，则返回 true。否 则返回 false 6 T newInstance(Object… initargs) throws Instantiation Exception,IllegalAccessException, IllegalArgument Exception,InvocationTargetException 普通 向指定的构造方法传递参数，并实例化对象 7 public void setAccessible(boolean flag)throws SecurityException 普通 如果构造方法的权限为private，默认为不允许通过反射利用newInstance(Object… initargs)方法创建对象。如果该方法先执行，并将入口参数设为true，则允许创建，即设置一个属性是否可以被外部访问 8 String toString() 普通 返回构造方法的信息 代码示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package org.com.pack;import java.lang.reflect.Constructor;class Student&#123; private String name; private int age; public Student() &#123; this.name=&quot;小红&quot;; this.age=19; &#125; public Student(String name,int age) //构造方法 &#123; this.name=name; this.age=age; &#125; public Student(String name) &#123; this.name=name; &#125; public Student(int age) &#123; this.age=age; &#125; public void setName(String name) &#123; this.name=name; &#125; public void setAge(int age) &#123; this.age=age; &#125; public String getName() &#123; return name; &#125; public int getAge() &#123; return age; &#125; public String toString() &#123; return &quot;姓名：&quot;+getName()+&quot;，年龄：&quot;+getAge(); &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; Class&lt;?&gt; c=null; Constructor&lt;?&gt; con[]=null; Student stu1=null; Student stu2=null; Student stu3=null; Student stu4=null; try &#123; c=Class.forName(&quot;org.com.pack.Student&quot;); &#125;catch(ClassNotFoundException e) &#123; e.printStackTrace(); &#125; con=c.getConstructors(); for(int i=0;i&lt;con.length;i++) //输出Student对象所有的构造方法 &#123; System.out.println(i+&quot;---&quot;+con[i]); &#125; try &#123; stu1=(Student)con[0].newInstance(20); stu2=(Student)con[1].newInstance(&quot;小强&quot;); stu3=(Student)con[2].newInstance(&quot;小明&quot;,18); stu4=(Student)con[3].newInstance(); &#125;catch(Exception e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;对象信息：&quot;+stu1); System.out.println(&quot;对象信息：&quot;+stu2); System.out.println(&quot;对象信息：&quot;+stu3); System.out.println(&quot;对象信息：&quot;+stu4); &#125;&#125; 运行结果： 123456780---public org.com.pack.Student(int)1---public org.com.pack.Student(java.lang.String)2---public org.com.pack.Student(java.lang.String,int)3---public org.com.pack.Student()对象信息：姓名：null，年龄：20对象信息：姓名：小强，年龄：0对象信息：姓名：小明，年龄：18对象信息：姓名：小红，年龄：19 ​ 以上的程序，不能保证返回数组的顺序，注意是不能保证返回顺序，而不是返回是乱序：它完全可能是乱序，也还可能是按照声明顺序排布。详情可查看API帮助文档。该程序相对于无参而言复杂很多，所以建议在自定义类时，一定要保留一个无参构造方法。 java反射机制的应用 ​ java 的反射机制主要运用 java.lang.reflect 包，在这个包中常用的类如下。 Constructor 类：用于表示类中的构造方法。 Field 类：用于表示类中的成员属性。 Method 类：用于表示类中的成员方法。 ​ 其中，java.lang 包中的 Class 类是 java 反射机制的入口，只有获得了一个类的描述对象后才能动态地加载和调用。 获取实现的全部接口 ​ Class 类中提供了 getInterface()方法，可以获取一个类所实现的全部接口，该方法返回的是一个 Class 类的对象数组。因为 java 中的类可以实现多个接口，所以取得 Class 对象实例后通过 getName()输出接口的名称即可。 代码示例： 1234567891011121314151617181920212223package org.com.pack;interface FirstInterface&#123;&#125;interface SecondInterface&#123;&#125;interface ThirdInterface&#123;&#125;class Demo implements FirstInterface,SecondInterface,ThirdInterface&#123;&#125;public class Test&#123; public static void main(String[] args) &#123; Class&lt;?&gt; inter[]=null; try &#123; inter=Class.forName(&quot;org.com.pack.Demo&quot;).getInterfaces(); &#125;catch(ClassNotFoundException e) &#123; e.printStackTrace(); &#125; for(Class&lt;?&gt; c:inter) &#123; System.out.println(c.getName()); &#125; &#125;&#125; 运行结果： 123org.com.pack.FirstInterfaceorg.com.pack.SecondInterfaceorg.com.pack.ThirdInterface 获取父类 ​ 可以通过 Class 类的 getSuperclass()方法获取一个类的父类，再通过 getName()方法返回父类的名称。 代码示例： 123456789101112131415161718192021package org.com.pack;class SuperClass&#123;&#125;class SubClass extends SuperClass&#123;&#125;public class Test&#123; public static void main(String[] args) &#123; Class&lt;?&gt; c1=null; Class&lt;?&gt; c2=null; try &#123; c1=Class.forName(&quot;org.com.pack.SubClass&quot;); c2=Class.forName(&quot;org.com.pack.SuperClass&quot;); &#125;catch(ClassNotFoundException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;SubClass的父类：&quot;+c1.getSuperclass().getName()); System.out.println(&quot;SuperClass的父类：&quot;+c2.getSuperclass().getName()); &#125;&#125; 运行结果： 12SubClass的父类：org.com.pack.SuperClassSuperClass的父类：java.lang.Object ​ 以上程序运行时，可以获取 SubClass 和 SuperClass 类的父类，而 SubClass 是显式继承了 SuperClass 类，所以打印输出的是 SuperClass 类。而 SuperClass 类没有明确地继承一个类，所以默认继承的是 Object 类。 访问成员变量：Field类 ​ Class 类中提供了一系列的方法可以访问类中的全部属性，并返回 Field 对象或数组。 每一个 Field 对象代表一个成员属性，利用 Field 对象还可以操作相应的成员属性。Field 类的常用方法如下表所示。 序号 方法 类型 说明 1 public Object get(Object obj)throws IllegalArgumentException,IllegalAccessException 普通 获取指定对象obj中该变量的值 2 public boolean getBoolean(Object obj)throws IllegalArgumentException,IllegalAccessException 普通 获取指定对象obj中类型为boolean的该成员属性的值，可重写为byte、char、double、float、int、short和long类型 3 public int getModifiers() 普通 获取该成员属性的修饰符，并以整数的形式返回 4 public String getName() 普通 获取该成员属性的名称 5 public Class&lt;?&gt; getType() 普通 获取表示该成员属性的Class对象(类型) 6 public void set(Object obj,Object value)throws IllegalArgumentException,IllegalAccessException 普通 设置指定对象中属性的内容 7 public static void setAccessible(boolean flag)throws SecurityException 静态 设置一个属性是否可以被外部访问 8 public static void setAccessible(AccessibleObject[] array,booleean flag)throws SecurityException 静态 设置一组属性是否可以被外部访问 9 public void setBoolean(Object obj,boolean z)throws IllegalArgumentException,IllegalAccessException 普通 将指定对象obj中类型为boolean的该成员属性的值设置为z，可重写为byte、char、double、float、int、short和long类型 10 public String toString() 普通 返回一个描述此Field的信息 ​ 下面通过范例介绍Field类的方法 获得类中的全部属性 1234567891011121314151617181920212223242526272829303132333435363738package org.com.pack;import java.lang.reflect.Field;class LocaderClass&#123; private int num=10; protected boolean b=true; public long l=123L; String str=&quot;java&quot;;&#125;public class Test&#123; public static void main(String[] args) &#123; Class&lt;?&gt; c=null; try &#123; c=Class.forName(&quot;org.com.pack.LocaderClass&quot;); &#125;catch(ClassNotFoundException e) &#123; e.printStackTrace(); &#125; Field field[]=c.getDeclaredFields(); for(int i=0;i&lt;field.length;i++) &#123; field[i].setAccessible(true); System.out.println(&quot;成员属性名称：&quot;+field[i].getName()); System.out.println(&quot;成员属性类型：&quot;+field[i].getType()); try &#123; System.out.println(&quot;成员属性内容：&quot;+field[i].get(c.newInstance())); &#125;catch(Exception e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;-------------------------------&quot;); &#125; &#125;&#125; 运行结果： 12345678910111213141516成员属性名称：num成员属性类型：int成员属性内容：10-------------------------------成员属性名称：b成员属性类型：boolean成员属性内容：true-------------------------------成员属性名称：l成员属性类型：long成员属性内容：123-------------------------------成员属性名称：str成员属性类型：class java.lang.String成员属性内容：java------------------------------- ​ 以上程序，若想访问 private 权限的成员属性，则需要执行 setAccessible()方法并设置其参数为 true，否则不允许访问。还可以使用 Field 类设置类中的属性值。 不能保证返回数组的顺序，注意是不能保证返回顺序，而不是返回是乱序：它完全可能是乱序，也还可能是按照声明顺序排布。详情可查看API帮助文档。 设置属性值 代码示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package org.com.pack;import java.lang.reflect.Field;class LocaderClass&#123; private int num=10; protected boolean b=true; public long l=123L; String str=&quot;java&quot;; public String toString() &#123; return &quot;num=&quot;+num+&quot;，b=&quot;+b+&quot;，l=&quot;+l+&quot;，str=&quot;+str; &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; Class&lt;?&gt; c=null; LocaderClass lc=new LocaderClass(); System.out.println(&quot;-------原先的lc对象信息-------&quot;); System.out.println(lc); System.out.println(); try &#123; c=Class.forName(&quot;org.com.pack.LocaderClass&quot;); &#125;catch(ClassNotFoundException e) &#123; e.printStackTrace(); &#125; try &#123; lc=(LocaderClass)c.newInstance(); //创建LocaderClass实例 &#125;catch(Exception e) &#123; e.printStackTrace(); &#125; Field field[]=c.getDeclaredFields(); for(int i=0;i&lt;field.length;i++) &#123; field[i].setAccessible(true); Class&lt;?&gt; fieldType=field[i].getType(); System.out.println(&quot;成员属性名称：&quot;+field[i].getName()); System.out.println(&quot;成员属性类型：&quot;+field[i].getType()); try &#123; System.out.println(&quot;修改前成员属性内容：&quot;+field[i].get(lc)); if(fieldType.equals(int.class)) &#123; System.out.print(&quot;修改后成员属性内容：&quot;); field[i].set(lc,500); System.out.println(field[i].get(lc)); &#125;else if(fieldType.equals(boolean.class)) &#123; System.out.print(&quot;修改后成员属性内容：&quot;); field[i].set(lc,false); System.out.println(field[i].get(lc)); &#125;else if(fieldType.equals(long.class)) &#123; System.out.print(&quot;修改后成员属性内容：&quot;); field[i].set(lc,325654L); System.out.println(field[i].get(lc)); &#125;else if(fieldType.equals(String.class)) &#123; System.out.print(&quot;修改后成员属性内容：&quot;); field[i].set(lc,&quot;java学习笔记&quot;); System.out.println(field[i].get(lc)); &#125; &#125;catch(Exception e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;--------------------------------&quot;); &#125; System.out.println(&quot;-------修改后的lc对象信息-------&quot;); System.out.println(lc); &#125;&#125; 运行结果： 12345678910111213141516171819202122232425-------原先的lc对象信息-------num=10，b=true，l=123，str=java成员属性名称：num成员属性类型：int修改前成员属性内容：10修改后成员属性内容：500--------------------------------成员属性名称：b成员属性类型：boolean修改前成员属性内容：true修改后成员属性内容：false--------------------------------成员属性名称：l成员属性类型：long修改前成员属性内容：123修改后成员属性内容：325654--------------------------------成员属性名称：str成员属性类型：class java.lang.String修改前成员属性内容：java修改后成员属性内容：java学习笔记---------------------------------------修改后的lc对象信息-------num=500，b=false，l=325654，str=java学习笔记 不能保证返回数组的顺序，注意是不能保证返回顺序，而不是返回是乱序：它完全可能是乱序，也还可能是按照声明顺序排布。详情可查看API帮助文档。 访问成员方法：Method类 ​ 当获取了某个类的对象的Class对象后，不但可以通过getDeclaredMethods()或getDeclaredMethod()方法获取全部的方法或指定方法，还可以通过这两个方法的返回值 Method 对象数组或 Method 对象操作相应的方法。 ​ 每一个 Method 对象都对应着一个方法，获取该 Method 对象后，程序就可以通过该对象来访问对应的方法。Method 类的常用方法如下表所示。 序号 方法 类型 说明 1 public Class&lt;?&gt;[] getExceptionTypes() 普通 获取方法抛出的全部异常类型 2 public int getModifiers() 普通 获取方法的修饰符，并以整数的形式表示 3 public String getName() 普通 获取方法名称 4 public Class&lt;?&gt;[] getParameterTypes() 普通 获取方法的全部参数类型 5 public Class&lt;?&gt; getRetrunType() 普通 获取方法的返回值类型 6 public Object invoke(Object obj,Object…args)throws IllegalAccessException,IllegalArgumentException,InvocationTarg etException 普通 使用指定参数args执行指定对象obj中的方法 7 public boolean isVarArgs() 普通 判断该方法是否带有可变参数，如果是，则返回true，否则返回false 8 public String toString() 普通 返回描述此 Method 对象的信息 ​ 下面通过范例介绍Method类的方法 获取类中的全部方法信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package org.com.pack;import java.lang.reflect.Method;import java.lang.reflect.Modifier;class LocaderClass&#123; public static void staticMethod() &#123; System.out.println(&quot;静态方法&quot;); &#125; public int publicMethod(int i)throws ClassCastException,NumberFormatException &#123; return i*2; &#125; protected float protectedMethod(float f,int i) &#123; return f+i; &#125; private String privateMethod(String...str) &#123; return str[0]; &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; Class&lt;?&gt; c=null; try &#123; c=Class.forName(&quot;org.com.pack.LocaderClass&quot;); &#125;catch(ClassNotFoundException e) &#123; e.printStackTrace(); &#125; Method method[]=c.getDeclaredMethods(); for(int i=0;i&lt;method.length;i++) &#123; System.out.println(&quot;方法名称：&quot;+method[i].getName()); int mod=method[i].getModifiers(); System.out.println(&quot;方法修饰符：&quot;+Modifier.toString(mod)); Class&lt;?&gt; cReturn=method[i].getReturnType(); System.out.println(&quot;方法返回值类型：&quot;+cReturn.getName()); System.out.println(&quot;方法参数是否为可变参数：&quot;+method[i].isVarArgs()); System.out.print(&quot;方法的参数类型：&quot;); Class&lt;?&gt; cParameters[]=method[i].getParameterTypes(); for(int j=0;j&lt;cParameters.length;j++) &#123; System.out.print(cParameters[j].getName()+&quot; &quot;); &#125; Class&lt;?&gt; cExceptions[]=method[i].getExceptionTypes(); System.out.print(&quot;\\n方法抛出的异常类型：&quot;); for(int j=0;j&lt;cExceptions.length;j++) &#123; System.out.print(cExceptions[j].getName()+&quot; &quot;); &#125; System.out.println(&quot;\\n---------------------------------------&quot;); &#125; &#125;&#125; 运行结果： 12345678910111213141516171819202122232425262728方法名称：staticMethod方法修饰符：public static反复返回值类型：void方法参数是否为可变参数：false方法的参数类型：方法抛出的异常类型：---------------------------------------方法名称：publicMethod方法修饰符：public反复返回值类型：int方法参数是否为可变参数：false方法的参数类型：int方法抛出的异常类型：java.lang.ClassCastException java.lang.NumberFormatException---------------------------------------方法名称：protectedMethod方法修饰符：protected反复返回值类型：float方法参数是否为可变参数：false方法的参数类型：float int方法抛出的异常类型：---------------------------------------方法名称：privateMethod方法修饰符：private transient反复返回值类型：java.lang.String方法参数是否为可变参数：true方法的参数类型：[Ljava.lang.String;方法抛出的异常类型：--------------------------------------- 不能保证返回数组的顺序，注意是不能保证返回顺序，而不是返回是乱序：它完全可能是乱序，也还可能是按照声明顺序排布。详情可查看API帮助文档。 调用类中的方法 ​ 还可以通过 Method 类实现调用类中的方法。在 java 中，通过反射机制获取类的 Class 对象，调用 getDeclaredMethods()方法获取类中全部的方法，并返回 Method 对象数组，再调用 Method 类中的 invoke()方法来执行类中指定的方法。 代码示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package org.com.pack;import java.lang.reflect.Method;import java.lang.reflect.Modifier;class LocaderClass&#123; public static void staticMethod() &#123; System.out.println(&quot;静态方法&quot;); &#125; public int publicMethod(int i)throws ClassCastException,NumberFormatException &#123; return i*2; &#125; protected float protectedMethod(float f,int i) &#123; return f+i; &#125; private String privateMethod(String...str) &#123; return str[0]; &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; Class&lt;?&gt; c=null; LocaderClass lc=null; try &#123; c=Class.forName(&quot;org.com.pack.LocaderClass&quot;); &#125;catch(ClassNotFoundException e) &#123; e.printStackTrace(); &#125; try &#123; lc=(LocaderClass)c.newInstance(); //创建LocaderClass实例 &#125;catch(Exception e) &#123; e.printStackTrace(); &#125; Method method[]=c.getDeclaredMethods(); for(int i=0;i&lt;method.length;i++) &#123; method[i].setAccessible(true); System.out.println(&quot;方法名称：&quot;+method[i].getName()); try &#123; if(i==0) &#123; method[0].invoke(lc); &#125;else if(i==1) &#123; System.out.println(&quot;执行结果：&quot;+method[1].invoke(lc,12)); &#125;else if(i==2) &#123; System.out.println(&quot;执行结果：&quot;+method[2].invoke(lc,3.4f,12)); &#125;else if(i==3) &#123; Object obj[]=new Object[]&#123;new String[]&#123;&quot;java&quot;,&quot;学&quot;,&quot;习&quot;,&quot;笔记&quot;&#125;&#125;; System.out.println(&quot;执行结果：&quot;+method[3].invoke(lc,obj)); &#125; &#125;catch(Exception e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;----------------------------------&quot;); &#125; &#125;&#125; 运行结果： 123456789101112方法名称：staticMethod静态方法----------------------------------方法名称：publicMethod执行结果：24----------------------------------方法名称：protectedMethod执行结果：15.4----------------------------------方法名称：privateMethod执行结果：java---------------------------------- ​ 在以上程序中，需要执行 setAccessible()方法并设置其参数为 true，否则在执行 private 属性的 privateMethod()方法 时将会产生异常。还有一点需要注意的是，在通过反射机制执行参数为可变参数的方法时，需要将传入的参数设置为二维数组的形式。 不能保证返回数组的顺序，注意是不能保证返回顺序，而不是返回是乱序：它完全可能是乱序，也还可能是按照声明顺序排布。详情可查看API帮助文档。 通过反射操作数组：Array类 ​ java 反射机制不止可以应用在类上，还可以用于任意的引用数据类型上。在 java.lang.reflect 包中提供了一个 Array 类来动态地创建和访问数组。Array 类常用的方法如下表所示。 序号 方法 类型 说明 1 public static Object get(Object array,int index)throws IllegalArgumentException, ArrayIndexOutOfBoundsException 静态 根据下标取得数组的内容 2 public static boolean getBoolean(Object arrat,int index)throws IllegalArgumentException, ArrayIndexOutOfBoundsException 静态 以 boolean 形式返回数组对象中指定下标的内容，可重写为byte、char、double、float、int、short和long类型 3 public static int getLength(Object array)throws IllegalArgumentException, ArrayIndexOutOfBoundsException 静态 获取指定数组的长度 4 public static Object newInstance(Class&lt;?&gt; componentType,int… dimensions)throws IllegalArgumentException, ArrayIndexOutOfBoundsException 静态 创建一个具有指定的类型和维度的新数组 5 public static Object newInstacne(Class&lt;?&gt; componentType,int length)throws IllegalArgumentException, ArrayIndexOutOfBoundsException 静态 创建一个具有指定的类型和长度的新数组 6 public static void set(Object array,int index,Object value)throws IllegalArgumentException, ArrayIndexOutOfBoundsException 静态 设置数组中指定下标的内容的值 7 public static void setBoolean(Object array,int index,boolean z)throws IllegalArgumentException, ArrayIndexOutOfBoundsException 静态 将数组中指定位置的值设置为指定的 boolean 值，可重写为byte、char、double、float、int、short和long类型 ​ 下面通过范例来演示 Arrary 类的用法。 获取数组的信息并修改数组内容 1234567891011121314151617181920212223import java.lang.reflect.Array;public class Test&#123; public static void main(String[] args) &#123; int num[]=&#123;1,2,3,4,5&#125;; Class&lt;?&gt; cArray=num.getClass().getComponentType(); System.out.println(&quot;数组元素类型：&quot;+cArray.getName()); System.out.println(&quot;数组长度：&quot;+Array.getLength(num)); System.out.println(&quot;修改前的数组：&quot;); int length=Array.getLength(num); for(int i=0;i&lt;length;i++) &#123; System.out.print(Array.get(num,i)+&quot; &quot;); &#125; System.out.println(&quot;\\n修改后的数组：&quot;); for(int i=0;i&lt;length;i++) &#123; Array.set(num,i,i*2+1); System.out.print(Array.get(num,i)+&quot; &quot;); &#125; &#125;&#125; 运行结果： 123456数组元素类型：int数组长度：5修改前的数组：1 2 3 4 5修改后的数组：1 3 5 7 9 创建新数组 ​ Array 类除了可以获取数组的相关信息及设置数组元素内容以外，还可以创建新的数组。 代码示例： 123456789101112131415161718192021222324import java.lang.reflect.Array;public class Test&#123; public static void main(String[] args) &#123; String str[]=null; try &#123; str=(String[])Array.newInstance(String.class,5); //向下转型 &#125;catch(Exception e) &#123; e.printStackTrace(); &#125; for(int i=0;i&lt;str.length;i++) &#123; Array.set(str,i,i*2+&quot;&quot;); &#125; System.out.println(&quot;数组内容：&quot;); for(int i=0;i&lt;str.length;i++) &#123; System.out.print(Array.get(str,i)+&quot; &quot;); &#125; &#125;&#125; 运行结果： 12数组内容：0 2 4 6 8 ​ 在以上程序中，Array 类的 newInstance()方法返回值为 Object 类中的数组，所以需要进行向下转型为 String 类型的数组。 参考书目： 《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"枚举","slug":"java/集合与泛型/枚举","date":"2021-08-20T13:26:01.000Z","updated":"2021-10-27T04:45:15.312Z","comments":true,"path":"2021/08/20/java/集合与泛型/枚举/","link":"","permalink":"https://silenthly.github.io/2021/08/20/java/%E9%9B%86%E5%90%88%E4%B8%8E%E6%B3%9B%E5%9E%8B/%E6%9E%9A%E4%B8%BE/","excerpt":"​ 枚举原本是 C 语言或 C++语言中的一种构造类型。当一个变量有几种可能的取值时， 将变量的值一一列出来，变量的值只限于列举出来的值的范围内，这称为枚举。","text":"​ 枚举原本是 C 语言或 C++语言中的一种构造类型。当一个变量有几种可能的取值时， 将变量的值一一列出来，变量的值只限于列举出来的值的范围内，这称为枚举。 为什么要使用枚举 ​ JDK 1.5 开始引入了枚举类型，可以使用枚举取代以往通过定义常量的方式来限制一个类的对象产生范围。java增加枚举之后，不但扩充了java的类集，还赋予了程序在编译时检查的功能。 ​ 在某些情况下，一个类的对象是有限且固定的，如方向类，它只有东南西北这4个对象，其他的任何值都是非法的。在以往没有泛型的程序设计中，会采取以下的方式构建这样的代码。 代码示例：(使用普通类) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Directions&#123; private String name; private Directions(String name) &#123; setName(name); &#125; private void setName(String name) &#123; this.name=name; &#125; public String getName() &#123; return name; &#125; public static final Directions EAST=new Directions(&quot;东&quot;); //创建“东”实例 public static final Directions SOUTH=new Directions(&quot;南&quot;); public static final Directions WEST=new Directions(&quot;西&quot;); public static final Directions NORTH=new Directions(&quot;北&quot;); public static Directions getDirections(int direcNumber) &#123; switch(direcNumber) &#123; case 0: return EAST; //返回“东”实例 case 1: return SOUTH; case 2: return WEST; case 3: return NORTH; default: return null; &#125; &#125; public String toString() //重写toString()方法 &#123; return getName(); &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; Directions dirEast=Directions.getDirections(0); //获取东 System.out.println(&quot;获取Directions对象：&quot;+dirEast); Directions dirWest=Directions.getDirections(2); //获取西 System.out.println(&quot;获取Directions对象：&quot;+dirWest); &#125;&#125; 运行结果： 12获取Directions对象：东获取Directions对象：西 ​ 在以上程序中，Directions 类有以下几个特点： 构造方法是 private 的，这是单例设计模式。 该类的对象是有限，有4个对象类型，且用 public static final 属性来保存。 其他类通过调用该类的静态方法 getDirections()方法取得相对应的实例。 ​ 由于 Directions 类的构造方法是 private 的，所有只能通过 getDirections()方法取得 Directions 的实例，且只能从 EAST、SOUTH、WEST、NORTH 中选择，这样可以有效地限制对象的取值范围。除此之外，还可以通过接口的方式限制方向的取值范围，但此时 Directions 对象需要使用常量表示。 代码示例：(使用接口) 12345678910111213141516interface Directions&#123; public static final int EAST=0; public static final int SOUTH=1; public static final int WEST=2; public static final int NORTH=3;&#125;public class Test&#123; public static void main(String[] args) &#123; System.out.println(&quot;获取东属性：&quot;+Directions.EAST); System.out.println(&quot;获取西属性：&quot;+Directions.WEST); System.out.println(&quot;错误属性：&quot;+(Directions.WEST+Directions.NORTH)); &#125;&#125; 运行结果： 123获取东属性：0获取西属性：2错误属性：5 ​ 从以上程序可以发现，使用接口的方式相对较为简单， 但容易产生歧义，如 Directions.WEST+Directions.NORTH。 还有意义不明确的，如打印输出的是0，用户不查看文档就 很难知道0代表的是东。 ​ 以上这两种形式都无法让用户了解程序可以提供的向种类，如有没有前后左右上下等。若想实现这样的功能，将是一个复杂的过程。从这个意义上来说，枚举的存在是非常有用的。 定义枚举类型 ​ 从 JDK 1.5 开始 java 新增了一个关键字 enum，用来定义枚举类型。枚举类型是一个常量集合的数据类型，所以枚举类型中的枚举成员的标识符都是大写的。 常见的枚举定义方法 ​ 从 JDK 1.5 开始可以使用 enum 关键字直接定义枚举类型，其语法格式如下。 1234[public] enum 枚举类型名&#123; 枚举成员1,枚举成员2...枚举成员n;&#125; ​ 其中，定义枚举类型时，各成员之类使用英文的逗号（,）分隔开。一个源文件只能定义一个 public 类型的枚举类型，枚举类型经过 java 编译器编译后，也将产生一个字节码文件（.class）。枚举类型本质上也是类，不过是一个特殊的类。 注意：所有的枚举类型都隐性地继承 java.lang.Enum。 代码示例： 123456789101112enum Directions&#123; EAST,SOUTH,WEST,NORTH; //定义枚举成员&#125;public class Test&#123; public static void main(String[] args) &#123; Directions dir=Directions.EAST; System.out.println(&quot;获取的枚举成员：&quot;+dir); &#125;&#125; 运行结果： 1获取的枚举成员：EAST 在 switch 语句中使用枚举 ​ switch 语句是支持枚举类型的，下面演示使用 switch 语句判断枚举类型。 代码示例： 123456789101112131415161718192021222324252627282930enum Directions&#123; EAST,SOUTH,WEST,NORTH; //定义枚举成员&#125;public class Test&#123; public static void show(Directions dir) &#123; switch(dir) &#123; case EAST: System.out.println(&quot;您传递进来的枚举成员为：东&quot;); break; case SOUTH: System.out.println(&quot;您传递进来的枚举成员为：南&quot;); break; case WEST: System.out.println(&quot;您传递进来的枚举成员为：西&quot;); break; case NORTH: System.out.println(&quot;您传递进来的枚举成员为：北&quot;); break; &#125; &#125; public static void main(String[] args) &#123; Directions dir=Directions.WEST; show(dir); &#125;&#125; 运行结果： 1您传递进来的枚举成员为：西 ​ 以上程序中，在 switch 语句中不能在每个 case 语句的枚举类型值前面加上枚举类型的类名，如 （Directions.WEST），可见枚举有参数类型检测优势。 若调用 show()方法时传入的参数不是 Directions 类型， 程序编译时将会报错。例如，在 main()方法中调用 show(0)，将会抛出如下异常。 12345Test.java:28: 错误: 不兼容的类型: int无法转换为Directions show(0); ^注: 某些消息已经过简化; 请使用 -Xdiags:verbose 重新编译以获得完整输出1 个错误 枚举类型与枚举类的区别 ​ 使用 enum 关键字可以定义一个枚举类型，实际上相当于定义了一个类，该类继承了 java.lang.Enum 类。可以使用 values()遍历所有的枚举成员。 ​ 枚举类 Enum 是 java.lang 包中的一个类，该类的构造方法是 protected 的。实际上定义 一个枚举类型之后，就会自动调用 Enum 类的构造方法。Enum 类中还有许多的方法可以被调用。 枚举类：Enum ​ 前面提示过，所有的枚举类型都隐性地继承 java.lang.Enum 类，就是说所有的枚举类型都可以看成一个类。当定义一个枚举类型时，每一个枚举类型成员都是枚举类型的一个 实例。这些实例的默认属性为 public static final，可以直接通过“类名.变量”的形式访问。 java.lang.Enum类的定义如下： 1public abstract class Enum&lt;E extends Enum&lt;E&gt;&gt; extends Object implements Comparable&lt;E&gt;,Serializable ​ 可以发现，Enum 类是抽象类且实现了 Comparable 和 Serializable 接口，索引枚举类型可以使用比较器和进行序列化操作。由于枚举类型继承了 Enum 类，所有 Enum 类中的以下关于操作枚举类型的方法，都可以运用到枚举类型中。Enum 类的常用方法如下表所示。 序号 方法 类型 说明 1 protected Enum(String name,int ordinal) 构造 以指定枚举的名称和枚举的常量创建枚举对象 2 protected Object clone() 普通 克隆枚举对象 3 public int compareTo(E o) 普通 比较此枚举与指定对象的顺序 4 public boolean equals(Object other) 普通 比较两个枚举对象是否相等。若相等，则返回true，否则返回false 5 public Class getDeclaringClass() 普通 返回与指定枚举常量的枚举类型相对应的Class对象 6 public int hashCode() 普通 返回枚举常量的哈希码 7 public String name() 普通 返回此枚举常量的名称，不能被重写 8 public int ordinal() 普通 返回枚举常量的序数（它在枚举声明中的位置，其中初始常量序数为 0） 9 public String toString() 普通 返回枚举常量的名称，可重写 10 public static &gt; T valueOf(Class enumType, String name) 普通 返回带指定名称的指定枚举类型的枚举常量 ​ 下面通过一些范例演示 Enum 类的使用。 枚举类型的values()方法 ​ 枚举类型实例都含有一个 values()方法，该方法是静态方法，用于将枚举类型的成员以数组的形式返回，也可以通过该方法获取枚举成员信息。 代码实例：(验证values()方法) 1234567891011121314151617181920enum Directions&#123; EAST,SOUTH,WEST,NORTH; //定义枚举成员&#125;public class Test&#123; public static void main(String[] args) &#123; System.out.println(&quot;使用循环方式输出：&quot;); for(int i=0;i&lt;Directions.values().length;i++) &#123; System.out.println(&quot;枚举成员：&quot;+Directions.values()[i]); &#125; System.out.println(&quot;使用foreach方式输出：&quot;); for(Directions dir:Directions.values()) &#123; System.out.println(&quot;枚举成员：&quot;+dir); &#125; &#125;&#125; 运行结果： 12345678910使用循环方式输出：枚举成员：EAST枚举成员：SOUTH枚举成员：WEST枚举成员：NORTH使用foreach方式输出：枚举成员：EAST枚举成员：SOUTH枚举成员：WEST枚举成员：NORTH ​ 可以发现，values()是静态方法，可以通过“枚举.values()” 的形式调用。该方法返回的是枚举类型的数组，所以可以使 用length获取其长度。 获取枚举成员的名称和索引 ​ 在 Enum 类中，提供了name()方法可以获取枚举类型成员的名称，而ordinal()方法用于获取每个枚举成员的索引值， 索引值从0 开始。 代码示例：(获取枚举成员的名称和索引) 1234567891011121314151617181920212223enum Directions&#123; EAST,SOUTH,WEST,NORTH; //定义枚举成员&#125;public class Test&#123; public static void main(String[] args) &#123; System.out.println(&quot;使用循环方式输出：&quot;); for(int i=0;i&lt;Directions.values().length;i++) &#123; System.out.println(&quot;索引位置：&quot;+Directions.values()[i].ordinal()+ &quot;，枚举成员名称：&quot;+Directions.values()[i].name()); &#125; System.out.println(&quot;使用foreach方式输出：&quot;); for(Directions dir:Directions.values()) &#123; System.out.println(&quot;索引位置：&quot;+dir.ordinal()+ &quot;，枚举成员名称：&quot;+dir.name()); &#125; &#125;&#125; 运行结果： 12345678910使用循环方式输出：索引位置：0，枚举成员名称：EAST索引位置：1，枚举成员名称：SOUTH索引位置：2，枚举成员名称：WEST索引位置：3，枚举成员名称：NORTH使用foreach方式输出：索引位置：0，枚举成员名称：EAST索引位置：1，枚举成员名称：SOUTH索引位置：2，枚举成员名称：WEST索引位置：3，枚举成员名称：NORTH ​ 在以上程序中，使用的是循环方式和 foreach 方式获取每个枚举成员，foreach显得更为简洁。Enum 类会自动为枚举类型中的每一个枚举成员进行自动编号，从 0 开始。 枚举类的构造方法与valueof()方法 ​ 枚举类型是一个特殊的类，那么类相关的规则在枚举类型中也是适用的。枚举类的构造方法常用作添加枚举成员的构造方法，为各个枚举成员添加附加的说明。枚举类型中的静态方法 valueOf()可将字符串转变为枚举类型。 代码示例：( 枚举类型对象属性) 123456789101112131415161718192021222324252627enum Directions&#123; EAST(&quot;东&quot;),SOUTH(&quot;南&quot;),WEST(&quot;西&quot;),NORTH(&quot;北&quot;); private String name; private Directions() &#123; this(null); &#125; private Directions(String name) &#123; this.name=name; &#125; public String getName() &#123; return name; &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; for(Directions dir:Directions.values()) &#123; System.out.println(&quot;索引位置：&quot;+dir.ordinal()+&quot;。枚举成员名称：&quot;+dir.name()+&quot;，说明信息：&quot;+dir.getName()); &#125; &#125;&#125; 运行结果： 1234索引位置：0。枚举成员名称：EAST，说明信息：东索引位置：1。枚举成员名称：SOUTH，说明信息：南索引位置：2。枚举成员名称：WEST，说明信息：西索引位置：3。枚举成员名称：NORTH，说明信息：北 ​ 以上程序中，Directions 类的构造方法为 private 的，这意味着外部是无法调用其构造方法创建对象的。其中， 1EAST(&quot;东&quot;) 相当于： 1public static final Directions EAST=new Directions(&quot;东&quot;) ​ 还可以使用 setter 方法来设置枚举成员的属性，但操作的枚举成员的属性值是明确的。 如果操作的对象是 EAST，则其属性值应该为东，若操作的是 WEST，则其属性值应该是西。 代码示例：(使用 setter 方法设置枚举成员的属性) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566enum Directions&#123; EAST,SOUTH,WEST,NORTH; private String name; public void setName(String name) &#123; switch(this) &#123; case EAST: if(name.equals(&quot;东&quot;)) &#123; this.name=name; &#125;else &#123; System.out.println(&quot;设置EAST属性错误！&quot;); return; &#125; break; case SOUTH: if(name.equals(&quot;南&quot;)) &#123; this.name=name; &#125;else &#123; System.out.println(&quot;设置SOUTH属性错误！&quot;); return; &#125; break; case WEST: if(name.equals(&quot;西&quot;)) &#123; this.name=name; &#125;else &#123; System.out.println(&quot;设置WEST属性错误！&quot;); return; &#125; break; case NORTH: if(name.equals(&quot;北&quot;)) &#123; this.name=name; &#125;else &#123; System.out.println(&quot;设置NORTH属性错误！&quot;); return; &#125; break; &#125; &#125; public String getName() &#123; return name; &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; Directions dir=Directions.SOUTH; dir.setName(&quot;南&quot;); System.out.println(&quot;属性：&quot;+dir.getName()); dir.setName(&quot;左&quot;); System.out.println(&quot;属性：&quot;+dir.getName()); &#125;&#125; 运行结果： 123属性：南设置SOUTH属性错误！属性：南 ​ 以上程序中，取得枚举类中的枚举成员后，想要为其设置 name 属性，则先要对其进行判断。若符合要求，则执行 this.name=name；不符合要求，则输出“设置 XXX 属性错 误！”。除此之外，还可以通过valueOf()方法获取枚举类的对象。 代码示例：(valueOf()方法获取枚举类的对象) 1234567891011public class Test&#123; public static void main(String[] args) &#123; Directions dir=Enum.valueOf(Directions.class,&quot;SOUTH&quot;); dir.setName(&quot;南&quot;); System.out.println(&quot;属性：&quot;+dir.getName()); dir.setName(&quot;左&quot;); System.out.println(&quot;属性：&quot;+dir.getName()); &#125;&#125; 运行结果： 123属性：南设置SOUTH属性错误！属性：南 ​ 以上程序中，Directions.class 为反射机制的内容，后面将会详细地讲解，这样可以根据用户输入来设置枚举成员。 类集的枚举操作：EnumMap和EnumSet ​ 从JDK1.5开始，java.util包中新增了两个用来建立枚举类的集合类，EnumMap和EnumSet，其中EnumMap是Map的子类，而EnumSet是Set的子类。 EnumMap类 ​ EnumMap类是一个与枚举类一起实现的Map的子类，其本身是以Map的形式操作的，即 key→value。EnumMap在内部是以数组形式保存的，所以EnumMap的实现非常高效。与普通的 Map集合不同的是，EnumMap要与指定枚举类关联。EnumMap的常用方法如下表所示。 序号 方法 类型 说明 1 protected EnumMap(Class&lt;K&gt; keyType) 构造 创建具有指定key类型的空枚举映射 2 protected EnumMap(EnumMap&lt;K,? extends V&gt; m) 构造 创建一个枚举映射，其key类型与指定的枚举映射相同 3 protected numMap(Map&lt;K,? extends V&gt; m) 构造 创建从指定Map初始化的枚举映射 4 public EnumMap&lt;K,V&gt; clone() 普通 返回此枚举映射的副本 5 public boolean containsKey(Object key) 普通 如果此映射包含指定的key，则返回 true 6 public boolean containsValue(Object Value) 普通 如果此映射包含指定的value，则返回 true 7 public void clear() 普通 从此映射中删除所有映射 8 public Set&lt;Map Entry&lt;K,V&gt; entrySet() 普通 将此Map转换为Set集合 9 public boolean equals(Object o) 普通 比较指定的对象o与此Map对象是否相等。若相等，则返回true，否则返回false 10 public V get(Object key) 普通 返回指定key所映射的value值。如果此key不包含映射关系，则返回null 11 public int hashCode() 普通 返回此Map集合的哈希码值 12 public Set&lt;K&gt; keySet() 普通 返回此Map集合中所有的key值 13 public V put(K key,V value) 普通 向此Map集合添加新的元素 14 public void putAll(Map&lt;? extends K,? extends V&gt; m) 普通 将指定的Map集合中的所有内容添加到此Map集合中 15 public V remove(Object key) 普通 根据key值删除相对应的value值 16 public int size() 普通 获取此Map集合的元素个数 17 public Collection&lt;V&gt; values() 普通 获取此Map集合中所有的value值 代码示例：(验证EnumMap的应用) 1234567891011121314151617181920212223242526import java.util.Set;import java.util.Map;import java.util.EnumMap;import java.util.Iterator;enum Directions&#123; EAST,SOUTH,WEST,NORTH;&#125;public class Test&#123; public static void main(String[] args) &#123; EnumMap&lt;Directions,String&gt; em=new EnumMap&lt;Directions,String&gt;(Directions.class); em.put(Directions.EAST,&quot;东&quot;); em.put(Directions.SOUTH,&quot;南&quot;); em.put(Directions.WEST,&quot;西&quot;); em.put(Directions.NORTH,&quot;北&quot;); Set&lt;Map.Entry&lt;Directions,String&gt;&gt; set=em.entrySet(); Iterator&lt;Map.Entry&lt;Directions,String&gt;&gt; it=set.iterator(); while(it.hasNext()) &#123; Map.Entry&lt;Directions,String&gt; me=it.next(); System.out.println(me.getKey()+&quot;---→&quot;+me.getValue()); &#125; &#125;&#125; 运行结果： 1234EAST---→东SOUTH---→南WEST---→西NORTH---→北 ​ 在以上程序中，EnumMap 的使用与普通的 Map 集合使用没有多大区别。 提示：EnumMap 中不允许使用 null 作为 key 值，但允许 null 作为 value 值。 EnumSet 类 ​ EnumSet 是与枚举类型一起使用的 Set 实现。EnumSet 集合中的所有值都必须来自单个枚举类型，该枚举类型在创建 EnumSet 对象时显式或隐式地指定。EnumSet 集合中的元素是有序的，是根据枚举成员在枚举类中定义的顺序决定的，即根据 ordinal()排序。EnumSet 在内部表示为位向量，此表示形式非常紧凑且高效，其空间和时间性能应该很好。尤其是在批量操作（如 containsAll 和 retainAll）时运行得非常快。 ​ EnumSet 集合不允许 null 元素。试图插入 null 元素将抛出 NullPointerException。但是， 试图测试是否出现 null 元素或移除 null 元素将不会抛出异常。 ​ EnumSet 的构造方法是 private 的，其他类是不能通过其构造方法来创建 EnumSet 对象 的，所以 EnumSet 提供很多静态方法。EnumSet 类的常用方法如下表所示。 提示：EnumSet 是不同步的。 序号 方法 类型 说明 1 public boolean add(E e) 普通 向集合中添加元素 2 public static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; allOf(Class&lt;E&gt; elementType) 静态 以指定元素类型创建一个EnumSet对象 3 public static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; complementOf(EnumSet&lt;E&gt; s) 静态 创建一个其元素类型与指定EnumSet集合s相同的EnumSet集合，包含s中所不包含的此类型的所有元素 4 public static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; copyOf(Collection&lt;E&gt; c) 静态 创建一个包含c中的所有元素的EnumSet集合 5 public static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; iterator() 静态 创建 Iterator 实例 6 public static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; noneOf(Class&lt;E&gt; elementType) 静态 创建一个具有指定元素类型的空 EnumSet 集合 7 public static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; of(E e1,E e2…) 静态 创建一个最初包含指定元素e的 EnumSet 集合 8 public static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; range(E from, E to) 静态 创建一个最初包含由两个指定端点所定义范围内的所有元素的 EnumSet 集合 9 public boolean remove(Object o) 普通 从集合中删除指定的元素 ​ 下面通过一些范例来演示 EnumSet 类的操作。 向集合中添加元素 ​ EnumSet 类提供 allOf()方法，向集合中添加元素，还可以使用其继承来的 add()和 addAll()方法。 代码示例：(allOf()方法向集合中添加元素) 12345678910111213141516171819202122232425262728293031323334import java.util.Set;import java.util.EnumSet;import java.util.Iterator;enum Directions&#123; EAST,SOUTH,WEST,NORTH;&#125;public class Test&#123; public static void show(EnumSet ms) &#123; Iterator&lt;Directions&gt; it=ms.iterator(); while(it.hasNext()) &#123; System.out.println(it.next()); &#125; &#125; public static void main(String[] args) &#123; EnumSet&lt;Directions&gt; ms1=EnumSet.allOf(Directions.class); System.out.println(&quot;enumset1 = EnumSet.allOf(Directions .class)&quot;); show(ms1); EnumSet&lt;Directions&gt; ms2=EnumSet.noneOf(Directions.class); ms2.add(Directions.EAST); ms2.add(Directions.SOUTH); ms2.add(Directions.NORTH); System.out.println(&quot;enumset2 = EnumSet.noneOf(Directions .class)和 add()&quot;); show(ms2); EnumSet&lt;Directions&gt; ms3=EnumSet.noneOf(Directions.class); ms3.addAll(ms1); System.out.println(&quot;enumset3 = EnumSet.noneOf(Directions .class)和 addAll()&quot;); show(ms3); &#125;&#125; 运行结果： 1234567891011121314enumset1 = EnumSet.allOf(Directions .class)EASTSOUTHWESTNORTHenumset2 = EnumSet.noneOf(Directions .class)和 add()EASTSOUTHNORTHenumset3 = EnumSet.noneOf(Directions .class)和 addAll()EASTSOUTHWESTNORTH ​ 在以上程序中，EnumSey类的静态方法allOf()是将一个枚举类的所有枚举成员添加到EnumSet集合中。而静态方法noneOf()方法只是将集合中的元素设置为指定的枚举类型，并没有添加任何枚举类中的枚举成员到EnumSet集合中，即执行noneOf()方法生成的EnumSet集合是空集合。 of()、copyOf()和range()方法 ​ EnumSet 类中的静态方法 of()可以创建一个包含指定元素的 EnumSet 集合。静态方法 copyOf()可以将指定集合中所有的元素复制到另一个 EnumSet 集合中。range()也可用于创建一个包含指定元素的 EnumSet 集合，但其可以包含的是由两个指定端点所定义范围内的所有元素。 代码示例：( 验证of()、copyOf()和range() ) 12345678910111213141516171819202122232425262728293031import java.util.Set;import java.util.EnumSet;import java.util.Iterator;enum Directions&#123; EAST,SOUTH,WEST,NORTH;&#125;public class Test&#123; public static void show(EnumSet ms) &#123; Iterator&lt;Directions&gt; it=ms.iterator(); while(it.hasNext()) &#123; System.out.println(it.next()); &#125; &#125; public static void main(String[] args) &#123; EnumSet&lt;Directions&gt; ms1=EnumSet.of(Directions.EAST,Directions.WEST); System.out.println(&quot;enumset1=EnumSet.of(Directions.EAST,Directions.WEST)&quot;); show(ms1); EnumSet&lt;Directions&gt; ms2=EnumSet.copyOf(ms1); System.out.println(&quot;enumset2=EnumSet.copyOf(ms1)&quot;); show(ms2); EnumSet&lt;Directions&gt; ms3=EnumSet.range(Directions.WEST,Directions.NORTH); ms3.addAll(ms1); System.out.println(&quot;enumset3=EnumSet.range(Directions.WEST,Directions.NORTH)&quot;); show(ms3); &#125;&#125; 运行结果： 12345678910enumset1=EnumSet.of(Directions.EAST,Directions.WEST)EASTWESTenumset2=EnumSet.copyOf(ms1)EASTWESTenumset3=EnumSet.range(Directions.WEST,Directions.NORTH)EASTWESTNORTH 枚举类与接口 ​ 一般情况下，接口中都包含抽象方法。当一个枚举类实现接口时，每一个枚举对象都必须分别实现接口中的抽象方法。与普通类一样，枚举类也是可以实现多个接口的，但必须实现所有的抽象方法。 代码示例：(枚举类实现接口) 123456789101112131415161718192021222324252627282930313233343536373839404142434445interface EnumInterface&#123; void show();&#125;enum Directions implements EnumInterface&#123; EAST() &#123; public void show() &#123; System.out.println(&quot;此枚举成员为东&quot;); &#125; &#125;, SOUTH() &#123; public void show() &#123; System.out.println(&quot;此枚举成员为南&quot;); &#125; &#125;, WEST() &#123; public void show() &#123; System.out.println(&quot;此枚举成员为西&quot;); &#125; &#125;, NORTH() &#123; public void show() &#123; System.out.println(&quot;此枚举成员为北&quot;); &#125; &#125;;&#125;public class Test&#123; public static void main(String[] args) &#123; for(Directions dir:Directions.values()) &#123; dir.show(); &#125; &#125;&#125; 运行结果： 1234此枚举成员为东此枚举成员为南此枚举成员为西此枚举成员为北 ​ 从以上的程序可以发现，枚举类实现接口与普通类是一致的，都是使用 implements 关键字来实现接口的，并且需要实现接口中的所有抽象方法。枚举成员后面的花括号实际上是类体部分，可以说枚举类中的枚举成员是枚举类中的匿名内部子类。 枚举类与抽象方法 ​ 枚举类除了可以实现接口中的抽象方法之外，还可以直接在枚举类中定义抽象方法。一个枚举类可以定义一个或多个抽象方法，但每一个枚举对象需要实现每一个抽象方法。 代码示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364interface EnumInterface&#123; void show();&#125;enum Directions implements EnumInterface&#123; EAST() &#123; public void show() &#123; System.out.println(&quot;此枚举成员为东&quot;); &#125; public String getDirections() &#123; return &quot;东&quot;; &#125; &#125;, SOUTH() &#123; public void show() &#123; System.out.println(&quot;此枚举成员为南&quot;); &#125; public String getDirections() &#123; return &quot;南&quot;; &#125; &#125;, WEST() &#123; public void show() &#123; System.out.println(&quot;此枚举成员为西&quot;); &#125; public String getDirections() &#123; return &quot;西&quot;; &#125; &#125;, NORTH() &#123; public void show() &#123; System.out.println(&quot;此枚举成员为北&quot;); &#125; public String getDirections() &#123; return &quot;北&quot;; &#125; &#125;; public abstract void show(); public abstract String getDirections();&#125;public class Test&#123; public static void main(String[] args) &#123; for(Directions dir:Directions.values()) &#123; dir.show(); System.out.println(&quot;属性：&quot;+dir.getDirections()); &#125; &#125;&#125; 运行结果： 12345678此枚举成员为东属性：东此枚举成员为南属性：南此枚举成员为西属性：西此枚举成员为北属性：北 ​ 由以上程序可以发现，在枚举类中定义抽象方法，枚举类不需要显式使用 abstract 关键字将枚举类定义为抽象类，并且在枚举类中定义抽象方法时，必须有枚举成员实现，定义多少个抽象方法就必须实现多少个。 参考书目： 《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"其他集合","slug":"java/集合与泛型/其他集合","date":"2021-08-18T11:46:41.000Z","updated":"2021-10-27T04:45:28.024Z","comments":true,"path":"2021/08/18/java/集合与泛型/其他集合/","link":"","permalink":"https://silenthly.github.io/2021/08/18/java/%E9%9B%86%E5%90%88%E4%B8%8E%E6%B3%9B%E5%9E%8B/%E5%85%B6%E4%BB%96%E9%9B%86%E5%90%88/","excerpt":"​ 面学习了java 常用的集合类和接口，还有一些集合类和接口虽然已经被取代，但是在早期的程序中还是会出现，有的在java Web 编程时还会使用。所以本文将对 Vector、 Stacke 类进行简单的介绍，以便读者认识它们。","text":"​ 面学习了java 常用的集合类和接口，还有一些集合类和接口虽然已经被取代，但是在早期的程序中还是会出现，有的在java Web 编程时还会使用。所以本文将对 Vector、 Stacke 类进行简单的介绍，以便读者认识它们。 向量类：Vector类 Vector类的定义如下： 1public class Vector&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, Serializable ​ 可以看出Vector类是List的子类，但实际上Vector类是一个元老级别的类，在JDK 1.0时就已存在（List在JDK1.2时才存在）。为了让Vector类可以保存下来，java 设计者让其实现了List 接口。 ​ Vector类与ArrayList是类似的，在ArrayList还未出现之前，Vector是使用最为广泛的顺序表。为了保证Vector类能与现在的集合框架兼容，从JDK1.5 后Vector类又被重新设计为泛型，并成为AbstractLis 的子类。所以，Vector类与ArrayList的使用没有多大的 区别。下面通过一个范例来演示其操作。 代码示例： 1234567891011121314151617181920212223242526272829303132import java.util.Iterator;import java.util.Vector;import java.util.Collections;public class Test&#123; public static void main(String[] args) &#123; Vector&lt;String&gt; vector=new Vector&lt;String&gt;(); vector.add(&quot;A&quot;); vector.addElement(&quot;B&quot;); vector.addElement(&quot;c&quot;); Collections.addAll(vector,&quot;M&quot;,&quot;N&quot;,&quot;O&quot;); vector.remove(1); Iterator&lt;String&gt; it=vector.iterator(); System.out.println(&quot;使用Iterator&quot;); while(it.hasNext()) &#123; System.out.print(it.next()+&quot; &quot;); &#125; System.out.println(&quot;\\n使用foreach&quot;); for(String str:vector) &#123; System.out.print(str+&quot; &quot;); &#125; System.out.println(&quot;\\n使用get()&quot;); int len=vector.size(); for(int i=0;i&lt;len;i++) &#123; System.out.print(vector.get(i)+&quot; &quot;); &#125; &#125;&#125; 运行结果： 123456使用IteratorA c M N O使用foreachA c M N O使用get()A c M N O ​ 从上面程序可以发现，Vector类的操作与ArrayList类的操作没有多大的区别，只不过是Vector 类出现较早，并定义了许多 ArrayList 类中没有定义的方法，如addElement()。 ArrayList与Vector的区别 ​ ArrayList和Vector都是List的子类，都是有序的集合，可以存储相同的元素，相当于动态数组。它们都可以按索引位置取得指定的元素。两者的主要区别有如下几点。 （1）出现的时间 ​ Vector 是在 JDK 1.0 时就已存在，而 ArrayList 到了 JDK 1.2 才推出。 （2）同步性 ​ Vector 是线程安全的，也就是说它的方法之间是线程同步的；而 ArrayList 是线程不安全的，它的方法之间是线程不同步的。在程序设计中，如果是只有一个线程会访问到集合， 那最好选择使用 ArrayList，因为它不考虑线程安全，效率会高些；如果有多个线程会访问到集合，那最好选择使用 Vector，因为不需要开发人员自己编写线程安全的代码。 （3）数据增长 ​ ArrayList 与 Vector 都存在初始的容量大小，当存储进集合里的元素的个数超过了容量时，就需要增加 ArrayList 与 Vector 的存储空间。每次要增加存储空间时，不是只增加一 个存储单元，而是增加多个存储单元。这就要求每次增加的存储单元的个数在内存空间利 用与程序效率之间要取得一定的平衡。Vector 默认增长为原来一倍，而 ArrayList 的增长策略在文档中没有明确规定（从源代码看到的是增长为原来的一半）。 ​ 另外，还需要注意的是，ArrayList 与 Vector 都可以设置初始的空间大小，但 Vector 还可以设置增长的空间大小，而 ArrayList 没有提供设置增长空间的方法。 （4）输出方式 ​ Vector 可以使用 Iterator、foreach 和 Enumeration 方式输出，而 ArrayList 只能使用 Iterator、foreach 方式输出。 栈：Stack类 ​ 栈是一种特殊的线性表，它仅限于在表尾进行元素的添加与删除操作。栈的表尾称为栈顶，表头称为栈底。栈是采用“先进后出”的数据存储方式，若栈中没有任何元素，则称为空栈。在java中可以使用Stack类来封装栈，其定义如下： 1public class Stack&lt;E&gt; extends Vector&lt;E&gt; ​ 可以发现，Stack是Vector的子类，自JDK1.5以后java并没有提供任何类来取代Stack 类，但对其重新设计为泛型。Stack类提供的方法如表所示。 序号 方法 类型 说明 1 public boolean empty() 普通 判断该栈是否为空。若为空，则返回true，否则返回false 2 public E peek() 普通 获取栈顶元素，但不删除它 3 public E pop() 普通 获取栈顶元素，并删除它 4 public E push(E item) 普通 将元素添加到栈顶中 5 public int search(Object 0) 普通 查找指定元素在栈中位置，起始位置为1，不是0 代码示例： 12345678910111213141516171819202122import java.util.Iterator;import java.util.Stack;public class Test&#123; public static void main(String[] args) &#123; Stack&lt;String&gt; stack=new Stack&lt;String&gt;(); stack.push(&quot;A&quot;); stack.push(&quot;B&quot;); stack.push(&quot;C&quot;); stack.push(&quot;D&quot;); Iterator&lt;String&gt; it=stack.iterator(); while(it.hasNext()) &#123; System.out.print(it.next()+&quot; &quot;); &#125; System.out.println(&quot;\\n出栈&quot;+stack.pop()); System.out.println(&quot;出栈&quot;+stack.pop()); System.out.println(&quot;出栈&quot;+stack.pop()); System.out.println(&quot;出栈&quot;+stack.pop()); &#125;&#125; 运行结果： 12345A B C D出栈D出栈C出栈B出栈A ​ 从程序的运行结果可以发现，先入栈的元素，最后才出 来，满足了“先进后出，后进先出”的特性。 哈希表：Hashtable类 Hashtable类的定义如下： 1public class Hashtable&lt;K,V&gt; extends Dictionary&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable ​ 可以看出Hashtable类是Map的子类，它与Vector类型一样都是在JDK1.0时出现的，属于元老级别的操作类。Hashtable类是同步的、线程安全的，不允许存放null key和null value。其他的功能与HashMap类似。 代码示例： 12345678910111213141516171819202122232425import java.util.Set; import java.util.Iterator; import java.util.Map; import java.util.Hashtable; public class Test&#123; public static void main(String[] args) &#123; Map&lt;String,String&gt; map=new Hashtable&lt;String,String&gt;(); map.put(&quot;THU&quot;,&quot;清华大学&quot;); map.put(&quot;CUMT&quot;,&quot;中国矿业大学&quot;); map.put(&quot;FU&quot;,&quot;复旦大学&quot;); map.put(&quot;USTC&quot;,&quot;中国科技大学&quot;); map.put(&quot;WHU&quot;,&quot;武汉大学&quot;); map.put(&quot;PKU&quot;,&quot;北京大学&quot;); //添加内容 Set&lt;Map.Entry&lt;String,String&gt;&gt; set=map.entrySet(); Iterator&lt;Map.Entry&lt;String,String&gt;&gt; it = set.iterator(); System.out.println(&quot;Key-----Value&quot;); while (it.hasNext()) &#123; Map.Entry&lt;String,String&gt; mapEntry =it.next(); System.out.println(&quot; &quot;+mapEntry.getKey()+&quot;----&quot;+mapEntry.getValue()); &#125; &#125; &#125; 运行结果： 1234567Key-----Value CUMT----中国矿业大学 WHU----武汉大学 PKU----北京大学 USTC----中国科技大学 THU----清华大学 FU----复旦大学 ​ 上面程序与前面学习的 HashMap 没有多大的区别。 HashMap与Hashtable的区别 ​ HashMap 和 Hashtable 都 Map 接口的实现类，而 HashMap 是 Hashtable 的轻量级实现（非线程安全的实现）。两者的主要区别有以下几点： （1）出现的时间 ​ Hashtable 在 JDK 1.0 时出现，属于旧的操作类，而 HashMap 是在 JDK 1.2 时退出的类， 属于较新的操作类。 （2）同步性 ​ Hashtable 是线程安全的，也就是说是同步的，性能相对较低，而 HashMap 是线程不安全的，不是同步的，性能相对较高。 （3）值 ​ Hashtable 不允许存在 null value和 null key，而 HashMap 允许存在一个 null key和多个 null value。 参考书目： 《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"集合工具类：Collections","slug":"java/集合与泛型/集合工具类：Collections","date":"2021-08-18T00:15:15.000Z","updated":"2021-10-27T04:45:35.268Z","comments":true,"path":"2021/08/18/java/集合与泛型/集合工具类：Collections/","link":"","permalink":"https://silenthly.github.io/2021/08/18/java/%E9%9B%86%E5%90%88%E4%B8%8E%E6%B3%9B%E5%9E%8B/%E9%9B%86%E5%90%88%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%9ACollections/","excerpt":"CollectionS类 ​ 在java集合类中，有一个功能强大的工具类——java.util.Collections类。Collections类是用于操作List、Set和Map等集合的工具类，该类提供了大量的方法可以对集合元素进行排序、查询和修改等操作。其定义如下：","text":"CollectionS类 ​ 在java集合类中，有一个功能强大的工具类——java.util.Collections类。Collections类是用于操作List、Set和Map等集合的工具类，该类提供了大量的方法可以对集合元素进行排序、查询和修改等操作。其定义如下： 1public class Collections extends Object ​ Collections类可以对集合的元素进行排序、反序、去极值、循环移位、查询和修改等功能，还可以将集合对象设置不可变、对集合对象实现同步控制等方法。Collections类的常用方法如下表所示： 序号 方法 类型 说明 1 public static List EMPTY_LIST 常量 返回一个空的List集合 2 public static Map EMPTY_MAP 常量 返回一个空的 Map 集合 3 public static Set EMPTY_SET 常量 返回一个空的 Set 集合 4 public static boolean addAll(Collection&lt;? super T&gt; c,T…elements) 静态 将所有指定元素添加到指定集合中 5 public static &lt;T&gt; int binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key) 静态 使用二分搜索法搜索列表，以获得指定元素的位置。若不存在该元素，则返 回-1 6 public static &lt;T&gt; int binarySearch(List&lt;? extends T&gt; list, T key,Comparator&lt;? super T&gt; c) 静态 使用二分搜索法搜索列表，以获得指定元素的位置。若不存在该元素，则返 回-1 7 public static &lt;T&gt; void copy(List&lt;? supper T&gt; dest, List&lt;? extends T&gt; src) 静态 将src集合中的所有元素复制到dest集合中 8 public static boolean disjoint(Collection c1, Collection c2) 静态 判断两个集合是否存在相同的元素。若不存在，则返回true，否则返会false 9 public static &lt;T&gt; void fill(List&lt;? super T&gt; list, T obj) 静态 使用指定元素替换指定集合中的所有元素 10 public static&lt;T extends Object &amp; Comparable&lt;? super T&gt;&gt;T max(Collection&lt;? extends T&gt; coll) 静态 根据元素的自然顺序，返回给指定集合的最大元素 11 public static&lt;T&gt; T max(Collection&lt;? extends T&gt; coll, Comparator&lt;? super T&gt; comp) 静态 根据指定比较器产生的顺序，返回指定集合的最大元素 12 public static&lt;T extends Object &amp; Comparable&lt;? super T&gt;&gt;T min(Collection&lt;? extends T&gt; coll) 静态 根据元素的自然顺序，返回指定集合的最小元素 13 public static&lt;T&gt; T min(Collection&lt;? extends T&gt; coll, Comparator&lt;? super T&gt; comp) 静态 根据指定比较器产生的顺序，返回指定集合的最小元素 14 public static&lt;T&gt; boolean replaceAll(List &lt;T&gt; list, T oldVal, T newVal) 静态 使用另一个元素替换集合中指定的所有元素 15 public static void reverse(List&lt;?&gt; list) 静态 反序输出集合的所有元素 16 public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list) 静态 根据自然顺序，对指定集合进行升序排序 17 public static &lt;T&gt; void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c) 静态 根据指定比较器产生的顺序，对指定集合进行升序排序 18 public static void swap(List&lt;?&gt; list, int i, int j) 静态 在指定列表的指定位置处交换元素 19 public static &lt;T&gt; Collection &lt;T&gt; synchronizedCollection(Collection&lt;T&gt; c) 静态 将指定集合设置成支持的同步（线程安全的）集合。此方法有多种重载形式 ​ 以上方法中出现了许多&lt;? extends T&gt;和&lt;? super T&gt;，就效果来说和直接&lt;T&gt;其实效果一样，若不是必要，可以暂时忽视这些。Collections类所提供的方法均为静态方法，可以直接通过“类名.方法()”的形式调用。下面通过范例演示Collections类的使用。 添加元素并执行反序操作 ​ Collections类提供了addAll()方法可以一次添加多个元素，还提供了reverse()方法对集合中的元素进行反序操作。 代码示例： 12345678910111213141516171819202122232425262728import java.util.Collection;import java.util.Collections;import java.util.List;import java.util.ArrayList;import java.util.Iterator;public class Test&#123; public static void main(String[] args) &#123; List&lt;String&gt; list=new ArrayList&lt;String&gt;(); list.add(&quot;A&quot;); list.add(&quot;B&quot;); Collections.addAll(list,&quot;1&quot;,&quot;2&quot;,&quot;3&quot;); //通过Collections添加元素 Iterator&lt;String&gt; it1=list.iterator(); System.out.println(&quot;输出集合中的元素：&quot;); while(it1.hasNext()) &#123; System.out.print(it1.next()+&quot; &quot;); &#125; Collections.reverse(list); System.out.println(&quot;\\n对集合进行反序输出：&quot;); Iterator&lt;String&gt; it2=list.iterator(); while(it2.hasNext()) &#123; System.out.print(it2.next()+&quot; &quot;); &#125; &#125;&#125; 运行结果： 1234输出集合中的元素：A B 1 2 3对集合进行反序输出：3 2 1 B A 对集合中的元素进行查找和替换 ​ 可以直接使用Collections类的 binarySearch()方法， 查找集合中是否存在某个元素，若存在则返回该元素的索引位置，否则返回-1 。需要注意的是，在使用binarySearch()方法前需要对集合中的元素进行排序，可以直接使用Collections类的sort()方法。除此之外，还可以使用replaceAll()方法替换集合中所有的指定元素。 代码示例： 12345678910111213141516171819202122232425262728293031323334353637import java.util.Collection;import java.util.Collections;import java.util.List;import java.util.ArrayList;import java.util.Iterator;public class Test&#123; public static void main(String[] args) &#123; List&lt;String&gt; list=new ArrayList&lt;String&gt;(); list.add(&quot;A&quot;); list.add(&quot;M&quot;); Collections.addAll(list,&quot;A&quot;,&quot;A&quot;,&quot;D&quot;,&quot;Z&quot;,&quot;C&quot;); Iterator&lt;String&gt; it=list.iterator(); System.out.println(&quot;排序前：&quot;); while(it.hasNext()) &#123; System.out.print(it.next()+&quot; &quot;); &#125; Collections.sort(list); //通过Collections进行排序 System.out.println(&quot;\\n排序后：&quot;); it=list.iterator(); //重新获取list中的集合 while(it.hasNext()) &#123; System.out.print(it.next()+&quot; &quot;); &#125; System.out.println(&quot;\\n集合中是否存在元素M：&quot;+Collections.binarySearch(list,&quot;M&quot;)); System.out.println(&quot;集合中是否存在元素M：&quot;+Collections.binarySearch(list,&quot;U&quot;)); Collections.replaceAll(list,&quot;A&quot;,&quot;1&quot;); //使用&quot;1&quot;替换集合中所有的&quot;A&quot; it=list.iterator(); //重新获取list中的集合 System.out.println(&quot;替换后：&quot;); while(it.hasNext()) &#123; System.out.print(it.next()+&quot; &quot;); &#125; &#125;&#125; 运行结果： 12345678排序前：A M A A D Z C排序后：A A A C D M Z集合中是否存在元素M：5集合中是否存在元素M：-7替换后：1 1 1 C D M Z ​ 从程序结果可以发现，查找失败的返回值并不是-1，这并不是程序出错，查找binarySearch的源代码可以发现，当查找失败时，返回语句是return -(low + 1)。其中，low是元素应插入的位置，-(low+1)是为了避免返回-0的情况，由此可见查询不到时不一定返回-1。再一次强调，在使用 binarySearch()前一定要先对集合进行排序，即先执行sort()方法，否则编译器虽不会报错，但查找的结果是错误的。 参考链接： Java泛型和_百度知道 (baidu.com) 【Java入坑之路】关于Collections.binarySearch查找结果不符合预期的探究_Hertter的博客-CSDN博客_collections.binarysearch 参考书目： 《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Map接口","slug":"java/集合与泛型/Map接口","date":"2021-08-17T01:05:54.000Z","updated":"2021-10-27T04:43:08.117Z","comments":true,"path":"2021/08/17/java/集合与泛型/Map接口/","link":"","permalink":"https://silenthly.github.io/2021/08/17/java/%E9%9B%86%E5%90%88%E4%B8%8E%E6%B3%9B%E5%9E%8B/Map%E6%8E%A5%E5%8F%A3/","excerpt":"​ Map接口并没有继承Collection接口，可用于保存具有映射关系的数据，其提供的是key到value的映射。因此，Map集合中保存这两组值，一组用于保存key，另一组用于保存value，key和value都可以是任何引用数据类型。Map集合中的key不允许重复，每一个key只能映射一个value。","text":"​ Map接口并没有继承Collection接口，可用于保存具有映射关系的数据，其提供的是key到value的映射。因此，Map集合中保存这两组值，一组用于保存key，另一组用于保存value，key和value都可以是任何引用数据类型。Map集合中的key不允许重复，每一个key只能映射一个value。 Map映射接口 Map接口定义如下： 1public interface Map&lt;K,V&gt; ​ 可以发现Map没有继承Collection接口，其提供的是key到value的映射。与Collection接口属于单值集合不同的是，Map的元素属于二元偶对象。Map集合不允许存在相同的key，每一个key只能映射一个value。key还决定了存储对象在映射中的存储位置，但这不是由key本身决定的，而是散列技术进行处理的。Map接口定义了许多方法，这些方法如下表所示。 序号 方法 类型 说明 1 public void clear() 抽象 删除此Map集合中所有的key-value 2 public boolean containsKey(Object key) 抽象 判断指定的key是否存在。若存在，则返回true，否则返回false 3 public boolean containsValue(Object value) 抽象 判断指定的value是否存在，若存在，则翻译true，否则返回false 4 public Set&lt;Map Entry&lt;K,V&gt; entrySet() 抽象 将此Map对象转换为Set集合 5 public boolean equals(Object o) 抽象 比较指定的对象o与此Map对象是否相等。若相等，则返回true，否则返回false 6 public V get(Object key) 抽象 返回指定key所映射的value值。如果此key不包含映射关系，则返回null 7 public int hashCode() 抽象 返回此Map集合的哈希码值 8 public boolean isEmpty() 抽象 判断此Map集合是否为空。若为空，则返回true，否则返回false 9 public Set&lt;K&gt; keySet() 抽象 返回此Map集合中所有的key值 10 public V put(K key,V value) 抽象 向此Map集合添加新的元素 11 public void putAll(Map&lt;? extends K,? extends V&gt; m) 抽象 将指定的Map集合中的所有内容添加到此Map集合中 12 public V remove(Object key) 抽象 根据key值删除相对应的value值 13 public int size() 抽象 获取此Map集合的元素个数 14 public Collection&lt;V&gt; values() 抽象 获取此Map集合中所有的value值 15 public default V getOrDefault(Object key,V defaultValue) 抽象 当Map集合中存在指定的key时，就使用这个key对应的value对象，否则将使用指定的value值 ​ 可以发现，Map的许多方法都含有Set关键字，不仅如此，Map里key集和Set集合里元素的存储形式也很像，Map子类和Set子类在名字上也惊人地相似，其实这并不是偶然。 ​ Set与Map之间的关系非常密切。虽然Map中放的元素是key-value对，Set集合中放的元素是单个对象，但如果把key-value对看做一体的，这样就可以像对待Set一样来对待Map了。事实上，Map提供了一个Entry内部接口来封装key-value对，而计算Entry存储时则只考虑Entry封装的key。从java源码来看，java是先实现了Map，然后通过包装一个所有value都为null的Map来实现Set集合。 Map.Entry接口 Map.Entry接口的定义如下： 1public static interface Map.Entry&lt;K,V&gt; ​ 可以发现Map.Entry接口是静态的，所以可直接使用&quot;外部类.内部类&quot;的形式调用。Map.Entry封装了一个key-value。Map.Entry接口的方法如下表。 序号 方法 类型 说明 1 public boolean equals(Object o) 抽象 比较指定对象与此Entry是否相等 2 public K getKey() 抽象 获取此Entry中包含的key值 3 public K getValue() 抽象 获取此Entry中包含的value值 4 public int hashCode() 抽象 返回此Entry的哈希码值 5 public V setValue(V value) 抽象 设置此Entry的value的值 哈希映射类：HashMap类 ​ HashMap类是Map接口的一个实现类，HashMap类的定义如下： 1public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;,Cloneable,Seriablizable ​ HashMap类是实现的Map集合，对于元素的添加和删除有着较高的效率，因为HashMap类是基于哈希表的Map接口的实现。HashMap类提供所有可选的映射操作，并允许使用null value和null key，但必须保证key是唯一的。 ​ HashMap是非同步的，也不保证映射顺序，它不能保证随着时间的推移保持不变。下面通过几个范例来认识HashMap实例的操作。 添加并获取 Map 集合的内容 ​ Map接口提供了put(K key,V value)，可以向Map集合中添加key-value，之后还可以通过get(Object key)获取key对应的value值。 代码示例： 1234567891011121314import java.util.Map;import java.util.HashMap;public class Test&#123; public static void main(String[] args) &#123; Map&lt;Integer,String&gt; map=new HashMap&lt;Integer,String&gt;(); map.put(1,&quot;清华大学&quot;); //向Map集合添加内容 map.put(2,&quot;北京大学&quot;); map.put(3,&quot;复旦大学&quot;); map.put(4,&quot;中山大学&quot;); System.out.println(&quot;获取内容：&quot;+map.get(4)); //获取内容 &#125;&#125; 运行结果： 1获取内容：中山大学 ​ 因为Map结合中，key与value是一一对应的，所以可以通过指定key获取其对应的value值。 获取Map集合中全部的key和value ​ Map接口中提供了keySet()和values()，可以分别获取Map集合中全部的key和value。不同的是，keySet()可以将Map集合中的所有值转换为Set集合，再使用Iterator输出，而values()返回的是Collection集合，同样可以是使用Iterator输出。 代码示例： 12345678910111213141516171819202122232425262728293031import java.util.Collection;import java.util.Iterator;import java.util.Set;import java.util.Map;import java.util.HashMap;public class Test&#123; public static void main(String[] args) &#123; Map&lt;Integer,String&gt; map=new HashMap&lt;Integer,String&gt;(); map.put(1,&quot;清华大学&quot;); //向Map集合添加内容 map.put(2,&quot;北京大学&quot;); map.put(3,&quot;复旦大学&quot;); map.put(4,&quot;中山大学&quot;); Set&lt;Integer&gt; set=map.keySet(); Iterator&lt;Integer&gt; itKey=set.iterator(); System.out.println(&quot;Map集合中全部的key：&quot;); while(itKey.hasNext()) &#123; System.out.print(itKey.next()+&quot; &quot;); //输出Map集合中的key &#125; System.out.println(); Collection&lt;String&gt; c=map.values(); Iterator&lt;String&gt; itValue=c.iterator(); System.out.println(&quot;Map集合中全部的value：&quot;); while(itValue.hasNext()) &#123; System.out.print(itValue.next()+&quot; &quot;); //输出Map集合中的value &#125; &#125;&#125; 运行结果： 1234Map集合中全部的key：1 2 3 4Map集合中全部的value：清华大学 北京大学 复旦大学 中山大学 ​ 将Map集合转换为Collection集合时，需要保存泛型类型的一致。 使用iterator输出Map集合 ​ Map集合与Collection集合不同，其本身不能使用Iterator进行输出。因为Map集合使用的是二元偶对象，而Iterator一次只能输出一个值。若想Map集合使用Iterator迭代器输出，则需要进行一些处理。首先，Map实例通过entrySet()方法转换为Set集合，再由Set集合实例化Iterator，这时Iterator迭代器可以输出Map.Entry对象，最后通过Map.Entry的getKey()和方法分离Map集合的key-value。 代码示例： 1234567891011121314151617181920212223import java.util.Iterator;import java.util.Set;import java.util.Map;import java.util.HashMap;public class Test&#123; public static void main(String[] args) &#123; Map&lt;Integer,String&gt; map=new HashMap&lt;Integer,String&gt;(); map.put(1,&quot;清华大学&quot;); //向Map集合添加内容 map.put(2,&quot;北京大学&quot;); map.put(3,&quot;复旦大学&quot;); map.put(4,&quot;中山大学&quot;); Set&lt;Map.Entry&lt;Integer,String&gt;&gt; set=map.entrySet(); Iterator&lt;Map.Entry&lt;Integer,String&gt;&gt; it=set.iterator(); System.out.println(&quot;Key-----Value&quot;); while(it.hasNext()) &#123; Map.Entry&lt;Integer,String&gt; mapEntry=it.next(); System.out.println(mapEntry.getKey()+&quot;------&quot;+mapEntry.getValue()); &#125; &#125;&#125; 运行结果： 12345Key-----Value1------清华大学2------北京大学3------复旦大学4------中山大学 ​ Map集合除了使用Iterator迭代器输出还可以使用foreach方式输出。范例如下： 代码示例： 123456789101112131415161718import java.util.Map;import java.util.HashMap;public class Test&#123; public static void main(String[] args) &#123; Map&lt;Integer,String&gt; map=new HashMap&lt;Integer,String&gt;(); map.put(1,&quot;清华大学&quot;); //向Map集合添加内容 map.put(2,&quot;北京大学&quot;); map.put(3,&quot;复旦大学&quot;); map.put(4,&quot;中山大学&quot;); System.out.println(&quot;Key-----Value&quot;); for(Map.Entry&lt;Integer,String&gt; mapEntry:map.entrySet()) &#123; System.out.println(mapEntry.getKey()+&quot;------&quot;+mapEntry.getValue()); &#125; &#125;&#125; 运行结果： 12345Key-----Value1------清华大学2------北京大学3------复旦大学4------中山大学 ​ 使用foreach方式输出Map集合，可以不需要通过Set集合，只需将集合中的每一个元素用Map.Entry类型的对象接收，再使用getKey()和getValue()分离Map集合的key-value。 虽然使用 foreach显得较为简便，但还是建议使用前面的 Iterator 迭代器输出。 有序树映射类：TreeMap类 ​ TreeMap类的定义如下： 1public class TreeMap&lt;K,V&gt; extends AbstractMao&lt;K,V&gt;,Cloneable,Serializable ​ TreeMap 类不但实现了Map接口，还实现了SortedMap接口。因此，TreeMap集合中 的映射关系具有一定的顺序性。与HashMap相比，TreeMap集合对元素的添加、删除和定位映射性能较低。 ​ TreeMap集合主要是对所有的key进行排序，从而保证所有的key-value映射关系处于有序状态，其默认的排序方式是升序排序（自然排序），但可以在创建TreeMap时，传入Comparator对象，负责对TreeMap所有的key进行排序。 代码示例： 1234567891011121314151617181920212223242526272829303132333435import java.util.Collection;import java.util.Iterator;import java.util.Set;import java.util.Map;import java.util.HashMap;import java.util.TreeMap;public class Test&#123; public static void main(String[] args) &#123; Map&lt;String,String&gt; hashMap=new HashMap&lt;String,String&gt;(); hashMap.put(&quot;THU&quot;,&quot;清华大学&quot;); hashMap.put(&quot;FU&quot;,&quot;复旦大学&quot;); hashMap.put(&quot;USTC&quot;,&quot;中国科技大学&quot;); hashMap.put(&quot;PKU&quot;,&quot;北京大学&quot;); Set&lt;Map.Entry&lt;String,String&gt;&gt; hashSet=hashMap.entrySet(); Iterator&lt;Map.Entry&lt;String,String&gt;&gt; hashIt=hashSet.iterator(); System.out.println(&quot;使用HashMap输出：&quot;); while(hashIt.hasNext()) &#123; Map.Entry&lt;String,String&gt; hashEntry=hashIt.next(); System.out.println(hashEntry.getKey()+&quot;------&quot;+hashEntry.getValue()); &#125; Map&lt;String,String&gt; treeMap=new TreeMap&lt;String,String&gt;(); treeMap.putAll(hashMap); //向TreeMap集合中添加HashMap集合 Set&lt;Map.Entry&lt;String,String&gt;&gt; treeSet=treeMap.entrySet(); Iterator&lt;Map.Entry&lt;String,String&gt;&gt; treeIt=treeSet.iterator(); System.out.println(&quot;使用TreeMap输出：&quot;); while(treeIt.hasNext()) &#123; Map.Entry&lt;String,String&gt; treeEntry=treeIt.next(); System.out.println(treeEntry.getKey()+&quot;------&quot;+treeEntry.getValue()); &#125; &#125;&#125; 运行结果： 12345678910使用HashMap输出：THU------清华大学USTC------中国科技大学PKU------北京大学FU------复旦大学使用TreeMap输出：FU------复旦大学PKU------北京大学THU------清华大学USTC------中国科技大学 ​ 从程序运行结果可以发现，HashMap输出的元素是无序的，TreeMap输出的元素是有序的。TreeMap集合中的数据排序是根据key值排序的。 提示：因为 String 类已经实现了 Comparable 接口，所以程序可以运行；若使用的是自 定义的类，则需要实现 Comparable 接口，否则将会出现类转换异常。 参考书目： 《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com) 《疯狂Java讲义(第3版)(含光盘)》【摘要 书评 试读】- 京东图书 (jd.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"集合的遍历输出","slug":"java/集合与泛型/集合的遍历输出","date":"2021-08-16T12:59:32.000Z","updated":"2021-10-27T04:45:49.033Z","comments":true,"path":"2021/08/16/java/集合与泛型/集合的遍历输出/","link":"","permalink":"https://silenthly.github.io/2021/08/16/java/%E9%9B%86%E5%90%88%E4%B8%8E%E6%B3%9B%E5%9E%8B/%E9%9B%86%E5%90%88%E7%9A%84%E9%81%8D%E5%8E%86%E8%BE%93%E5%87%BA/","excerpt":"​ 虽然各个集合类都有各样的输出，如Collection集合可以将元素转换为数组后输出，List 集合还可以是get()方法输出，但这些都不是集合的标 准输出。在 java中，主要提供了以下两个输出方式。 Iterator：迭代器输出，也是最常使用的。 foreach：这是JDK1.5以后新增的输出","text":"​ 虽然各个集合类都有各样的输出，如Collection集合可以将元素转换为数组后输出，List 集合还可以是get()方法输出，但这些都不是集合的标 准输出。在 java中，主要提供了以下两个输出方式。 Iterator：迭代器输出，也是最常使用的。 foreach：这是JDK1.5以后新增的输出 迭代输出：Iterator接口 ​ Iterator接口是一个提供遍历各种集合类型的迭代器。有的集合类没有提供get()方法，可以用迭代器来获取集合的元素信息。所有的Collection接口的子接口、子类都支持Iterator迭代器，Iterator接口提供了如下方法。 序号 方法 类型 说明 1 public boolean hasNext() 抽象 判断集合中是否还存在下一个元素。若存在，则返回true，否则返回false 2 public E next() 抽象 返回集合中的下一个元素，E代表元素的数据类型 3 public void remove() 抽象 将集合中上一个由next()方法返回的元素删除 ​ 下面通过几个范例来讲解Iterator方法的应用。 输出集合中的所有元素 ​ Collection子类都提供iterator()为Iterator实例化，所以直接调用该方法就可以使用Iterator接口输出。 代码示例： 1234567891011121314151617181920import java.util.LinkedList;import java.util.Iterator;public class Test&#123; public static void main(String[] args) &#123; LinkedList&lt;String&gt; link=new LinkedList&lt;String&gt;(); link.add(&quot;1&quot;); link.add(&quot;2&quot;); link.add(&quot;3&quot;); link.add(&quot;A&quot;); link.add(&quot;B&quot;); link.add(&quot;C&quot;); Iterator&lt;String&gt; it=link.iterator(); while(it.hasNext()) &#123; System.out.print(it.next()+&quot; &quot;); &#125; &#125;&#125; 运行结果： 11 2 3 A B C ​ 以上程序输出集合是一种标准的输出方式，以后遇到集合就可以使用Iterator方式输出。 删除集合中的部分元素 ​ 使用Iterator接口还可以删除集合中的元素，可以选择全部元素，也可以选择部分删除，直接调用remove()方法。 代码示例：(删除指定元素) 123456789101112131415161718192021222324252627import java.util.LinkedList;import java.util.Iterator;public class Test&#123; public static void main(String[] args) &#123; LinkedList&lt;String&gt; link=new LinkedList&lt;String&gt;(); link.add(&quot;1&quot;); link.add(&quot;2&quot;); link.add(&quot;3&quot;); link.add(&quot;A&quot;); link.add(&quot;B&quot;); link.add(&quot;C&quot;); Iterator&lt;String&gt; it=link.iterator(); while(it.hasNext()) &#123; String strIt=it.next(); //取得元素 if(strIt.equals(&quot;3&quot;)||strIt.equals(&quot;B&quot;)) //判断是否为指定元素 &#123; it.remove(); &#125;else &#123; System.out.print(strIt+&quot; &quot;); &#125; &#125; &#125;&#125; 运行结果： 11 2 A C ​ 从程序的运行结果可以发现。集合已经删除了元素“3”和“B&quot;。以上程序只是部分删除元素，若想将集合中的元素都删除，可以使用集合类的removeAll()方法或修改为如下范例。 代码示例：(删除所有元素) 1234567891011121314151617181920212223import java.util.LinkedList;import java.util.Iterator;public class Test&#123; public static void main(String[] args) &#123; LinkedList&lt;String&gt; link=new LinkedList&lt;String&gt;(); link.add(&quot;1&quot;); link.add(&quot;2&quot;); link.add(&quot;3&quot;); link.add(&quot;A&quot;); link.add(&quot;B&quot;); link.add(&quot;C&quot;); System.out.println(&quot;元素数目：&quot;+link.size()); Iterator&lt;String&gt; it=link.iterator(); while(it.hasNext()) &#123; it.next(); it.remove(); &#125; System.out.println(&quot;元素数目：&quot;+link.size()); &#125;&#125; 运行结果： 12元素数目：6元素数目：0 ​ 从程序运行结果可以发现，集合中的元素个数变为0，说明所有的元素已被删除。需要注意的是，在调用remove()飞前需要使用next()方法指定要删除的元素，否则运行时将尝试llegalStateException异常。 foreach遍历 ​ 在JDK1.5以后，可以使用更加简便的方式输出集合中的元素。那就是前面使用过的foreach循环，其语法格式如下： 1234for(类型 临时遍历:集合)&#123; //循环体&#125; 代码示例：(输出集合中的所有元素) 12345678910111213141516171819import java.util.LinkedList;import java.util.Iterator;public class Test&#123; public static void main(String[] args) &#123; LinkedList&lt;String&gt; link=new LinkedList&lt;String&gt;(); link.add(&quot;1&quot;); link.add(&quot;2&quot;); link.add(&quot;3&quot;); link.add(&quot;A&quot;); link.add(&quot;B&quot;); link.add(&quot;C&quot;); for(String str:link) &#123; System.out.print(str+&quot; &quot;); &#125; &#125;&#125; 运行结果： 11 2 3 A B C ​ 可以看出使用foreach可以简便地输出集合中的所有元素，foreach循环虽然书写起来很简洁，但在使用时也存在一定的局限性。当使用foreach循环遍历集合和数组时，只能访问集合中的元素，不能对其中的元素进行修改，所以建议在程序设计中使用Iterator输出集合的元素 参考书目： 《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com) 《Java基础入门 第2版 黑马程序员 经典Java入门教材书籍》【摘要 书评 试读】- 京东图书 (jd.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Set接口","slug":"java/集合与泛型/Set接口","date":"2021-08-16T00:21:54.000Z","updated":"2021-10-27T04:45:54.400Z","comments":true,"path":"2021/08/16/java/集合与泛型/Set接口/","link":"","permalink":"https://silenthly.github.io/2021/08/16/java/%E9%9B%86%E5%90%88%E4%B8%8E%E6%B3%9B%E5%9E%8B/Set%E6%8E%A5%E5%8F%A3/","excerpt":"​ Set是一个不包含重复元素的Collection，Set运行包含null元素，但同一个Set集合只允许含有一个null元素，也就是说Set集合不能包含重复的元素。本文将介绍Set接口与它的两个实现类HashSet和TreeSet。","text":"​ Set是一个不包含重复元素的Collection，Set运行包含null元素，但同一个Set集合只允许含有一个null元素，也就是说Set集合不能包含重复的元素。本文将介绍Set接口与它的两个实现类HashSet和TreeSet。 认识Set接口 ​ set集合中的对象不按特定的方式排序，只是简单地把对象加入集合中。但Set集合中不允许包含重复的元素。Set构造方法有一个约束条件，传入Collection参数不能包含有相同的元素。所以在操作时，必须小心可变对象，若Set集合中的可变元素改变了自身状态，则会出现一些问题。 Set接口的定义： 1public interface Set&lt;E&gt; extends Collection&lt;E&gt; ​ 可以看出Set接口与List接口没有多大的区别，而Set接口也没有对Collection接口进行扩充。但Set接口比Collection接口有更严格的约束条件——不允许重复的元素，Set接口的实例也不能像List接口的实例一样拥有双向输出，也没有get(int index)方法。 ​ Set接口的常用实现类有HashSet和TreeSet类。HashSet类可以快速定位一个元素，但是放到HashSet集合中的元素需要重写equals()和hashCode()方法。而TreeSet集合将放进其中的元素按序存放。 散列集：HashSet类 ​ HashSet类是按照哈希算法来存取集合中的元素的，使用哈希算法可以提高存取的效率。当向HashSet集合中添加元素时，就会调用该元素的hashCode()方法，获取其哈希码值，然后根据这个哈希码值计算出该元素的存放位置。HashSet集合具有以下特点： 不能保证元素的排列顺序，集合中元素的顺序随时有可能发生改变。 集合中最多运行存在一个null元素。 HashSet集合不是线程同步的。 代码示例：(不重写equals()和hashCode()) 12345678910111213141516171819202122232425262728293031import java.util.Set;import java.util.HashSet;class Person&#123; private String name; private int age; public Person()&#123;&#125; public Person(String name,int age) &#123; this.name=name; this.age=age; &#125; public String toString() &#123; return (&quot;姓名：&quot;+name+&quot;，年龄：&quot;+age+&quot;\\n&quot;); &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; Set&lt;Person&gt; set=new HashSet&lt;Person&gt;(); set.add(new Person(&quot;小强&quot;,18)); set.add(new Person(&quot;小强&quot;,19)); set.add(new Person(&quot;小强&quot;,18)); set.add(new Person(&quot;小强&quot;,18)); set.add(new Person(&quot;小强&quot;,20)); set.add(new Person(&quot;小强&quot;,20)); System.out.println(set); &#125;&#125; 运行结果： 1234567[姓名：小强，年龄：18, 姓名：小强，年龄：20, 姓名：小强，年龄：20, 姓名：小强，年龄：18, 姓名：小强，年龄：19, 姓名：小强，年龄：18] ​ 从程序结果可以发现，HashSet 集合存在着3个new Person(“小强”,18)，这 与前面讲的Set 集合不允许存在两个相同的元素相违背。之所以出现这样的情况，是因为这3个new Person(“小强”,18)时不在同一个内存地址的对象。使用Person类中默认的equals()比较的结果是false，所以HashSet集合认为它们是不同的元素。 代码示例：(重写equals()和hashCode()) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import java.util.Set;import java.util.HashSet;class Person&#123; private String name; private int age; public Person()&#123;&#125; public Person(String name,int age) &#123; this.name=name; this.age=age; &#125; public boolean equals(Object o) //重写equals()方法 &#123; if(this==o) return true; if(this==null) return false; if(!(o instanceof Person)) //判断指定对象是否为Person实例 return false; Person per=(Person)o; //将指定对象转换为Person实例 if(this.name.equals(per.name)&amp;&amp;this.age==per.age) //比较对象属性 &#123; return true; &#125;else &#123; return false; &#125; &#125; public int hashCode() //重写hashCode()方法 &#123; final int prime=13; int result=13; result=prime*result+((name==null)?0:name.hashCode()); result=prime*result+age; return result; &#125; public String toString() &#123; return (&quot;姓名：&quot;+name+&quot;，年龄：&quot;+age+&quot;\\n&quot;); &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; Set&lt;Person&gt; set=new HashSet&lt;Person&gt;(); set.add(new Person(&quot;小强&quot;,18)); set.add(new Person(&quot;小强&quot;,19)); set.add(new Person(&quot;小强&quot;,18)); set.add(new Person(&quot;小强&quot;,18)); set.add(new Person(&quot;小强&quot;,20)); set.add(new Person(&quot;小强&quot;,20)); System.out.println(set); &#125;&#125; 运行结果： 1234[姓名：小强，年龄：19, 姓名：小强，年龄：18, 姓名：小强，年龄：20] ​ 从上面的运行结果可以发现，集合中重复的元素已经没有了，说明重写equals()和hashCode()方法后可以可以传入重复元素，但重复元素不能进入集合，还有就是输出的顺序与添加顺序是无关的。 树集：TreeSet类 TreeSet类的定义格式： 1public class TreeSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements Iterator&lt;E&gt;,Collection&lt;E&gt;,NavigableSet&lt;E&gt;,Set&lt;E&gt;,SortedSet&lt;E&gt;,Cloneable,Serializable ​ TreeSet类实现了java.util包中的Set接口和SortSet接口。TreeSet集合中的元素在默认情况下是升序排序(自然排序)。若想自定义自己的排序方式，可以使用TreeSet类的构造方法TreeSet(Comparator comparator)。TreeSet类的常用方法如下表所示。 序号 方法 类型 说明 1 public TreeSet() 构造 构造一个新的TreeSet实例，该集合的元素自然排序 2 public TreeSet(Comparator&lt;? super E&gt; comparator) 构造 构造一个新的TreeSet实例，并根据指定的comparator进行排序 3 public E ceiling(E e) 普通 获取此集合中大于或等于给定元素的最小元素，若不存在，则返回null 4 public Comparator&lt;? super E&gt; comparator() 普通 返回此集合使用的比较器，若此集合的元素升序排序，则返回null 5 public terator&lt;E&gt; descendingIterator() 普通 返回此集合的 Iterator 实例，并按降序进行 遍历输出所有元素 6 public E first() 普通 返回此集合中当前第一个(最小的)元素 7 public E floor(E e) 普通 返回此集合中小于等于给定元素的最大值，若不存在，则返回null 8 public SortedSet&lt;E&gt; headSet(E toElement) 普通 返回此集合中比toElement小的所有元素集合 9 public boolean isEmpty() 普通 判断此集合是否为空，若为空，则返回true，否则返回false 10 public Iterator&lt;E&gt; iterator() 普通 返回此集合中的Iterator实例 11 public E last() 普通 返回此集合中当前的最后一个（最高）元素 12 public E lower(E e) 普通 返回此集合中小于给定元素的最大元素，若不存在，则返回null 13 public E pollFirst() 普通 获取并删除第一个(最小的)元素，如果集合为空，则返回null 14 public E pollLast() 普通 获取并删除最后一个(最大的)元素，如果集合为空，则返回null 15 public SotredSet&lt;E&gt; subSet(E fromElement,E toElement) 普通 返回一个新的集合，该新的集合包含原有集合从 fromElement(包括)到toElement(不包括)的元素 16 public SortedSet&lt;E&gt; tailSet(E fromElement) 普通 返回一个新的集合，该新的集合包含原有结合从fromElement(包括)之后的所有元素 17 public boolean add(E e) 普通 若元素 e 不在集合中，则将其添加进去 18 public void clear() 普通 清除此集合中的所有元素 19 public boolean addAll(Collection c) 普通 将指定集合 c 中的所有元素添加到此集合 中 20 public boolean contains(Object o) 普通 判断此集合是否包含指定的元素。若包含， 则返回 true，否则返回 false 21 public boolean remove(Object o) 普通 若指定的元素存在集合中，就将其删除 22 public int size() 普通 返回此集合中的元素数（set 的容量） ​ 更多其他方法可以前往API帮助文档查阅。下面通过几个范例来认识TreeSet集合的操作。 TreeSet集合的默认排序 代码示例：(验证TreeSet集合的默认排序) 1234567891011121314151617import java.util.Set;import java.util.TreeSet;public class Test&#123; public static void main(String[] args) &#123; Set&lt;Integer&gt; ts=new TreeSet&lt;Integer&gt;(); ts.add(1); ts.add(3); ts.add(5); ts.add(2); ts.add(6); ts.add(9); ts.add(1); System.out.println(ts); &#125;&#125; 运行结果： 1[1, 2, 3, 5, 6, 9] ​ 从程序的运行结果可以发现，TreeSet集合不允许添加重复元素，而且向TreeSet集合添加元素的顺序都是无序的，但输出的顺序是有序的，默认排序为升序排序。 自定义的类排序 代码示例： 12345678910111213141516171819202122232425262728293031import java.util.Set;import java.util.TreeSet;class Person&#123; private String name; private int age; public Person()&#123;&#125; public Person(String name,int age) &#123; this.name=name; this.age=age; &#125; public String toString() &#123; return (&quot;姓名：&quot;+name+&quot;，年龄：&quot;+age+&quot;\\n&quot;); &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; Set&lt;Person&gt; ts=new TreeSet&lt;Person&gt;(); ts.add(new Person(&quot;小强&quot;,18)); ts.add(new Person(&quot;小强&quot;,19)); ts.add(new Person(&quot;小强&quot;,18)); ts.add(new Person(&quot;小强&quot;,18)); ts.add(new Person(&quot;小强&quot;,20)); ts.add(new Person(&quot;小强&quot;,20)); System.out.println(ts); &#125;&#125; 运行结果： 12345Exception in thread &quot;main&quot; java.lang.ClassCastException: Person cannot be cast to java.lang.Comparable at java.util.TreeMap.compare(Unknown Source) at java.util.TreeMap.put(Unknown Source) at java.util.TreeSet.add(Unknown Source) at Test.main(Test.java:23) ​ 以上程序运行时，产生了ClassCastException(类转换异常)异常，这是因为TreeSet集合只能对实现了Comparable接口的类的对象进行排序。若想自定义的类创建多个对象可以添加到TreeSet集合中，就需要让该自定义类实现Comparable接口。若没有实现Comparable接口的类，只能向TreeSet集合添加一个对象。若添加更多的对象，将产生ClassCastException异常。 ​ 一个类实现Comparable接口则必须实现该接口中的int compareTo()方法，对前面的范例修改如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.Set;import java.util.TreeSet;class Person implements Comparable&lt;Person&gt; //实现Comparable接口&#123; private String name; private int age; public Person()&#123;&#125; public Person(String name,int age) &#123; this.name=name; this.age=age; &#125; public int compareTo(Person per) //重写Comparable接口的compareTo()方法 &#123; if(this.age&gt;per.age) //以年龄排序 &#123; return 1; &#125;else if(this.age&lt;per.age) &#123; return -1; &#125;else &#123; return this.name.compareTo(per.name); &#125; &#125; public String toString() &#123; return (&quot;姓名：&quot;+name+&quot;，年龄：&quot;+age+&quot;\\n&quot;); &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; Set&lt;Person&gt; ts=new TreeSet&lt;Person&gt;(); ts.add(new Person(&quot;小强&quot;,18)); ts.add(new Person(&quot;小天&quot;,19)); ts.add(new Person(&quot;小强&quot;,18)); ts.add(new Person(&quot;小强&quot;,18)); ts.add(new Person(&quot;小明&quot;,20)); ts.add(new Person(&quot;小红&quot;,20)); System.out.println(ts); &#125;&#125; 运行结果： 12345[姓名：小强，年龄：18, 姓名：小天，年龄：19, 姓名：小明，年龄：20, 姓名：小红，年龄：20] ​ 以上程序实现了自定义类的多个对象排序，并且结果中没有重复的元素。 参考书目： 《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"List接口","slug":"java/集合与泛型/List接口","date":"2021-08-14T23:09:15.000Z","updated":"2021-10-27T04:40:24.885Z","comments":true,"path":"2021/08/15/java/集合与泛型/List接口/","link":"","permalink":"https://silenthly.github.io/2021/08/15/java/%E9%9B%86%E5%90%88%E4%B8%8E%E6%B3%9B%E5%9E%8B/List%E6%8E%A5%E5%8F%A3/","excerpt":"​ List接口是一个有序集合，其元素以线性方式存储。集合中允许存放重复的元素。本文将介绍List接口的两个主要的实现类，ArrayList和LinkedList。","text":"​ List接口是一个有序集合，其元素以线性方式存储。集合中允许存放重复的元素。本文将介绍List接口的两个主要的实现类，ArrayList和LinkedList。 认识List接口 ​ List是有序的Collection，使用List接口可以精确地控制每个元素插入的位置，也可以通过索引来访问List中的元素，类似于数组。List接口的定义如下： 1public interface List&lt;E&gt; extends Collection&lt;E&gt; ​ List不但继承了Collection接口，还进行了扩展增加了更多方法，如下表所示。 序号 方法 类型 说明 1 public void add(int index,E element) 抽象 在集合的指定位置插入一个元素 2 public boolean addAll(int index,Collection&lt;? extends E&gt; c) 抽象 在集合的指定位置插入集合c的所有元素 3 public E get(int index) 抽象 返回此集合中指定位置的元素 4 public int indexOf(Object o) 抽象 返回此集合中首次出现指定元素的索引，如果集合不包含此元素，则返回-1 5 public int lastIndexOf(Object o) 抽象 返回此集合中最后出现指定元素的索引，如果集合不包含此元素，则返回-1 6 public ListIterator&lt;E&gt; listInterator() 抽象 为ListInterator接口实例化，用于遍历集合中的元素 7 public ListIterator&lt;E&gt; listInterator(int index) 抽象 为ListInterator接口实例化，用于遍历集合中的元素，并从集合的指定位置开始遍历 8 public E remove(int index) 抽象 删除集合中指定位置的元素 9 public E set(int index,E element) 抽象 替换指定位置的元素 10 public List&lt;E&gt; subList(int fromIndex,int toIndex) 抽象 返回一个新的元素新的集合中的包含fromIndex(包括)到toIndex(不包括)索引之间的所有元素。 注意：List允许存在相同的元素 数组列表类：ArrayList类 ​ 在java中，ArrayList类的定义如下： 1public class ArrayList&lt;E&gt; extends AbstactList&lt;E&gt; implements List&lt;E&gt;,RandomAccess,Cloneable,Seriablizable ​ 可以发现，ArrayList类实现List接口，可以通过ArrayList为List接口实例化。ArrayList类是数组列表类，实现了可变长度的数组，允许对集合中的元素进行快速的访问，但向ArrayList集合中插入或删除速度较慢（类似顺序表删除元素）。 ​ ArrayList集合允许所有的元素，包括null。每一个ArrayList实例都有一个默认的容量，即存储元素的个数，这个容量可以随着元素的增大而自动变大。ArrayList实例的容量算法没有定义。在添加大量元素前，可以使用ensureCapacity()操作来增加ArrayList实例的容量，这可以减少递增式再分配的数量。ArrayList类实现了List接口，这意味着它实现了List接口中的所有方法，但也增加了一些常用的方法，如下表所示。 序号 方法 类型 说明 1 public void ensureCapacity(int minCapacity) 普通 将ArrayList实例的容量扩大指定的容量 2 public void removeRange(int fromIndex,int toIndex) 普通 删除集合中索引在fromIndex(包括)和toIndex(不包括)之间所有元素 3 public void trimToSize() 普通 将此ArrayList实例的容量调整为集合的当前大小 4 public &lt;T&gt; toArray(T[] a) 普通 返回包含此列表中所有元素的数组，返回数组的运行类型是指数组的运行时类型 向集合添加元素 ​ 在Collection接口中就已定义了向集合添加元素的两个方法，add()和addAll()，在List接口增加可以向指定位置添加元素的add()和addAll()方法 代码示例1：(向集合添加元素) 12345678910111213141516171819import java.util.Collection;import java.util.List;import java.util.ArrayList;public class Test&#123; public static void main(String[] args) &#123; Collection&lt;String&gt; collect=new ArrayList&lt;String&gt;(); //通过ArrayList实例化Collection List&lt;String&gt; list=new ArrayList&lt;String&gt;(); //通过ArrayList实例化List collect.add(&quot;1&quot;); //向集合插入元素 collect.add(&quot;2&quot;); collect.add(&quot;3&quot;); System.out.println(&quot;collect集合：&quot;+collect); //打印集合中的元素 list.add(&quot;A&quot;); list.add(&quot;B&quot;); list.add(&quot;C&quot;); System.out.println(&quot;List集合：&quot;+list); //打印集合中的元素 &#125;&#125; 运行结果： 12collect集合：[1, 2, 3]List集合：[A, B, C] ​ 从程序的运行结果可以发现，add(E o)只是在集合最后进行内容的追加，而add(int Index,E element)可以指定添加位置。虽然System.out.println可以打印输出集合中所有的元素，但这不是标准的输出集合的方式。 删除集合中的元素 ​ ArrayList集合提供了专门用于删除元素的方法，Collection接口提供了remove()和removeAll()方法。在List接口中还提供了可以删除指定位置元素的方法remove(itn index)。 代码示例2：(删除元素) 123456789101112131415161718192021222324import java.util.Collection;import java.util.List;import java.util.ArrayList;public class Test&#123; public static void main(String[] args) &#123; Collection&lt;String&gt; collect=new ArrayList&lt;String&gt;(); //通过ArrayList实例化Collection List&lt;String&gt; list=new ArrayList&lt;String&gt;(); //通过ArrayList实例化List collect.add(&quot;1&quot;); collect.add(&quot;2&quot;); collect.add(&quot;3&quot;); System.out.println(&quot;collect集合：&quot;+collect); //打印集合中的元素 list.add(&quot;A&quot;); list.add(&quot;C&quot;); list.add(1,&quot;B&quot;); //向指定位置添加元素 list.addAll(0,collect); //向指定位置添加一个集合的所有元素 System.out.println(&quot;List集合删除前：&quot;+list); //打印集合中的元素 list.remove(&quot;B&quot;); list.remove(&quot;3&quot;); list.removeAll(collect); //删除list集合中所有collect集合中含有的元素 System.out.println(&quot;List集合删除后：&quot;+list); &#125;&#125; 运行结果： 123collect集合：[1, 2, 3]List集合删除前：[1, 2, 3, A, B, C]List集合删除后：[A, C] 集合的其他操作 ​ 在ArrayList集合中处理前面常用的添加元素和删除元素之外，还可以对集合进行其他的操作，如截取子集合、判断某个元素是否存在和将元素变为指定类型顶的数组等。 代码示例2：(集合的其他操作) 1234567891011121314151617181920212223242526272829303132333435import java.util.Collection;import java.util.List;import java.util.ArrayList;public class Test&#123; public static void main(String[] args) &#123; Collection&lt;String&gt; collect=new ArrayList&lt;String&gt;(); List&lt;String&gt; list=new ArrayList&lt;String&gt;(); collect.add(&quot;1&quot;); collect.add(&quot;2&quot;); collect.add(&quot;3&quot;); System.out.println(&quot;collect集合：&quot;+collect); list.add(&quot;A&quot;); list.add(&quot;C&quot;); list.add(1,&quot;B&quot;); list.addAll(0,collect); System.out.println(&quot;List集合：&quot;+list); //打印集合中的元素 List&lt;String&gt; sub=list.subList(1,5); //截取集合 System.out.println(&quot;sub集合：&quot;+sub); System.out.println(&quot;设置list集合元素前：&quot;+list.get(3)); list.set(3,&quot;Set&quot;); System.out.println(&quot;设置list集合元素后：&quot;+list.get(3)); System.out.println(&quot;list集合中，元素3的位置：&quot;+ list.indexOf(&quot;3&quot;)+&quot;，元素D的位置：&quot;+list.indexOf(&quot;D&quot;)); String arrString[]=list.toArray(new String[]&#123;&#125;); //将集合转为字符串数组 for(String str:arrString) &#123; System.out.print(str+&quot; &quot;); &#125; System.out.println(&quot;\\nlist集合是否为空：&quot;+list.isEmpty()); list.clear(); //清除集合中的所有元素 System.out.println(&quot;集合是否为空：&quot;+list.isEmpty()); &#125;&#125; 运行结果： 123456789collect集合：[1, 2, 3]List集合：[1, 2, 3, A, B, C]sub集合：[2, 3, A, B]设置list集合元素前：A设置list集合元素后：Setlist集合中，元素3的位置：2，元素D的位置：-11 2 3 Set B Clist集合是否为空：false集合是否为空：true ​ 在以上程序中，list.toArray(new String[]{})指定的是new String[]{}，而不是new String[]。若截取的子集合元素个数超出原集合的范围，如List subList=list.subList(1,7)，编译虽然可以通过，但是在运行时将产生 IndexOutOfBoundsException异常。 链表类：LinkedLIst类 ​ LinkedLIst是链表类，采用链表结果保存元素。链表结构的优点是便于向集合插入和删除元素。因为在插入或删除元素，不需要移动任何元素。在程序中，若经常需要向集合中插入或删除元素时，使用LinkedLIst实例化List接口是较好的选择。但若需要随机访问集合中的元素时，LinkedLIst集合就显得相对较慢了。 LinkedLIst类的定义： 1public class LinkedLIst&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;,Deque&lt;E&gt;,Queue&lt;E&gt;,Cloneable,Serializable ​ 从以上格式可以发现，LinkedLIst继承自了Queue接口、List接口和Deque接口，包含这三个接口的所有方法。List接口上面已经介绍过，下面分别介绍Queue接口和Deque接口。 队列：Queue接口 ​ Queue接口是java中实现队列的接口，它总共只有6个方法，我们·一般只用其中3个就可以了。Queue的实现类有LinkedList和PriorityQueue。Queue接口除了基本的Collection操作外，还提供的特有的插入、提取和检查操作。**每个方法都存在两种形式：一种抛出异常（操作失败时），另一种返回一个特殊值（null或false，具体取决于操作）。**插入操作后一种形式是用于专门为有容量的Queue实现设计的，在大多数实现中，插入操作不会失败。 序号 方法 类型 说明 1 public boolean add(E o) 抽象 若有足够的空间，则将指定的元素插入此队列，成功返回true ，否则抛出异常 2 public boolean offer(E o) 抽象 若有足够的空间，则将指定的元素插入此队列，成功返回true，否则返回false 3 public E remove() 抽象 删除并返回队列头部的元素，若队列为空，则抛出异常 4 public E poll() 抽象 删除并返回队列头部的元素，若队列为空，则返回null 5 public E element() 抽象 返回队列头部的元素，但不删除，若队列为空，则抛出异常 6 public E peek() 抽象 返回队列头部的元素，但不删除，若队列为空，则返回null ​ 队列通常（但并非一定）以 FIFO（先进先出）的方式排序各个元素。在FIFO队列中，所有的新元素都插入队列的末尾，调用 remove() 或 poll() 所移除的元素都是队列的头部。 ​ 如果可能，offer()方法可插入一个元素，否则返回 false。这与 Collection.add 方法不同，该方法只能通过抛出未经检查的异常使添加元素失败。offer 方法设计用于正常的失败情况，而不是出现异常的情况，例如在容量固定（有界）的队列中。 代码示例：(比较使用remobe()与poll()) 123456789101112import java.util.Queue;import java.util.LinkedList;public class Test&#123; public static void main(String[] args) &#123; Queue&lt;String&gt; q=new LinkedList&lt;String&gt;(); String str=q.poll(); System.out.println(str); q.remove(); &#125;&#125; 运行结果： 12345nullException in thread &quot;main&quot; java.util.NoSuchElementException at java.util.LinkedList.removeFirst(Unknown Source) at java.util.LinkedList.remove(Unknown Source) at Test.main(Test.java:10) ​ 以上程序，使用LinkedLIst类实例化一个Queue类型的空队列，由于队列为空，调用poll()方法返回null，而调用remove则抛出了NoSuchElementException异常。 双端队列：Deque接口 ​ Deque是一个双端队列接口，继承自Queue接口，Deque的实现类是LinkedList、ArrayDeque、LinkedBlockingDeque，其中LinkedList是最常用的。 Deque有三种用途： 普通队列（一端另一端出）： Queue queue = new LinkedList()或Deque deque = new LinkedList() 双端队列（两端都可以进出）： Deque deque = new LinkedList() 堆栈（进出在同一端） Deque deque = new LinkedList() 注意：Java堆栈Stack类已经过时，Java官方推荐使用Deque替代Stack使用。Deque堆栈操作方法：push()、pop()、peek()。 ​ Deque是一个线性collection，支持在两端插入和移除元素。名称 deque 是“double ended queue（双端队列）”的缩写。大多数 Deque 实现对于它们能够包含的元素数没有固定限制，但此接口既支持有容量限制的双端队列，也支持没有固定大小限制的双端队列。 ​ 此接口定义在双端队列访问元素的方法。提供插入、移除和检查元素的方法。每种方法都存在两种形式：一种形式在操作失败时抛出异常，另一种形式返回一个特殊值（null 或 false，具体取决于操作）。插入操作的后一种形式是专为使用有容量限制的 Deque 实现设计的，在大多数实现中，插入操作不能失败。 操作/对象 第一个元素(头部) 最后一个元素(尾部) 抛出异常 特殊值 抛出异常 特殊值 插入 addFirst(e) offerFirst(e) addLast(e) offerLast(e) 删除 removeFirst() pollFirst() removeLast() pollLast() 检查 getFirst() peekFirst() getLast() peekLast() ​ Deque接口扩展(继承)了Queue接口。在将双端队列用作队列时，Deque接口部分方法等效于Queue接口方法。如下表所示。 Queue方法 等效Deque方法 add(e) addLast(e) offer(e) offerLast(e) remove() removeFirst() poll() pollFirst() element() getFirst() peek() peekFirst() ​ 双端队列也可用作LIFO(先进先出)堆栈。应优先使用此接口而不是遗留Stack类。在将双端队列用作堆栈时，元素被推入双端队列的开头并从双端队列的开头弹出。Deque接口部分方法等效于Stack类方法。如下表所示。 堆栈方法 等效Deque方法 push(e) addFirst(e) pop() removeFirst() peek() peekFirst() LinkedList类新增方法 ​ LinkedList类是List接口、Queue接口与Deque接口的实现类，所以LinkedList类方法包含了这三个接口的所有方法，包括以上tack类的三个方法。所以可以通过LinkedList类实现堆栈、队列和双端队列。除此之外，LinkedList类还有一些新增方法，如下表所示。 序号 方法 类型 说明 1 public Iterator&lt;E&gt; descendingIterator() 普通 为listIterator接口实例化，用于遍历链表中的元素，顺序为从尾部到头部 6 public boolean remove(Object o) 普通 删除此链表中首次出现的指定元素 7 public boolean removeFirstOccurrence(Object o) 普通 从此链表中删除第一次出现的指定元素 8 public boolean removeLastOccurrence(Object o) 普通 从此链表中删除最后一次出现的指定元素 代码示例： 1234567891011121314151617181920212223import java.util.LinkedList;public class Test&#123; public static void main(String[] args)throws Exception &#123; LinkedList&lt;String&gt; link=new LinkedList&lt;String&gt;(); link.add(&quot;A&quot;); link.add(&quot;B&quot;); link.offer(&quot;C&quot;); link.offer(&quot;D&quot;); link.offer(&quot;B&quot;); System.out.println(&quot;链表中包含的元素：&quot;+link); System.out.println(&quot;链表中下标为2的元素为：&quot;+link.get(2)); System.out.println(&quot;首次出现元素B的下标为：&quot;+link.indexOf(&quot;B&quot;)); System.out.println(&quot;最后一次出现元素B的下标为：&quot;+link.lastIndexOf(&quot;B&quot;)); link.remove(3); System.out.println(&quot;删除下标3的元素后：&quot;+link); link.removeLastOccurrence(&quot;B&quot;); System.out.println(&quot;删除最后一次出现元素B：&quot;+link); link.set(0,&quot;H&quot;); System.out.println(&quot;将下标为0的元素替换为“H“：&quot;+link); &#125;&#125; 运行结果： 1234567链表中包含的元素：[A, B, C, D, B]链表中下标为2的元素为：C首次出现元素B的下标为：1最后一次出现元素B的下标为：4删除下标3的元素后：[A, B, C, B]删除最后一次出现元素B：[A, B, C]将下标为0的元素替换为“H“：[H, B, C] 参考链接： 【Java】Java队列Queue使用详解_devnn的专栏-CSDN博客_java队列queue使用场景 【Java】Java双端队列Deque使用详解_devnn的专栏-CSDN博客 参考书目： 《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"认识集合","slug":"java/集合与泛型/认识集合","date":"2021-08-12T00:32:42.000Z","updated":"2021-10-27T04:46:06.041Z","comments":true,"path":"2021/08/12/java/集合与泛型/认识集合/","link":"","permalink":"https://silenthly.github.io/2021/08/12/java/%E9%9B%86%E5%90%88%E4%B8%8E%E6%B3%9B%E5%9E%8B/%E8%AE%A4%E8%AF%86%E9%9B%86%E5%90%88/","excerpt":"​ 在JDK1.5之前，使用集合是一件相当麻烦的事。但在JDK1.5之后，java对集合进行了一系列的改进，极大地提高了集合的使用效率。这些改进主要体现在引进泛型技术、自动装箱与拆箱技术和foreach等技术的运用上。","text":"​ 在JDK1.5之前，使用集合是一件相当麻烦的事。但在JDK1.5之后，java对集合进行了一系列的改进，极大地提高了集合的使用效率。这些改进主要体现在引进泛型技术、自动装箱与拆箱技术和foreach等技术的运用上。 集合的基本概念 ​ java中的集合类是一种特别有用的工具类，所有的集合类都存放在java.util包中，所以使用集合类时需要导入该包。集合类主要负责保存、盛装和管理对象，因此集合又称为类集或容器。 ​ 数组是一种相同数据的集合，但在java语言里“集合”却是一个类，这两者有很多不同之处。比如，数组的长度是不可变的，而集合的长度是可变的。数组可以用来存储基本数据类型的数据，也可以存放引用数据类型的数据，而集合只能存放引用数据类型的数据，不能存放基本数据类型的数据。 ​ java中的集合类主要由两个派口派生，即Collection和Map。其中，Collection接口派生出了List集合和Set集合，各个接口还提供了不同的实现类。集合类的继承关系如下图所示 箭头表示接口间的继承关系。 Collection接口 ​ java.util.Collection是集合类的基本接口，它位于集合类的顶层。Collection接口的定义如下： 1public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; ​ 可以发现，Collection使用泛型技术，所以在操作时必须指定具体的操作类型，有利于集合的安全性。Collection是List接口和Set接口的父接口。Collection接口声明多个集合类的核心方法，如下表所示。 序号 方法 类型 说明 1 public boolean add(E o) 抽象 向集合插入一个元素 2 public boolean addAll(Collection&lt;? extends E&gt; c) 抽象 向集合添加一个集合c的所有元素 3 public void clear() 抽象 清除集合中所有的元素 4 public boolean contains(Object o) 抽象 判断集合中是否存在指定的元素。若存在，则返回true，否则返回false 5 public boolean containsAll(Collection&lt;?&gt; c) 抽象 判断集合中是否存在指定的集合c的所有元素。若存在，则返回true，否则返回false 6 public boolean equals(Object o) 抽象 比较两个集合是否相等 7 public int hashCode() 抽象 返回此Collection的哈希码值 8 public boolean isEmpty() 抽象 判断此集合是否为空。若为空，则返回true，否则返回false 9 public Iterator&lt;E&gt; iterator() 抽象 为Iterator接口实例化，用于遍历集合中的元素 10 public boolean remove(Object o) 抽象 从集合中删除指定的元素 11 public boolean removeAll(Collection&lt;?&gt; c) 抽象 从集合中删除指定集合c中出现的所有元素 12 public boolean retainAll() 抽象 保存集合中所有在集合c中出现的元素 13 public int size() 抽象 返回此集合中的元素个数 14 public Object[] toArray() 抽象 返回包含此元素中所有元素的对象数组 15 public &lt;T&gt; T[] toArray(T[] a) 抽象 返回包含此元素中所有元素的数组，并可以指定返回的数组类型 ​ 所有实现Collection接口的类都必须提供两个标准的构造方法，一个是无参构造法，用于创建一个空的Collection。一个是带有Collection参数的有参构造方法，用于创建一个新的Collection，而这个新的Collection与传入的Collection具有相同的元素，该构造方法允许用户复制一个Collection。 ​ 虽然Collection是集合类的基本接口，但是一般都不会直接使用Collection接口进行操作，而是使用其子接口。Collection接口的主要子接口有如下几个。 List&lt;E&gt;：集合中的元素按照索引值来排序，允许存放重复的元素。List集合与数组类似。 Queue&lt;E&gt;：队列接口，队列通常以FIFO(先进先出)的方式排序各个元素。 Set&lt;E&gt;：集合中的元素不按特定方式排序，不能存在重复对象，但它的有些实现类能对集合中的元素按照特定方式排序。 SortedSet&lt;E&gt;：可以对集合中的元素进行排序。 参考链接： Java集合之泛型类和泛型接口 - sun10367 - 博客园 (cnblogs.com) Java 集合和泛型 - 爆炸的果核 - 博客园 (cnblogs.com) 参考书目： 《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"泛型","slug":"java/集合与泛型/泛型","date":"2021-08-10T23:32:11.000Z","updated":"2021-10-27T04:45:07.858Z","comments":true,"path":"2021/08/11/java/集合与泛型/泛型/","link":"","permalink":"https://silenthly.github.io/2021/08/11/java/%E9%9B%86%E5%90%88%E4%B8%8E%E6%B3%9B%E5%9E%8B/%E6%B3%9B%E5%9E%8B/","excerpt":"为什么要使用泛型 ​ 泛型是配合集合使用的，当不使用泛型时，集合中是可以存放任意类型对象的，只要把对象存储集合后，那么他们都会被提升为Object类型。当我们在取出每一个对象，并且进行相应的操作，需要进行类型转换。","text":"为什么要使用泛型 ​ 泛型是配合集合使用的，当不使用泛型时，集合中是可以存放任意类型对象的，只要把对象存储集合后，那么他们都会被提升为Object类型。当我们在取出每一个对象，并且进行相应的操作，需要进行类型转换。 ​ 若集合没有使用泛型，什么类型的元素都可以存储，导致取出时强转引发运行时ClassCastException(类型转换异常)。Collection虽然可以存储各种类型对象，但一般只存储同一类型对象，例如都是字符串对象。因此在JDK5之后，新增了泛型(Generic)语法，让你在设计API时可以指定类或方法支持泛型，这样我们使用API的时候也变得更为简洁，并得到了编译时期的语法检查。下面通过一个范例来介绍为什么要使用泛型。 代码示例1：(类型转换) 12345678910111213141516171819202122232425class Generics&#123; private Object obj; public void setObj(Object obj) &#123; this.obj=obj; &#125; public Object getObj() &#123; return obj; &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; Generics gd=new Generics(); gd.setObj(new Integer(5)); //向上转型，设置obj Integer in=(Integer)gd.getObj(); //向下转型 System.out.println(&quot;设置的数值为：&quot;+in); gd.setObj(new Float(1.23f)); //向上转型，设置obj Float f=(Float)gd.getObj(); //向下转型 System.out.println(&quot;设置的数值为：&quot;+f); &#125;&#125; 运行结果： 12设置的数值为：5设置的数值为：1.23 ​ 在以上程序中，定义了Object类的属性obj，我们知道所有的类都是Object的子类，所以在setObj()方法中可以完成向上转型。向上转型是安全的，但是在向下转型时，通常容易出现问题，范例如下。 代码示例2：(错误的类型转换) 12345678910111213141516171819202122232425class Generics&#123; private Object obj; public void setObj(Object obj) &#123; this.obj=obj; &#125; public Object getObj() &#123; return obj; &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; Generics gd=new Generics(); gd.setObj(new Integer(5)); //向上转型，设置obj Integer in=(Integer)gd.getObj(); //向下转型 System.out.println(&quot;设置的数值为：&quot;+in); gd.setObj(&quot;1.23&quot;); //向上转型，设置obj Float f=(Float)gd.getObj(); //向下转型 System.out.println(&quot;设置的数值为：&quot;+f); &#125;&#125; ​ 运行结果： 123设置的数值为：5Exception in thread &quot;main&quot; java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Float at Test.main(Test.java:22) ​ 以上程序在编译时没有抛出任何异常，但在编译时产生了ClassCastException异常，这是一个类型转换异常。这是因为Object类型可以接收String类型，但是不能将其转换为Float类型，这就造成了类型安全问题。想要解决问题，可以使用泛型。 泛型应用 ​ 想要解决数据类型转换异常的常用方法，则需要使用泛型类增大java类型系统，甚至可以把泛型看做类型的”函数“。 泛型的基本应用 ​ Object类作为顶级的类，在程序中无论传入什么样的类型都可以被结束。但当要处理这些实例时，必须正确地将该实例转换为原类型，否则在运行时就会产生ClassCastException异常。其实java的泛型创建，是创建用类型作为参数的类，创建泛型类语法格式如下所示。 创建泛型类： 123456[public] class 类名&lt;泛型类型标识1...泛型类型标识n&gt;&#123; [访问控制符] 泛型类型标识 变量名; //定义属性 [访问控制符] 泛型类型标识 方法名()&#123;&#125; //定义方法 [访问控制符] 泛型类型标识 方法名(泛型类型标识 参数名)&#123;&#125; //定义方法&#125; ​ 其中，泛型类型标识只能是引用数据类型。泛型方法的返回值类型可以是泛型类型标识，也就是其他数据类型，如int、String、甚至是void。 ps：一般而言，类型的参数命名为单个大写字母，普遍的类型名称如下： E——元素 K——key N——数字 T——类型 V——value S，U，V——第二，第三，第四个类型 代码示例3：(声明泛型类) 123456789101112class Generics&lt;T&gt;&#123; private T obj; //创建引用对象 public void setObject(T obj) //设置obj属性 &#123; this.obj=obj; &#125; public T getObj() //获得obj属性 &#123; return obj; &#125;&#125; ​ 上面已经创建了泛型类，但是想要使用泛型类还需要创建泛型类的对象，其语法格式如下： 1类名&lt;泛型类型&gt; 对象名=new 类名&lt;泛型类型&gt;(); ​ 其中，类型为引用数据类型，不可为基本数据类型。 代码示例4：(使用泛型类) 1234567891011121314151617181920212223242526class Generics&lt;T&gt;&#123; private T obj; public void setObj(T obj) &#123; this.obj=obj; &#125; public T getObj() &#123; return obj; &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; Generics&lt;Integer&gt; gd1=new Generics&lt;Integer&gt;(); //创建泛型实例 gd1.setObj(new Integer(5)); Integer in=(Integer)gd1.getObj(); System.out.println(&quot;设置的数值为：&quot;+in); Generics&lt;Float&gt; gd2=new Generics&lt;Float&gt;(); //创建泛型实例 gd2.setObj(new Float(1.23f)); Float f=(Float)gd2.getObj(); System.out.println(&quot;设置的数值为：&quot;+f); &#125;&#125; 运行结果： 12设置的数值为：5设置的数值为：1.23 ​ 前面说过，泛型类型标识符不能为基本类型，但如果传入的是基本数据类型，那又会怎么样呢？ 代码示例5：(泛型类型标识为基本数据类型) 12345678910111213141516171819202122class Generics&lt;T&gt;&#123; private T obj; public void setObj(T obj) &#123; this.obj=obj; &#125; public T getObj() &#123; return obj; &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; Generics&lt;int&gt; gd1=new Generics&lt;int&gt;(); //创建泛型实例 gd1.setObj(new Integer(5)); Integer in=(Integer)gd1.getObj(); System.out.println(&quot;设置的数值为：&quot;+in); &#125;&#125; 运行结果： 1234567891011Test.java:17: 错误: 意外的类型 Generics&lt;int&gt; gd1=new Generics&lt;int&gt;(); //创建泛型实例 ^ 需要: 引用 找到: intTest.java:17: 错误: 意外的类型 Generics&lt;int&gt; gd1=new Generics&lt;int&gt;(); //创建泛型实例 ^ 需要: 引用 找到: int2 个错误 ​ 由此可见，在泛型中是无法指定基本数类的，但可以使用包装类将基本数据类型封装成一个类，再传入泛型中。而从JDK1.5以后增加了自动装箱的功能，操作上是不复杂的。 ​ 到目前为止，除了写法不同以外，没有看到泛型类与普通类的区别。下面我们设置内容与泛型所指不一致时，看看会出现说明情况。 代码示例:6：(设置内容与泛型所指的类型不一致) 1234567891011121314151617181920class Generics&lt;T&gt;&#123; private T obj; public void setObj(T obj) &#123; this.obj=obj; &#125; public T getObj() &#123; return obj; &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; Generics&lt;Integer&gt; gd1=new Generics&lt;Integer&gt;(); //创建泛型实例 gd1.setObj(&quot;5&quot;); &#125;&#125; 运行结果： 12345Test.java:18: 错误: 不兼容的类型: String无法转换为Integer gd1.setObj(&quot;5&quot;); ^注: 某些消息已经过简化; 请使用 -Xdiags:verbose 重新编译以获得完整输出1 个错误 ​ 将上面程序与示例2相比可以发现，示例2在编译时没有抛出任何异常，但在运行时产生了ClassCastException异常；而该程序在编译时就抛出了ClassCastException异常，这样就可以提高程序的安全性，不需要等到程序运行时发现异常错误，即可修改程序。 注意：不能直接使用参数类型来构造一个对象，如示例： 1234class Generics&lt;T&gt;&#123; T t=new T(); //错误&#125; ​ 在通常情况下，泛型类型参数所指定的对象是不会在泛型类中创建的，而是由外部传入的。若一定要在泛型类中创建泛型类型参数所指定的对象，可以通过反射机制中的Class.newInstance()方法。 泛型类的构造方法 ​ 泛型的构造方法与普通类的构造方法并无不同，不需要在构造设置内容时指定类型。 语法格式： 1234[访问控制符] 类名([泛型类型] 参数列表)&#123; //构造方法语句&#125; 代码示例：(定义泛型的构造方法) 1234567891011121314151617181920212223242526class Generics&lt;T&gt;&#123; private T obj; public Generics()&#123;&#125; public Generics(T obj) &#123; setObj(obj); &#125; public void setObj(T obj) &#123; this.obj=obj; &#125; public T getObj() &#123; return obj; &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; Generics&lt;Integer&gt; gd=new Generics&lt;Integer&gt;(5); int in=gd.getObj(); System.out.println(&quot;设置的数值为：&quot;+in); &#125;&#125; 代码示例： 1设置的数值为：5 ​ 从以上程序可以发现，泛型类只是在类的定义上声明，而与构造方法的定义无关。 定义泛型类时声明多个类型 ​ 在泛型中，可以声明多个泛型类型，只需要在这些类型之间用逗号（,）隔开。下面通过一个范例来演示定义泛型类时声明多个类型。 代码示例7：(设置两个泛型类型) 123456789101112131415161718192021222324252627282930313233343536373839class Generics&lt;T,S&gt;&#123; private T obj1; private S obj2; public Generics()&#123;&#125; public Generics(T obj1,S obj2) &#123; setObj1(obj1); setObj2(obj2); &#125; public void setObj1(T obj1) &#123; this.obj1=obj1; &#125; public T getObj1() &#123; return obj1; &#125; public void setObj2(S obj2) &#123; this.obj2=obj2; &#125; public S getObj2() &#123; return obj2; &#125; public void show() &#123; System.out.println(&quot;姓名：&quot;+getObj1()+&quot;，年龄：&quot;+getObj2()); &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; Generics&lt;String,Integer&gt; gd=new Generics&lt;String,Integer&gt;(&quot;小强&quot;,5); gd.show(); &#125;&#125; 运行结果： 1姓名：小强，年龄：5 ​ 以上程序中，泛型类型T和S可以是相同的类型，也可以是不同的类型，这是由外部指定的。 泛型的安全警告 ​ 在创建泛型的对象时，最好指定该对象的数据类型。如果不指定，就会出现不安全的警告信息。 代码示例8：(不指定泛型类型) 123456789101112131415161718192021class Generics&lt;T&gt;&#123; private T obj; public void setObj(T obj) &#123; this.obj=obj; &#125; public T getObj() &#123; return obj; &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; Generics gd=new Generics(); //创建泛型实例 gd.setObj(5); System.out.println(&quot;设置的数值为：&quot;+gd.getObj()); &#125;&#125; 运行结果： 12注: Test.java使用了未经检查或不安全的操作。注: 有关详细信息, 请使用 -Xlint:unchecked 重新编译。 ​ 以上程序在编译是出现警告信息，是因为在创建泛型类对象时没有为其指定类型。虽然出现了警告信息，但是不影响程序的运行。因为在没有指定类型时，系统就会默认以Object类型接收，也就是在定义时将泛型擦拭(删除)。 注意：在java中泛型类继承Throwable及其子类都是不合法的。并且java规定不能使用泛型类型的数组，如： 1Generics&lt;String&gt; genArr[]=new Generics&lt;String&gt;[10]; ​ 因为java代码代码编译时，会有擦拭处理，这时就会变为Object obj[]=genArr。这是一个Object类型的数组，试图向其插入其他类型的元素时，就会抛出ArrayStoreException异常。 通配符 ​ 前面介绍的泛型知识虽已经可以解决很多实际问题，但还有一些特殊的问题需要解决。在前面泛型类操作时都设置了一个固定的类型，若要接收任意指定的泛型类型时，需要使用通配符。 无界通配符&quot;?&quot; ​ 前面的泛型类都是指定了参数的类型，但是很多时候我们并不指定要传入的是什么类型，这时可以使用无界通配符&quot;?&quot;。 代码示例9：(使用无界通配符&quot;?&quot;) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Generics&lt;T,S&gt;&#123; private T obj1; private S obj2; public Generics()&#123;&#125; public Generics(T obj1,S obj2) &#123; setObj1(obj1); setObj2(obj2); &#125; public void setObj1(T obj1) &#123; this.obj1=obj1; &#125; public T getObj1() &#123; return obj1; &#125; public void setObj2(S obj2) &#123; this.obj2=obj2; &#125; public S getObj2() &#123; return obj2; &#125; public void show() &#123; System.out.println(&quot;姓名：&quot;+getObj1()+&quot;，年龄：&quot;+getObj2()); &#125; public String toString() //重写toString()方法 &#123; return (&quot;姓名：&quot;+getObj1()+&quot;，年龄：&quot;+getObj2()); &#125;&#125;public class Test&#123; public static void fun(Generics&lt;?,?&gt; t) &#123; System.out.println(&quot;fun():&quot;+t); &#125; public static void main(String[] args) &#123; Generics&lt;?,?&gt; gd=new Generics&lt;String,Integer&gt;(&quot;小强&quot;,5); gd.show(); fun(gd); &#125;&#125; 运行结果： 12姓名：小强，年龄：5fun():姓名：小强，年龄：5 ​ 以上程序使用了无界通配符&quot;?&quot;，表示可以接收任意的泛型类型。但是有一点必须要注意，使用无界通配符&quot;?&quot;设置对象时，不能通过setter()方法设置被泛型指定的内容。 代码示例10： 123456789101112131415public class Test&#123; public static void fun(Generics&lt;?,?&gt; t) &#123; System.out.println(&quot;fun():&quot;+t); &#125; public static void main(String[] args) &#123; Generics&lt;?,?&gt; gd=new Generics&lt;String,Integer&gt;(); gd.setObj1(&quot;小强&quot;); gd.setObj2(5); gd.show(); fun(gd); &#125;&#125; 运行结果： 123456789101112Test.java:45: 错误: 不兼容的类型: String无法转换为CAP#1 gd.setObj1(&quot;小强&quot;); ^ 其中, CAP#1是新类型变量: CAP#1从?的捕获扩展ObjectTest.java:46: 错误: 不兼容的类型: int无法转换为CAP#1 gd.setObj2(5); ^ 其中, CAP#1是新类型变量: CAP#1从?的捕获扩展Object注: 某些消息已经过简化; 请使用 -Xdiags:verbose 重新编译以获得完整输出2 个错误 受限泛型——泛型上限 ​ 在使用泛型类创建泛型对象，类型参数只能为某个接口（包含某个接口的实现类）或某种类型（包括某种类型的子类）时，可以设置类型形参的上限来实现，即使用关键字extends对接口和类的类型进行限制。设置类型形参的上限语法格式如下。 格式：(设置类型形参的上限) 1&lt;泛型类型标识 extends 泛型类型1 &amp; 泛型类型2...&gt; ​ 其中，在设置类型形参的上限时，无论使用的是类还是接口作为类型的形参的上限都是使用extends关键字进行限制。一个类型参数可以用多个限界类型。限界类之间用&quot;&amp;&quot;分隔开，因为逗号（,）是用来分隔类型参数的。需要注意的是，在多个限界类型中，可以用多个接口，但只能有一个类，如果类作为限界类型，则必须放在限界列表中的第一个。 代码示例11：(设置类型通配符的上限) 12345678910111213141516171819202122232425262728293031323334class Generics&lt;T extends Number&gt;&#123; private T obj; public void setObj(T obj) &#123; this.obj=obj; &#125; public T getObj() &#123; return obj; &#125; public void show(Generics&lt;?&gt; t) &#123; System.out.println(&quot;show()：&quot;+getObj()); &#125;&#125;public class Test&#123; public static void info(Generics&lt;? extends Number&gt; t) &#123; System.out.println(&quot;info()：&quot;+t.getObj()); &#125; public static void main(String[] args) &#123; Generics&lt;Integer&gt; gd1=new Generics&lt;Integer&gt;(); //创建泛型实例 gd1.setObj(5); gd1.show(gd1); info(gd1); Generics&lt;Double&gt; gd2=new Generics&lt;Double&gt;(); //创建泛型实例 gd2.setObj(1.234); gd2.show(gd2); info(gd2); &#125;&#125; 运行结果： 1234show()：5info()：5show()：1.234info()：1.234 ​ 以上程序中，gd1是Generics&lt;Integer&gt;类型，gd2是Generics&lt;Double&gt;类型。由于实际类型不同，所以使用的是： 1public void show(Generics&lt;?&gt; t) ​ 它表示t可以为任意Generics类型。因为Generics类定义为： 1class Generics&lt;T extends Number&gt; ​ 所以Generics类的对象只能是Number类的泛型对象或其子类的泛型对象。info()方法定义也为： 1public static void info(Generics&lt;? extends Number&gt; t) ​ info()方法也只能结束Number类的发现对象或其子类的泛型对象，但不能如下定义： 1public static void info(Generics&lt;T extends Number&gt; t) ​ 因为泛型类型T的作用域不在Test类中。 ​ 若传入的是String类的泛型对象，则编译时会出现错误。因为该泛型类型的上限为Number类。 代码示例12： 1234567891011121314public class Test&#123; public static void info(Generics&lt;? extends Number&gt; t) &#123; System.out.println(&quot;info()：&quot;+t.getObj()); &#125; public static void main(String[] args) &#123; Generics&lt;String&gt; gd1=new Generics&lt;String&gt;(); //创建泛型实例 gd1.setObj(&quot;5&quot;); gd1.show(gd1); info(gd1); &#125;&#125; 运行结果： 123456789101112131415Test.java:25: 错误: 类型参数String不在类型变量T的范围内 Generics&lt;String&gt; gd1=new Generics&lt;String&gt;(); //创建泛型实例 ^ 其中, T是类型变量: T扩展已在类 Generics中声明的NumberTest.java:25: 错误: 类型参数String不在类型变量T的范围内 Generics&lt;String&gt; gd1=new Generics&lt;String&gt;(); //创建泛型实例 ^ 其中, T是类型变量: T扩展已在类 Generics中声明的NumberTest.java:28: 错误: 不兼容的类型: Generics&lt;String&gt;无法转换为Generics&lt;? extends Number&gt; info(gd1); ^注: 某些消息已经过简化; 请使用 -Xdiags:verbose 重新编译以获得完整输出3 个错误 注意：不可将类声明为： 1class Generics&lt;? extends Number&gt; ​ 因为通配符是用来声明一个泛型类的变量的，而不是用来创建一个泛型类的。 受限泛型——泛型下限 ​ 在java泛型机制汇总，除了可以限制泛型类型的上限之外，还可以限制泛型类型的下限，使其只能是某种类型或该类型的父类，只需使用super关键字就可以设置泛型类型通配符下限，其语法格式如下。 格式：(设置泛型下限) 1&lt;? super 泛型类型&gt; 代码实例13：(设置泛型类型通配符的下限) 123456789101112131415161718192021222324252627282930313233class Generics&lt;T&gt;&#123; private T obj; public Generics()&#123;&#125; public Generics(T obj) &#123; setObj(obj); &#125; public void setObj(T obj) &#123; this.obj=obj; &#125; public T getObj() &#123; return obj; &#125; public String toString() //重写toString()方法 &#123; return getObj().toString(); &#125;&#125;public class Test&#123; public static void fun(Generics&lt;? super Integer&gt; t) &#123; System.out.println(&quot;fun():&quot;+t); &#125; public static void main(String[] args) &#123; Generics&lt;Integer&gt; gd=new Generics&lt;Integer&gt;(123); fun(gd); &#125;&#125; 运行结果： 1fun():123 ​ 以上程序中，fun()方法只能接收的泛型类型是Integer、Number和Object类型的引用。除了这些类型，传入其他类型时，在编译时将会报错。 注意：在java的泛型里，对于static方法而言，是无法访问泛型类的类型参数的。因此，如果想让static方法具有泛型能力，就必须使其成为泛型方法。 泛型与子类继承的限制 ​ 与普通类一样，泛型也可以作为父类或子类。普通类的继承规则包括成员的隐藏、重载和访问限制等，同样也适用于泛型类之间的继承。 以泛型为父类 ​ 当一个类的父类是泛型类时，该类也必定是泛型类，因为子类要将类型参数传递给父类。 代码示例14：(继承泛型类) 12345678910111213141516171819202122232425262728293031323334class Generics&lt;T&gt;&#123; private T obj; public Generics()&#123;&#125; public Generics(T obj) &#123; setObj(obj); &#125; public void setObj(T obj) &#123; this.obj=obj; &#125; public T getObj() &#123; return obj; &#125;&#125;public class Test&lt;T&gt; extends Generics&lt;T&gt;&#123; public Test()&#123;&#125; public Test(T obj) &#123; super(obj); &#125; public String toString() //重写toString()方法 &#123; return getObj().toString(); &#125; public static void main(String[] args) &#123; Test&lt;String&gt; p=new Test&lt;String&gt;(&quot;小强&quot;); System.out.println(&quot;对象内容：&quot;+p); &#125;&#125; 运行结果： 1对象内容：小强 ​ 在上面程序中，子类Test类的泛型标标识也为T，这意味着传递给子类Test的实际类型也会传递给父类Generics。除此之外，子类还可以根据自身的需求增加泛型类型。如下范例。 代码示例15：(子类自身的需求增加泛型类型) 123456789101112131415161718192021222324252627public class Test&lt;T,S&gt; extends Generics&lt;T&gt;&#123; private S sub; public Test()&#123;&#125; public Test(T obj,S sub) &#123; super(obj); setSub(sub); &#125; public void setSub(S sub) &#123; this.sub=sub; &#125; public S getSub() &#123; return sub; &#125; public String toString() &#123; return (&quot;姓名：&quot;+getObj()+&quot;，年龄：&quot;+getSub()); &#125; public static void main(String[] args) &#123; Test&lt;String,Integer&gt; p=new Test&lt;String,Integer&gt;(&quot;小强&quot;,18); System.out.println(&quot;对象内容：&quot;+p); &#125;&#125; 运行结果： 1对象内容：姓名：小强，年龄：18 以非泛型类为父类 ​ 泛型类可以以泛型类做父类，这时不再需要传递参数给父类，所有的类型参数都是为自己准备的。 代码示例16：(泛型类继承普通类) 12345678910111213141516171819202122232425262728class Generics&#123;&#125;public class Test&lt;T&gt; extends Generics&#123; private T obj; public Test()&#123;&#125; public Test(T obj) &#123; setObj(obj); &#125; public void setObj(T obj) &#123; this.obj=obj; &#125; public T getObj() &#123; return obj; &#125; public String toString() //重写toString()方法 &#123; return getObj().toString(); &#125; public static void main(String[] args) &#123; Test&lt;String&gt; p=new Test&lt;String&gt;(&quot;小强&quot;); System.out.println(&quot;对象内容：&quot;+p); &#125;&#125; 运行结果： 1对象内容：小强 ​ 可以发现，泛型类和非泛型类在继承时的主要差别是：泛型类的子类必须将泛型父类所需要的类型参数沿着继承链向上传递。 泛型接口 ​ 在java中，不但可以定义泛型类，还可以定义泛型接口。泛型接口的定义与泛型类的定义是相似的，只需在接口名称后加上类型参数标识，其语法格式如下： 格式：(定义泛型接口) 123[访问控制符] interface 接口名称&lt;泛型类型标识&gt;&#123; //接口代码&#125; 代码示例17：(在子类后声明泛型的方式来实现泛型接口) 123456789101112131415161718192021222324252627282930313233interface InterGenerics&lt;T&gt;&#123; public T show();&#125;class Generics&lt;T&gt; implements InterGenerics&lt;T&gt;&#123; private T obj; public Generics()&#123;&#125; public Generics(T obj) &#123; setObj(obj); &#125; public void setObj(T obj) &#123; this.obj=obj; &#125; public T getObj() &#123; return obj; &#125; public T show() &#123; return getObj(); &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; Generics&lt;Integer&gt; g=new Generics&lt;Integer&gt;(45); System.out.println(&quot;对象内容：&quot;+g.show()); &#125;&#125; 运行结果： 1对象内容：45 ​ 从上面程序可以看出，实现类Generics的类型参数与泛型接口的参数是一致的。 如果泛型接口声明为： 1interface InterGenerics&lt;T extends Serializable&gt; 则实现类Generics必须声明为如下所示： 1class Generics&lt;T extends Serializable&gt; implements InterGenerics&lt;T&gt; 若实现类Generics声明为以下格式是无法编译通过的： 1class Generics&lt;T extends Serializable&gt; implements InterGenerics&lt;T extends Serializable&gt; ​ 子类还可以在实现泛型接口时明确地给出泛型类型，范例如下。 代码示例18：(子类在实现泛型接口时明确地给出泛型类型) 123456789101112131415161718192021222324252627282930313233interface InterGenerics&lt;T&gt;&#123; public T show();&#125;class Generics implements InterGenerics&lt;Integer&gt; //给出泛型类型&#123; private Integer obj; public Generics()&#123;&#125; public Generics(Integer obj) &#123; setObj(obj); &#125; public void setObj(Integer obj) &#123; this.obj=obj; &#125; public Integer getObj() &#123; return obj; &#125; public Integer show() &#123; return getObj(); &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; Generics g=new Generics(87); System.out.println(&quot;对象内容：&quot;+g.show()); &#125;&#125; 运行结果： 1对象内容：87 ​ 在以上程序中，实现子类对象时，不需要再指定泛型类型，因为在声明子类时就已经指定了具体类型。 泛型方法 ​ 与普通的类和接口一样，除了的前面介绍定义泛型类和泛型接口外，还有一种泛型方法。泛型类在定义时需要在实例化时就指明类型，如果想换一种类型，不得不重新创建一次，不够灵活，而泛型方法可以在调用时指明类型。 定义泛型方法 ​ 一个方法若被声明为泛型方法，那么在泛型方法中可以定义泛型类型参数。与前面的泛型类和泛型接口不同的是，这些类型参数只能在它所修饰的泛型方法中使用。定义泛型方法的语法格式如下。 格式：(定义泛型方法) 1[访问控制符] [static|final] &lt;泛型类型标识&gt;返回值类型 方法名(&#123;泛型类型标识 参数名&#125;) 以上格式有几点需要注意： 泛型方法可以写在泛型类或泛型接口中，也可以写在普通类或普通接口中。在泛型类或泛型接口中的方法本质上都是泛型方法，但在实际中很少在泛型类或泛型接口中显式定义泛型方法。 泛型类型标识可以用在方法体内的局部变量，也可以用在方法中的参数列表中，作为形参使用。 泛型方法可以被定义成实例方法，也可以被定义为静态方法，这也是与泛型类中的泛型方法的主要区别。 代码示例19：(定义泛型方法) 1234567891011class Generics&#123; public &lt;T&gt; T show(T t) &#123; return t; &#125; public static &lt;T&gt; T staticShow(T t) &#123; return t; &#125;&#125; ​ 以上程序中定义了一个实例泛型方法和一个静态泛型方法，show()和staticShow()方法中使用了泛型操作，可以接收任意类型的数据，两者的返回值也是由泛型类型指定的。 使用泛型方法 ​ 使用泛型方法通常有以下两种格式。 格式一： 1[对象名.|类名.]方法名(实参列表); 格式二： 1[对象名.|类名.]&lt;实际泛型类型&gt;方法名(实参列表); 其中，需要注意的是： 若泛型方法是实例方法时，可以通过对象调用 若泛型方法是静态方法时，可以通过对象调用，也可以直接通过类名来调用 若是在类内部调用泛型方法，可以省略对象名和类名 代码示例20：(使用泛型方法) 12345678910111213141516171819202122class Generics&#123; public &lt;T&gt; T show(T t) &#123; return t; &#125; public static &lt;T&gt; T staticShow(String str,T t) &#123; return t; &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; Generics gen=new Generics(); System.out.println(&quot;姓名：&quot;+gen.show(&quot;小强&quot;)); System.out.println(&quot;年龄：&quot; +Generics.staticShow(&quot;小强&quot;,18)); System.out.println(&quot;姓名：&quot;+gen.&lt;String&gt;show(&quot;小明&quot;)); System.out.println(&quot;年龄：&quot; +Generics.&lt;Integer&gt;staticShow(&quot;小明&quot;,19)); &#125;&#125; 运行结果： 1234姓名：小强年龄：18姓名：小明年龄：19 ​ 在以上程序中，使用了两种形式调用泛型方法，格式一的形式显得更为简洁，在实际中使用最多的也是格式一的形式。但需要注意的是，在使用格式二的形式时，指定了具体的类型后，传入的类型要与其相符，若不相符，则会在编译时报错。如下所示。 1Generics.&lt;Integer&gt;staticShow(&quot;小伟&quot;,&quot;23&quot;); ​ 虽然使用格式一的形式比较方便。但在某些情况下，实参不能提供足够的类型信息给编译器时，就需使用格式二的形式。 参考链接： Java中的泛型类和泛型方法区别和联系 - 哼哼唧唧 - 博客园 (cnblogs.com) Java集合之泛型类和泛型接口 - sun10367 - 博客园 (cnblogs.com) 参考书目： 《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"格式化类：NumberFormat类","slug":"java/常用类库/格式化类：NumberFormat类","date":"2021-08-10T07:28:01.000Z","updated":"2021-10-27T04:46:17.926Z","comments":true,"path":"2021/08/10/java/常用类库/格式化类：NumberFormat类/","link":"","permalink":"https://silenthly.github.io/2021/08/10/java/%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%BA%93/%E6%A0%BC%E5%BC%8F%E5%8C%96%E7%B1%BB%EF%BC%9ANumberFormat%E7%B1%BB/","excerpt":"​ 数值是程序设计中经常要处理的数据，可以根据不同的需求，显示不同的样式或格式。在java中可以使用NumberFormat类实现。","text":"​ 数值是程序设计中经常要处理的数据，可以根据不同的需求，显示不同的样式或格式。在java中可以使用NumberFormat类实现。 ​ java.text.NumberFormat类是用于数字的格式化类，可以根据需求进行数字的格式显示。NumberFormat类的定义如下： 1public abstract class NumbrerFormat extends Format ​ 可以看出NumberFormat是抽象类，所以不能使用new关键字为其实例化，可以通过NumberFormat类的静态方法为其实例化。NumberFormat类的常用方法如下表所示： 序号 方法 类型 说明 1 public static Locale[] getAvailableLocales() 静态 返回所有语言环境的数组 2 public Currency getCurrency() 普通 获取格式化货币值时此数字格式使用的货币符号 3 pubclic static format(double number) 普通 规范格式 4 public static NumberFormat getCurrencyInstance() 静态 返回当前默认语言环境的货币格式符号 5 public static NumberFormat getCurrencyInstance(Locale inLocale) 静态 返回指定语言环境的货币格式符号 6 public static NumberFormat getInstance() 静态 返回当前默认语言环境的数字格式 7 public static NumberFormat getInstance(Locale inLocale) 静态 返回指定语言环境的数字格式 8 public static NumberFormat getIntegerInstance() 静态 返回当前默认语言环境的整数格式 9 public static NumberFormat getIntegerInstance(Locale inLocale) 静态 返回指定语言环境的整数格式 10 public static NumberFormat getNumberInstance() 静态 返回当前默认语言环境的通用数字格式 11 public static NumberFormat getNumberInstance(Locale inLocale) 静态 返回指定语言环境的通用数字格式 12 public static NumberFormat getPercentInstance() 静态 返回当前默认语言环境的百分比格式 13 public static NumberFormat getPercentInstance(Locale inLocale) 静态 返回指定语言环境的百分比格式 14 public Number parse(String source) 普通 将给定包含数字的字符串，解析为一个数字 15 public void setCurrency(Currency currency) 普通 获取格式化货币值时此数字格式使用的货币 ​ 一旦取得NumberFormat对象，就可以调用NumberFormat对象的format()方法来格式化数值。 代码示例： 1234567891011121314151617181920212223import java.text.NumberFormat;import java.util.Locale;public class Test&#123; public static void main(String[] args) &#123; System.out.println(&quot;———默认格式(中文)———&quot;); NumberFormat nf1=NumberFormat.getInstance(); //默认格式 System.out.println(nf1.format(1000000000)); //格式化数据 System.out.println(nf1.format(1234567.89)); System.out.println(&quot;———指定格式(德国)———&quot;); NumberFormat nf2=NumberFormat.getIntegerInstance(Locale.GERMAN); //整数格式(德国) System.out.println(nf2.format(1000000000)); //格式化数据 System.out.println(nf2.format(1234567.89)); System.out.println(&quot;———指定格式(美国)———&quot;); NumberFormat nf3=NumberFormat.getCurrencyInstance(Locale.US); //货币格式(美国) System.out.println(nf3.format(1000000000)); //格式化数据 System.out.println(nf3.format(1234567.89)); System.out.println(&quot;———默认格式(中文)———&quot;); NumberFormat nf4=NumberFormat.getPercentInstance(); //默认百分比格式 System.out.println(nf4.format(0.123)); //格式化数据 &#125;&#125; 运行结果： 1234567891011———默认格式(中文)———1,000,000,0001,234,567.89———指定格式(德国)———1.000.000.0001.234.568———指定格式(美国)———$1,000,000,000.00$1,234,567.89———默认格式(中文)———12% ​ 以上程序中，由于测试程序的操作系统是中文的，所以默认格式为中文格式。在指定不同的国家地区后，显示格式也发生了变化，表现出了国际化的作用。从程序的运行结果可以看出，中国是采用(,)作为数字分组分隔符的，而德 国是采用(.)作为数字分组分隔符。 知识扩展：DecimalFormat类 ​ DecimalFormat是NumberFormat的一个具体子类，用于格式化十进制数字，使用该类格式化数字要比直接NumberFormat更加方便。 ​ DecimalFormat类设计有各种功能，使其能够分析和格式化任意语言环境中的数，包括对西方语言、阿拉伯语和印度语数字的支持。它还支持不同类型的数，包括整数(123)、定点数(123.4)、科学记数法表示的数(1.23E4)、百分数(12%)和金额($123)，所有这些内容都可以本地化。 未完待续。。。。(有时间再补) 参考书目： 《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"随机数类：Random类","slug":"java/常用类库/随机数类：Random类","date":"2021-08-10T01:42:45.000Z","updated":"2021-10-27T04:46:24.172Z","comments":true,"path":"2021/08/10/java/常用类库/随机数类：Random类/","link":"","permalink":"https://silenthly.github.io/2021/08/10/java/%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%BA%93/%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%B1%BB%EF%BC%9ARandom%E7%B1%BB/","excerpt":"​ 在程序设计中，经常需要产生一些随机数值，如贪吃蛇中的食物出现位置。在java中除了可以使用Math类中的random()方法获得随机数，还可以使用Random类。 ​ Random类是在java.util包中，是专门用于提供生成一个随机数的类，随机数字的生成相关方法都包含在该类的内部。Random类可以指定一个随机数值范围，随机数均在这个范围内产生。Random类的常用方法如下表所示。","text":"​ 在程序设计中，经常需要产生一些随机数值，如贪吃蛇中的食物出现位置。在java中除了可以使用Math类中的random()方法获得随机数，还可以使用Random类。 ​ Random类是在java.util包中，是专门用于提供生成一个随机数的类，随机数字的生成相关方法都包含在该类的内部。Random类可以指定一个随机数值范围，随机数均在这个范围内产生。Random类的常用方法如下表所示。 注意：这里所谓的随机数并不完全是随机数，所谓随机数其实是伪随机数，所谓的‘伪’，意思是这些数其实是有规律的，只不过因为算法规律太复杂，很难看出来。 序号 方法 类型 说明 1 public Random() 构造 该构造方法使用一个与当前系统时间毫秒相对应的数字值作为种子数，然后使用这个种子数构造Random对象 2 public Random(long seed) 构造 该构造方法通过指定的数值作为种子数构造Random对象 3 protected int next(int bits) 普通 生成下一个随机数 4 public booleannextBoolean() 普通 生成一个boolean类型的随机数 5 public void nextBytes(byte[] bytes) 普通 生成随机字节并将其置于用户提供的字节数组中 6 public nextDouble() 普通 生成一个double类型的随机数，可更改为int，double，float，long类型 7 public double nextGaussian() 普通 生成一个高斯类型的随机数。是从此随机数生成器的序列中取出的、呈高斯分布double值，其平均值是0.0，标准差是1.0 8 public nextInt(int n) 普通 生成一个 int 类型的随机数，该值取值范围 0～n，包含 0 但不包含 n 9 public void setSeed(long seed) 普通 重新设置Random对象的种子数 10 public int nextInt() 普通 生成一个int类型的随机数，可更改为float，long类型 ​ 在进行随机时，生成伪随机数时需要指定的随机抽样起点，随机算法的抽样起点称为种子数(seed)。这个seed的选取是随意的，只要你设置的seed是一样的，就保证得到同样的一组随机模拟数据。若没有指定种子数，将使用系统时间对应的毫秒数作为种子。 生成指定区域内的随机数 12345678910111213141516import java.util.Random;public class Test&#123; public static void main(String[] args) &#123; Random rd=new Random(); System.out.println(&quot;生成0~1.0的随机小数：&quot;+rd.nextDouble()); System.out.println(&quot;生成0~10.0的随机小数：&quot;+rd.nextDouble()*10); System.out.println(&quot;生成5~15的随机整数：&quot;+(rd.nextInt(10)+5)); System.out.println(&quot;生成0~100的随机整数：&quot;); for(int i=0;i&lt;10;i++) &#123; System.out.print(rd.nextInt(100)+&quot; &quot;); &#125; &#125;&#125; 运行结果： 12345生成0~1.0的随机小数：0.11398530592772715生成0~10.0的随机小数：9.395734031963132生成5~15的随机整数：10生成0~100的随机整数：42 7 13 74 82 21 48 34 17 9 ​ 以上程序中，rd.nextDouble()生成的是一个0~1的随机小数。而rd.nextInt()则会生成的是-231～231-1 区域内的随机数。若想生成一个介于[0,n]区间的随机整数，则需要使用rd.nextInt(n)。 使用相同种子数生成随机数 12345678910111213141516171819import java.util.Random;public class Test&#123; public static void main(String[] args) &#123; Random r1=new Random(100); Random r2=new Random(100); System.out.println(&quot;种子数为100的Random对象：&quot;); for(int i=0;i&lt;10;i++) &#123; System.out.print(r1.nextInt(100)+&quot; &quot;); &#125; System.out.println(&quot;\\n种子数为100的Random对象：&quot;); for(int i=0;i&lt;10;i++) &#123; System.out.print(r2.nextInt(100)+&quot; &quot;); &#125; &#125;&#125; 运行结果： 1234种子数为100的Random对象：15 50 74 88 91 66 36 88 23 13种子数为100的Random对象：15 50 74 88 91 66 36 88 23 13 ​ 以上程序中，对象 r1 和 r2 均是通过指定种子数为 100 构造的，而这两个 对象在相同次数内生成的随机数是完全一样的。所以为了避免这样的情况，无论程序中需 要生成多少个随机数，都只使用一个 Random 对象。 参考链接： 关于随机种子seed()的一点理解_深蓝色的鬼的博客-CSDN博客 SAS中seed（种子）的数目是什么意思 - SAS专版 - 经管之家(原人大经济论坛) (pinggu.org) 参考书目： 《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"数学类：Math类","slug":"java/常用类库/数学类：Math类","date":"2021-08-09T13:41:12.000Z","updated":"2021-10-27T04:46:29.450Z","comments":true,"path":"2021/08/09/java/常用类库/数学类：Math类/","link":"","permalink":"https://silenthly.github.io/2021/08/09/java/%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%BA%93/%E6%95%B0%E5%AD%A6%E7%B1%BB%EF%BC%9AMath%E7%B1%BB/","excerpt":"​ 在前面，我们学习过java的基本运算符运算&quot;+&quot;、“-&quot;、“*”、“/&quot;、“%”等，但是对较为复杂的运算，如三角函数、指数函数和绝对值函数等运算时，基本运算符就显得力不从心了。为此，java提供了java.lang.Math类来完成这些复杂的运行。","text":"​ 在前面，我们学习过java的基本运算符运算&quot;+&quot;、“-&quot;、“*”、“/&quot;、“%”等，但是对较为复杂的运算，如三角函数、指数函数和绝对值函数等运算时，基本运算符就显得力不从心了。为此，java提供了java.lang.Math类来完成这些复杂的运行。 ​ Math类是数学操作类，提供一系列的数学运算方法，包括求绝对值、三角函数、指数函数和绝对值函数等。在Math类中提供的方法都是静态方法，既可以通过“类名.方法()”的形式调用，无需通过Math类的对象。Math类提供了功能不同的数学函数，下面将他们分类列出，如以下表格所示。 Math类的绝对值函数 序号 方法 类型 说明 1 public static double abs(double a) 静态 返回double值的绝对值，可更改为int、float、long型 Math类的最大值最小值函数 序号 方法 类型 说明 1 public static double max(double a,double b) 静态 返回两个double值中较大的一个，可更改为int、float、long型 2 public static double min(double a,double b) 静态 返回两个double值中较小的一个，可更改为int、float、long型 Math类的取整函数 序号 方法 类型 说明 1 public static double ceil(double a) 静态 向上取整 2 public static double floor(double) 静态 向下取整 3 public static double rint(double a) 静态 最接近a的整数值，如果有两个同样接近的整数，则结果取平均值 4 public static int round(int a) 静态 将a四舍五入，可更改为long型 Math类的三角函数 序号 方法 类型 说明 1 public static double sin(double a) 静态 返回叫的三角正弦 2 public static double asin(double a) 静态 返回叫的三角反正弦，范围为在-π/2～π/2 之间 3 public static double cos(double a) 静态 返回叫的三角余弦 4 public static double acos(double a) 静态 返回角的反余弦，范围在 0～π 之间 5 public static double tan(double a) 静态 返回叫的三角正切 6 public static double atan(double a) 静态 返回角的反正切，范围在-π/2～π/2 之间 7 public static double toDegress(double a) 静态 将用弧度测量的角转换为近似相等的用度数测量的角 8 public static double toRadians(double a) 静态 将用度数测量的角转换为近似相等的用弧度测量的角 Math类的幂与开发函数 序号 方法 类型 说明 1 public static double cbrt(double a) 静态 返回 a 的立方根 2 public static double exp(double a) 静态 返回欧拉数e的double次幂的值，ea 3 public static double expm1(double a) 静态 返回ex-1 4 public static double pow(double a，double b) 静态 返回a的b次幂的值，ab 5 public static double sqrt(double a) 静态 返回a值的正平方根，若 参数a是 NaN 或小于 0，那么结果是NaN Math类的对数函数 序号 方法 类型 说明 1 public static double log(double a) 静态 返回 lna 的值 2 public static double log10(double a) 静态 返回 log10a 的值 3 public static double log1p(double x) 静态 返回 ln(x+1) 的值 Math类的随机数 序号 方法 类型 说明 1 public static double random() 静态 返回带正号的double值，范围为0.0~1.0 Math类中常量 序号 方法 类型 说明 1 public static double E 常量 数学常量e 2 public static double PI 常量 圆周率π ​ 在进行各种数学运算的时候，时常会运用到这些函数。 代码示例： 12345678910111213public class Test&#123; public static void main(String[] args) &#123; System.out.println(&quot;绝对值函数：10.02=&quot;+Math.abs(10.02D)+&quot;，-10.02=&quot;+Math.abs(-10.02D)); System.out.println(&quot;最大值最小值(23,12)：最大值：&quot;+Math.max(23,12)+&quot;，最小值：&quot;+Math.min(23,12)); System.out.println(&quot;四舍五入：13.6=&quot;+Math.round(13.6)); System.out.println(&quot;三角函数：sin(30)=&quot;+Math.sin(30)+&quot;，cos(60)=&quot;+Math.cos(60)+&quot;，tan(45)=&quot;+Math.tan(45)); System.out.println(&quot;开方函数：16的开方=&quot;+Math.sqrt(16)+&quot;，8的立方根=&quot;+Math.cbrt(8)); System.out.println(&quot;对数函数：ln(10)=&quot;+Math.log(10)); System.out.println(&quot;随机数：范围为0~10=&quot;+Math.random()*10); &#125;&#125; 运行结果： 1234567绝对值函数：10.02=10.02，-10.02=10.02最大值最小值(23,12)：最大值：23，最小值：12四舍五入：13.6=14三角函数：sin(30)=-0.9880316240928618，cos(60)=-0.9524129804151563，tan(45)=1.6197751905438615开方函数：16的开方=4.0，8的立方根=2.0对数函数：ln(10)=2.302585092994046随机数：范围为0~10=1.5633001947083047 参考书目： 《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"日期操作类","slug":"java/常用类库/日期操作类","date":"2021-08-09T00:04:12.000Z","updated":"2021-10-27T04:46:35.001Z","comments":true,"path":"2021/08/09/java/常用类库/日期操作类/","link":"","permalink":"https://silenthly.github.io/2021/08/09/java/%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%BA%93/%E6%97%A5%E6%9C%9F%E6%93%8D%E4%BD%9C%E7%B1%BB/","excerpt":"​ 在程序开发中，经常会遇到日期类型的操作，日期处理是程序员必须具备的一种常用技能。在不同的程序设计语言中提供了不同的格式进行实现，在java中，对日期的处理提供了优秀的支持，主要用到了java.util包中的Date类、Calendar类，以及java.text包中的DateFormat类和SimpledataFormat类。下面将介绍讲解 Java 语言的时间和日期处理技术。","text":"​ 在程序开发中，经常会遇到日期类型的操作，日期处理是程序员必须具备的一种常用技能。在不同的程序设计语言中提供了不同的格式进行实现，在java中，对日期的处理提供了优秀的支持，主要用到了java.util包中的Date类、Calendar类，以及java.text包中的DateFormat类和SimpledataFormat类。下面将介绍讲解 Java 语言的时间和日期处理技术。 简单日期操作类：Date类 ​ java.util.Date类是一个简单的日期处理类。在JDK1.0时，Date类是唯一的一个代表时间的类，它包含了一些关于时间和日期操作的方法，可将日期分为年、月、日、时、分、秒。Date类的常用方法如下表所示。 序号 方法 类型 说明 1 public Date() 构造 生成一个Date对象，以表示分配它的时间(精确到毫秒)。该构造方法调用 Systems.currentTimeMillis()方法获取当前时间。即new Date() 等价于new Date(System.currentTimeMillis()) 2 public Date(long date) 构造 根据指定的 long 类型的值来生成一个Date对象，date表示自从标准基准时(也称历元，即1970年1月1日00:00:00GMT)以来的时间差，以 ms 为单位 3 public boolean after(Date when) 普通 测试此日期是否在指定日期之后 4 public boolean before(Date when) 普通 测试此日期是否在指定日期之前 5 public int compareTo(Date anotherDate) 普通 比较两个日期的顺序，若早，则返回-1，相等则返回0，若晚，则返回1 6 public boolean equals(Object obj) 普通 比较两个日期的相等性 7 public long getTime() 普通 返回自1970年1月1日00:00:00GMT到指定Date对象的时间插，以ms为单位 8 public setTime(long time) 普通 设置此Date对象，以表示1970年1月1日00:00:00GMT以后time毫秒的时间点 9 public String toString() 普通 把此Date对象转换为以下字符串形式表现：dow mon dd hh:mm:ss zzz yyyy 其中：dow 是一周中的某一天 (Sun，Mon，Tue，Wed，Thu，Fri，Sat) 代码示例： 123456789101112131415import java.util.Date;public class Test&#123; public static void main(String[] args) &#123; Date date1=new Date(); //获取当前时间 Date date2=new Date(System.currentTimeMillis()+123); //当前时间+123ms System.out.println(&quot;时间：&quot;+date1); System.out.println(&quot;时间差：&quot;+date2.getTime()+&quot;ms&quot;); System.out.println(&quot;date1与date2的比较：&quot;+date1.compareTo(date2)); System.out.println(&quot;date2与date1的比较：&quot;+date2.compareTo(date1)); System.out.println(&quot;date1是否比date2早&quot;+date1.before(date2)); System.out.println(&quot;date1是否比date2晚&quot;+date1.after(date2)); &#125;&#125; 运行结果： 123456时间：Mon Aug 09 08:33:27 CST 2021时间差：1628469207183msdate1与date2的比较：-1date2与date1的比较：1date1是否比date2早truedate1是否比date2晚false ​ Date类中的很多方法已经不被推进使用了，功能大减。而且Date类不便于实现国际化，所以从JDK1.1开始，推荐使用Calendar类进行时间和日期处理。 日期抽象类：Calendar类 ​ 由于前面的Date类在设计上存在一些缺陷，为此java语言提供了更好的Calendar类。java.util.Calendar类可以取得时间精确度达到ms级别。该类的定义如下： 1public abstract class Calender extends Object implements Serializable,Cloneable,Comparable&lt;Calendar&gt; ​ 可以发现Calendar类是抽象类，所以不能使用new关键字为其实例化。创建Calendar类的实例有两种方式： 1、通过Calendar的子类GregorianCalendar为其实例化。 2、通过Calendar类中的getInstance()方法。 ​ 通过Calendar的对象可以对日期时间进行一系列的处理，Calendar类的常用方法如下表所示。 序号 方法 类型 说明 1 public abstract void add(int field,int amount) 抽象 根据日历的规则，为给定的日历字段field添加或减去指定的时间量 2 public boolean after(Object when) 普通 判断此Calendar表示的时间是否在值得Object表示的时间之后，返回判断结果 3 public boolean before(Object when) 普通 判断此Calendar表示的时间是否在值得Object表示的时间之前，返回判断结果 4 public void clear() 普通 清空Calendar中的日期时间值 5 public int compareTo(Calendar anotherCalendar) 普通 比较两个Calendar对象表示的时间值(从历元至现在的毫秒偏移量)，若小，则返回-1，相等返回0，若大返回1 6 public int get(int field) 普通 返回给定日历字段的值 7 public int getActualMaximun(int field) 普通 给定此Calendar的时间值，返回指定日历字段可能具有的 Calenda最大值 8 public int getActualMinimum(int field) 普通 给定此Calendar的时间值，返回指定日历字段可能具有的 Calenda最小值 9 public static Locale[] getAvailableLocales() 静态 返回所有语言环境的数组，此类的getInstance()方法可以为其返回本地化的实例 10 public int getFirstDayOfWeek() 普通 获得一星期的第一天，根据不同的国家地区，返回不同的值。例如，在美国，这一天是Sunday，而在中国，这一天是Monday 11 public static Calendar getInstance() 静态 使用默认时区和默认语言环境获得一个日历 12 public static Calendar getInstance(Locale aLocale) 静态 使用默认时区和指定语言环境获得一个日历 13 public static Calendar getInstance(TimeZone zone) 静态 使用指定时区和默认语言环境获得一个日历 14 public static Calendar getInstance(TimeZone zone,Locale aLocale) 静态 使用指定时区和指定语言环境获得一个日历 15 public Date getTime() 普通 返回一个表示此Calendar时间值(从历元至现在的ms偏移量)的Date对象 16 public long getTimeMillis() 普通 返回指定Calendar的时间值，以ms为单位 17 public TimeZone getTimeZone() 普通 获得时区 18 public void set(int field,int value) 普通 将给定的日历字段设置为给定值 19 public void set(int year,int month,int date) 普通 设置日历字段 YEAR 、MONTH和DAY_OF_MONTH的值 20 public void set(int year,int month,int date,int hourOfDay,int minute) 普通 设置日历字段 YEAR 、MONTH、DAY_OF_MONTH、HOUR_OF_DAY和MINUTE的值 21 public void set(int year,int month,int date,int hourOfDay,int minute,int second) 普通 设置日历字段 YEAR 、MONTH、DAY_OF_MONTH、HOUR_OF_DAY、MINUTE和SECOND的值 22 public setFirstDayOfWeek(int value) 普通 设置一星期的第一天是哪一天，根据不同的国家地区，返回不同的值 23 public void setTime(Date date) 普通 使用给定的Date设置此Calendar的时间 24 public void setTimeInMillis(long millis) 普通 用给定的long值设置此Calendar的当前时间值 25 public void setTimeZone(TimeZone value) 普通 使用给定的时区值来设置时区 26 public String toString() 普通 返回此日历的字符串表示 ​ 在Calendar类中除了存在功能强大的方法之外，还有众多的常量，下表列出一些常用的常量，更多的常量可前往API帮助文档内查看。 序号 常量 说明 1 public static int DATE 表示一个月中的某天 2 public static int DAY_OF_MONTH 表示一个月中的某天 3 public static int DAY_OF_WEEK 表示一个星期中的某天 4 public static int DAY_OF_WEEK_IN_MONTH 表示当前月中的第几个星期 5 public static int DAY_OF_YEAR 表示当前年中的天数 6 public static int MINUTE 表示一小时中的分钟 7 public static int SECOND 表示一分钟中的秒 8 public static int MONTH 表示月份 9 public static int HOUR 表示上午或下午的小时 10 public static int HOUR_OF_DAY 表示一天中的小时 11 public static int WEEK_OF_MONTH 表示当前月中的星期数 12 public static int WEEK_OF_YEAR 表示当前年中的星期数 13 public static int YEAR 表示年份 代码示例： 123456789101112131415161718192021222324252627import java.util.Calendar;import java.util.GregorianCalendar;public class Test&#123; public static void main(String[] args) &#123; Calendar cal1=Calendar.getInstance(); Calendar cal2=new GregorianCalendar(); System.out.println(&quot;年份：&quot;+cal1.get(Calendar.YEAR)); System.out.println(&quot;月份：&quot;+(cal1.get(Calendar.MONTH)+1)); System.out.println(&quot;号数：&quot;+cal1.get(Calendar.DATE)); System.out.println(&quot;今年的第&quot;+cal1.get(Calendar.DAY_OF_YEAR)+&quot;天&quot;); System.out.println(&quot;本月的第&quot;+cal1.get(Calendar.DAY_OF_MONTH)+&quot;天&quot;); System.out.println(&quot;本月的第&quot;+cal1.get(Calendar.DAY_OF_WEEK_IN_MONTH)+&quot;周&quot;); System.out.println(&quot;星期&quot;+(cal1.get(Calendar.DAY_OF_WEEK)-1)); System.out.println(&quot;24小时制：&quot;+cal1.get(Calendar.HOUR_OF_DAY)); System.out.println(&quot;12小时制：&quot;+cal1.get(Calendar.HOUR)); System.out.println(&quot;分钟：&quot;+cal1.get(Calendar.MINUTE)); System.out.println(&quot;秒钟：&quot;+cal1.get(Calendar.SECOND)); System.out.println(&quot;毫秒：&quot;+cal1.get(Calendar.MILLISECOND)); System.out.println(&quot;日期：&quot;+cal1.getTime()); cal2.set(2022,1,1); //2022年的春节为2.1 long time=cal2.getTimeInMillis()-cal1.getTimeInMillis(); long day=time/(24*60*60*1000); System.out.println(&quot;今天距离2022的春节还有&quot;+day+&quot;天&quot;); &#125;&#125; 运行结果： 1234567891011121314年份：2021月份：8号数：9今年的第221天本月的第9天本月的第2周星期124小时制：1412小时制：2分钟：36秒钟：52毫秒：851日期：Mon Aug 09 14:36:52 CST 2021今天距离2022的春节还有176天 ​ 在以上程序中，cal1是通过Calendar类中的getInstance()方法实例化的，而cal2是通过Calendar的子类GregorianCalendar实例化的。其中，需要注意的是：第一，在Calendar类中，0表示1月份。第二，获取星期几时要减1，因为一个星期的第一天是从星期天开始算的。 日期格式类：DateFormat类 ​ 在程序设计中，日期和时间的处理要根据不同的需求显示不同的样式。前面学习到的Date类虽然可以获取精确的时间，但是显示格式不理想。为此java语言提供了java.textDateFormat类用于日期和时间的格式化处理。DateFormat类的定义如下： 1public abstract class DateFormat extends Format ​ 可以看出DateFormat类与前面的Calendar类一样作为抽象类，所以不能使用new关键字实例化，而是使用DateFormat类中提供的静态方法getDateFormat()实例化。DateFormat类的常用变量和方法如下表所示。 序号 方法 类型 说明 1 public static int DEFAULT 常量 用于默认模式的常量 2 public static int FULL 常量 用于FULL模式的常量 3 public static int LONG 常量 用于LONG模式的常量 4 public static int MEDIUM 常量 用于MEDIUM模式的常量 5 public static int SHORT 常量 用于SHORT模式的常量 6 public String format(Date date) 普通 将一个Date格式化为日期/时间字符串 7 public Calendar getCalendar() 普通 获得此日期/时间格式关联的日历 8 public static DateFormat getDateInstance() 静态 获得日期格式，该格式具有默认FORMAT语言环境的默认格式化风格 9 public static DateFormat getDateInstance(int style) 静态 获得日期格式，该格式具有默认语言环境的给定格式化风格 10 public static DateFormat getDateInstance(int style,Locale aLocale) 静态 获得日期格式，该格式具有给定语言环境的给定格式化风格 11 public static DateFormat getDateTimeInstance() 静态 获得日期/时间格式，该格式具有默认语言环境的默认格式化风格 12 public static DateFormat getDateTimeInstance(int dateStyle,int timeStyle) 静态 获得日期/时间格式，该格式具有给定语言环境的给定格式化风格 13 public static DateFormat getInstance() 静态 获得使用SHORT风格的默认日期/时间格式 14 public NumberFormat getNumberFomat() 普通 获得此日期/时间格式用于格式化和分析时间的数字 15 public static DateFormat getTimeInstance() 静态 获得时间格式，该格式具有默认语言环境的默认格式化风格 16 public static DateFormat getTimeInstance(int style) 静态 获得时间格式，该格式具有默认语言环境的给定格式化风格 17 public static DateFormat getTimeInstance(int style,Locale aLocale) 静态 获得时间格式，该格式具有给定语言环境的给定格式化风格 18 public TimeZone getTimeZone() 普通 获得时区 19 public Date parse(String source) 普通 将给定的字符串解析成日期/时间 20 public void setCalendar(Calendar newCalendar) 普通 设置此日期格式所使用的日历 21 public void setNumberFormat(NumberFomat newNumberFomat) 普通 允许用户设置数字格式 22 public void setTimeZone(Timezone zone) 普通 指定DateFormat对象的日历设置时区 代码示例： 12345678910111213141516import java.util.Date;import java.text.DateFormat;public class Test&#123; public static void main(String[] args) &#123; DateFormat df1=DateFormat.getInstance(); DateFormat df2=DateFormat.getDateInstance(); DateFormat df3=DateFormat.getTimeInstance(); DateFormat df4=DateFormat.getDateTimeInstance(); System.out.println(&quot;默认：&quot;+df1.format(new Date())); System.out.println(&quot;Date默认：&quot;+df2.format(new Date())); //格式化日期 System.out.println(&quot;Time默认：&quot;+df3.format(new Date())); //格式化时间 System.out.println(&quot;DateTime默认：&quot;+df4.format(new Date())); //格式化日期时间 &#125;&#125; 运行结果： 1234默认：21-8-9 下午3:27Date默认：2021-8-9Time默认：15:27:38DateTime默认：2021-8-9 15:27:38 ​ 程序执行后显示的时间格式比前面的Date类和Calendar类输出的时间格式好一些，但不是很符合中文的显示格式。若想要显示更加合理的日期格式，在构造DateFormat实例时，可传入DateFormat的常量和Locale常量。 输出中文格式的日期： 12345678910111213141516171819import java.util.Date;import java.util.Locale;import java.text.DateFormat;public class Test&#123; public static void main(String[] args) &#123; DateFormat dfSHORT=DateFormat.getDateTimeInstance(DateFormat.SHORT,DateFormat.SHORT,Locale.CHINA); DateFormat dfMEDIUM=DateFormat.getDateTimeInstance(DateFormat.MEDIUM,DateFormat.MEDIUM,Locale.CHINA); DateFormat dfDEFAULT=DateFormat.getDateTimeInstance(DateFormat.DEFAULT,DateFormat.DEFAULT,Locale.CHINA); DateFormat dfFULL=DateFormat.getDateTimeInstance(DateFormat.FULL,DateFormat.FULL,Locale.CHINA); DateFormat dfLONG=DateFormat.getDateTimeInstance(DateFormat.LONG,DateFormat.LONG,Locale.CHINA); System.out.println(&quot;SHORT型：&quot;+dfSHORT.format(new Date())); System.out.println(&quot;MEDIUM型：&quot;+dfMEDIUM.format(new Date())); System.out.println(&quot;EFAULT型：&quot;+dfDEFAULT.format(new Date())); System.out.println(&quot;FULL型：&quot;+dfFULL.format(new Date())); System.out.println(&quot;fLONG型：&quot;+dfLONG.format(new Date())); &#125;&#125; 运行结果： 12345SHORT型：21-8-9 下午3:53MEDIUM型：2021-8-9 15:53:59EFAULT型：2021-8-9 15:53:59FULL型：2021年8月9日 星期一 下午03时53分59秒 CSTfLONG型：2021年8月9日 下午03时53分59秒 ​ 以上程序，getDateTimeFormat()方法使用了三个参数，这是因为该方法获取的数据有两个，分别是日期和时间，所以参数的列表也应对应三个，分别为(int dateStyle,int TimeStyle,Locale aLocale)，以上表格为简化形式。 ​ 从程序的运行结果可以发现，FULL模式和LONG模式较好地符合了中国显示习惯。若开发人员想要得到自己定义的格式，需要用到DateFormat的子类SimpleDateFormat。 转换日期格式类：SimpleDateFormat类 ​ 在程序设计汇总，经常用到特定的日期时间格式，前面的DateFormat类明显不能满足要求，如将2021年8月9日 15:53:59转化为21年8月9日 15:53:59。这两个日期表示的都是同一个时间点，不同的是日期格式更加省略。 ​ 想要转换自定义格式，可以使用java.text.SimpleDateFormat类。SimpleDateFormat是以日期时间格式化类，一个与语言环境相关的方式和解析日期的具体类。 ​ 使用SimpleDateFormat类时，首先要定义一个完整的日期时间转换模板，在模板中可以通过特定的日期时间标记将一个日期时间的数字提取出来。日期时间格式模板中的字母及其含义如下表所示。 序号 标记 含义 1 y 表示年份。一般使用yy标记两位年份，yyyy标记四位年份 2 M 表示月份。一般使用MM标记两位年份，若使用MMM，则会根据语言环境的不同，显示不同的月份 3 d 表示月份中的天数。一般使用dd表示天数 4 D 表示年份中的天数。一般使用D表示当天是当年的第几天 5 E 表示星期中的天数。使用E即可标记，会根据语言环境的不同，显示不同的星期几 6 H 表示一天的小时数(24小时制)。一般使用HH标记 7 h 表示一天的小时数(12小时制)。一般使用hh标记 8 m 表示小时中的分钟数。一般使用mm标记 9 s 表示分钟中的秒数。一般使用ss标记 10 S 表示毫秒数。一般使用SSS标记 ​ 处理使用以上的模板标记，还需要使用SimpleDateFormat类中的一些方法，常用方法如下表所示。 序号 方法 类型 说明 1 public SimpleDateFormat() 构造 用默认的模式和默认语言环境的日期格式符号构造SimpleDateFormat对象 2 public SimpleDateFormat(String pattern) 构造 用给定的模式和默认语言环境的日期格式符号构造SimpleDateFormat对象 3 public SimpleDateFormat(String pattern,Locale locale) 构造 用给定的模式和给定的语言环境的默认日期格式符号构造SimpleDateFormat对象 4 public void applyLocalizedPattren(String pattern) 普通 将给定的本地化模式字符串应用于此日期格式 5 public void applyPattern(String pattern) 普通 将给定模式字符串应用与此日期格式 6 public String format(Date date) 普通 将一个Date格式化为日期/时间字符串 7 public StringBuffer format(Date date,StringBuffer toAppendTo,FieldPosition pos) 普通 将给定的Date格式化为日期/时间字符串，并将结果追加到给定的StringBuffer 8 public public Date parse(String source) Throws ParseException 普通 将一个包含日期的字符串转变为Date类型 9 public Date parse(String text,ParsePosition pos) 普通 分析字符串的文本，生成Date 10 public void setDateFormatSymbols(DateFormatSymbols newFormatSymbols) 普通 设置此日期格式的日期和时间格式符号 11 public String toLocalizePattern() 普通 返回描述此日期格式的本地化模式字符串 12 public String toPattern() 普通 返回描述此日期格式的模式字符串 使用指定的格式模板输出日期和时间 12345678910111213141516import java.util.Date;import java.text.SimpleDateFormat;public class Test&#123; public static void main(String[] args) &#123; String format1=&quot;yyyy年MM月dd日 HH:mm:ss E&quot;; //指定日期时间格式模板 String format2=&quot;yyyy年MM月dd日 HH时mm分ss秒SSS E&quot;; SimpleDateFormat sdf1=new SimpleDateFormat(format1); //使用指定模板实例化对象 SimpleDateFormat sdf2=new SimpleDateFormat(format2); String d1=sdf1.format(new Date()); String d2=sdf2.format(new Date()); System.out.println(d1); System.out.println(d2); &#125;&#125; 运行结果： 122021年08月09日 16:57:47 星期一2021年08月09日 16时57分47秒421 星期一 ​ 以上程序是以指定的日期时间格式format的模板形式显示日期时间的。SimpleDateFormat类还可以将包含日期的字符串转换为日期Date类型。 将包含日期的字符串转换为日期Date类型 123456789101112131415161718192021import java.util.Date;import java.text.SimpleDateFormat;import java.text.ParseException;public class Test&#123; public static void main(String[] args) &#123; String strDate=&quot;2021-08-09 17:02:32.562&quot;; String format=&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;; SimpleDateFormat sdf=new SimpleDateFormat(format); Date date=null; try &#123; date=sdf.parse(strDate); &#125;catch(ParseException e) &#123; e.printStackTrace(); &#125; System.out.println(date); &#125;&#125; 运行结果： 1Mon Aug 09 17:02:32 CST 2021 ​ 以上程序中，使用parse()方法将字符串解析为Date类型时，需要进行异常处理。还需要注意的是，指定日期时间模板的格式是要与日期时间的字符串一致，否则在运行时将产生错误。 错误如下： 1234java.text.ParseException: Unparseable date: &quot;2021-08-09 17:02:32:562&quot; at java.text.DateFormat.parse(Unknown Source) at Test.main(Test.java:14)null 牛刀小试 ​ 请编写一段程序，以获取输入日期所在月份的日历。如输出 2021 年 8 月，就可获得 当月的日历。 ​ 答：若要编写该程序，首先要获取输出的日期，可以使用Scanner类。在获取了日期后，还需要获得该日期当前月的1号是星期几，该月的天数是多少，这就需要使用Calendar类。 代码示例： 12345678910111213141516171819202122232425262728293031323334353637import java.util.Calendar;import java.util.Scanner;public class Test&#123; public static void main(String[] args) &#123; Scanner scan=new Scanner(System.in); System.out.println(&quot;————请输入年月————&quot;); System.out.println(&quot;年份：&quot;); int year=scan.nextInt(); System.out.println(&quot;月份：&quot;); int month=scan.nextInt(); if(month&lt;1||month&gt;12) &#123; System.out.println(&quot;输入的月份错误！&quot;); System.exit(0); &#125; Calendar c=Calendar.getInstance(); c.set(year,month-1,1); //将时间设置为指定日期,注意月份 int firstday=c.get(Calendar.DAY_OF_WEEK); //获取1号为星期几 int max=c.getActualMaximum(Calendar.DATE); //获取当月最大天数 System.out.println(&quot; &quot;+year+&quot;年&quot;+month+&quot;月&quot;); System.out.println(&quot;日 一 二 三 四 五 六&quot;); for(int i=1;i&lt;firstday;i++) //输出第一天之前的空白天数 &#123; System.out.print(&quot; &quot;); &#125; for(int i=1;i&lt;=max;i++) //输出月中的所有日期 &#123; System.out.print(i+&quot; &quot;); if(i&lt;10) System.out.print(&quot; &quot;); if((firstday+i-1)%7==0) System.out.println(); &#125; &#125;&#125; 运行结果： 参考书目： 《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"系统类：System类","slug":"java/常用类库/系统类：System类","date":"2021-08-08T12:15:39.000Z","updated":"2021-10-27T04:46:46.734Z","comments":true,"path":"2021/08/08/java/常用类库/系统类：System类/","link":"","permalink":"https://silenthly.github.io/2021/08/08/java/%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%BA%93/%E7%B3%BB%E7%BB%9F%E7%B1%BB%EF%BC%9ASystem%E7%B1%BB/","excerpt":"​ 大家对System类应该不会陌生，从第一个java程序Hello World开始就已经使用System.out.println()了，那么System类是什么呢？本文将讲解System类的常用功能。 认识System类 ​ System类代表当前java程序的运行平台，一些与系统相关的属性和方法。java引用程序不能创建System类的对象，它提供控制系统状态的静态方法，允许直接通过System类名来调用这些属性和方法。","text":"​ 大家对System类应该不会陌生，从第一个java程序Hello World开始就已经使用System.out.println()了，那么System类是什么呢？本文将讲解System类的常用功能。 认识System类 ​ System类代表当前java程序的运行平台，一些与系统相关的属性和方法。java引用程序不能创建System类的对象，它提供控制系统状态的静态方法，允许直接通过System类名来调用这些属性和方法。 ​ 一般而言，System类有以下几个重要的功能： 访问系统属性 访问环境变量 标准输入与输出 加载文件和动态链接库 复制数组 系统退出命令 执行垃圾回收 ​ 加载文件和动态链接库主要针对native方法起作用。对于一些特殊功能，如访问系统底层的硬件设备等，java程序是无法实现的，必须借助c语言完成。System类的常用属性和方法如下表所示。 序号 方法 类型 说明 1 public static PrintStream err 常量 “标准”错误输出流 2 public static InputStream in 常量 &quot;标准&quot;输如流 3 public static PrintStream out 常量 &quot;标准&quot;输出流 4 public static void arraycopy(Object src,int srcPos,Object dest,int destPos,int length) 静态 从指定源数组src中复制一个数组，复制从指定的索引位置srcPos开始，到目标数组dest的指定结束，destPos表示目标数组的起始位置，length表示复制数组的长度。注意不要产生数组越界行为 5 public static long currentTimeMillis() 静态 返回以ms为单位的当前时间 6 public static void exit(int status) 静态 终止当前正在运行的JVM，用于退出程序 7 public static void gc() 静态 调用垃圾回收器 8 public static String getenv(String name) 静态 获取指定的环境变量值 9 public static Properties getProperties() 静态 取得当前的系统属性 10 public static void load(String name) 静态 从作为动态库的本地文件系统中以指定的文件名加载代码文件 11 public static void loadLibrary() 静态 加载由libname参数指定的系统库 12 public static long nanoTime() 静态 返回最准确的可用系统计时器的当前值，以毫秒为单位 13 public static void runFinalization() 静态 运行处于挂起终止状态的所有对象的终止方法 14 public static void setErr(PrintStream err) 静态 重新分配“标准”错误流 15 public static void setIn(InputStream in) 静态 重新分配“标准”输入流 16 public static void setOut(PrintStream out) 静态 重新分配“标准”输出流 17 public static void setProperties(Properties props) 静态 将系统属性设置为Properties参数 访问系统属性 ​ 系统属性是指系统固有的属性，即在操作系统和JDK安装后就已存在属性。通过System类的getProperties()方法可以获取本机的系统属性。 代码示例： 123456789import java.util.Properties;public class Test&#123; public static void main(String[] args) &#123; Properties pr=System.getProperties(); //取得系统属性 pr.list(System.out); &#125;&#125; 运行结果： 1234567891011-- listing properties --java.runtime.name=Java(TM) SE Runtime Environmentsun.boot.library.path=D:\\Software\\JAVAJDK\\java111\\binjava.vm.version=25.231-b11java.vm.vendor=Oracle Corporationjava.vendor.url=http://java.oracle.com/path.separator=;java.vm.name=Java HotSpot(TM) 64-Bit Server VM...sun.desktop=windowssun.cpu.isalist=amd64 ​ 以上程序中通过标准输出流System.out将输出流打印在屏幕上。程序运行结果包含这个系统的属性集合。 复制数组 12345678910111213public class Test&#123; public static void main(String[] args) &#123; char src[]=&#123;&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;D&#x27;,&#x27;E&#x27;,&#x27;F&#x27;&#125;; char dest[]=&#123;&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;,&#x27;5&#x27;,&#x27;6&#x27;&#125;; System.arraycopy(src,3,dest,2,3); //快速赋值数组 for(char c:dest) //使用foreach输出数组元素 &#123; System.out.print(c+&quot; &quot;); &#125; &#125;&#125; 运行结果： 11 2 D E F 6 计算程序执行时间 ​ 可以使用System类的currentTimeMillis()来计算程序的运行时间，在前面的文件复制程序中也可以使用。 12345678910111213public class Test&#123; public static void main(String[] args) &#123; long start=System.currentTimeMillis(); //获取任务开始时间 long result=0; for(long i=1;i&lt;9999999999L;i++) &#123; result=result+i; &#125; System.out.println(&quot;程序执行时间：&quot;+(System.currentTimeMillis()-start)+&quot;ms&quot;); &#125;&#125; 运行结果： 1程序执行时间：2356ms ​ currentTimeMillis()方法返回的是一个long类型的数据，时间单位为ms。 垃圾对象的回收 ​ System.gc()可用于垃圾回收器。此方法实际上是对RunTime类中的gc()方法的封装，等效于使用： 1Runtime.getRuntime().gc(); ​ 当使用System.gc()回收某个对象所占用的内存之前，通常要求程序调用适当的方法来清理资源。在没有明确指定资源清理的情况下，java提供了默认机制来清理该对象的资源，就是调用Object类的finalize()方法。finalize()方法的作用是在释放一个对象占有的内存空间时，会被JVM自动调用。该方法的定义如下： 1protected void finalize() throws Thowable ​ 可以发现finalize()方法的访问控制符为protected，而且声明的异常为Throwable，表示它可以抛出任何类型的异常。子类只需重写finalize()方法，即可清理对象占用的资源。由于finalize()方法没有链式调用，所以必须手动实现。 123456789101112131415161718192021222324252627282930class Person&#123; private String name; private int age; public Person()&#123;&#125; public Person(String name,int age) &#123; this.name=name; this.age=age; &#125; public String toString() &#123; return (&quot;姓名&quot;+name+&quot;,年龄&quot;+age); &#125; public void finalize()throws Throwable &#123; System.out.println(&quot;释放对象&quot;+this); super.finalize(); &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; Person p=new Person(&quot;小明&quot;,3); System.out.println(p); p=null; System.gc(); &#125;&#125; 运行结果： 12姓名小明,年龄3释放对象姓名小明,年龄3 ​ 从程序运行结果可以发现，执行System.gc()前，系统会自动调用finalize()方法清除对象占有的资源。通过super.finalize()方式可以从上到下实现finalize()方法的调用，即先释放自己的资源，再去释放父类的资源。 ​ 注意：不可在程序中频繁的调用垃圾回收。因为每执行异常垃圾回收，JVM都会强制启动垃圾回收器运行，这样会耗费更多的系统资源，会与正常的java程序运行争抢资源。只有在执行大量对象的释放，才调用垃圾回收最好。 参考书目： 《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"定时器","slug":"java/常用类库/定时器","date":"2021-08-08T03:25:13.000Z","updated":"2021-10-27T04:47:13.045Z","comments":true,"path":"2021/08/08/java/常用类库/定时器/","link":"","permalink":"https://silenthly.github.io/2021/08/08/java/%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%BA%93/%E5%AE%9A%E6%97%B6%E5%99%A8/","excerpt":"​ 定时器是一种应用十分广泛的线程工具，可用于调度多个定时任务以后台线程方式执行。每一个定时器都有一个后台线程，定时器调度的所有任务均在该线程中依次执行。在java中，可以通过Timer类和TimerTask类来实现定时调度的功能。","text":"​ 定时器是一种应用十分广泛的线程工具，可用于调度多个定时任务以后台线程方式执行。每一个定时器都有一个后台线程，定时器调度的所有任务均在该线程中依次执行。在java中，可以通过Timer类和TimerTask类来实现定时调度的功能。 Timer类 ​ 在java中可以使用两个类来实现定时器，即java.util.Timer类和java.util.TimerTask类。Timer类可以用来实现在某一个时间点或某一段时间后，执行某个任务依次或定期重复执行。Timer类一般要与TimerTask搭配使用。TimerTask类由Timer安排为一次执行或重复执行的任务。Timer类的常用方法如下表所示。 序号 方法 类型 说明 1 public Timer() 构造 创建一个新计时器 2 public Timer(boolean isDaemon) 构造 创建一个新计时器，并指定相关线程作为守护线程 3 public Timer(String name) 构造 创建一个新的计时器，并为指定的相关线程设置名称 4 public Timer(String name,boolean isDaemon) 构造 创建一个新的计时器，为指定的相关线程设置名称，并指定相关线程作为守护线程 5 public void cancel() 普通 终止此计时器，放弃所有当前已安排的任务，但对已执行的任务没有影响 6 public int purge() 普通 移除所有已取消的任务。可用于是否内存空间。 7 public void schedule(TimerTask task,Date time) 普通 安排在指定的时间执行指定的任务，若已超过该时间，则立即执行 8 public void schedule(TimerTask task,Date firsttime,long period) 普通 安排在指定的时间执行指定的任务，然后以固定的频率(单位：ms)重复执行 9 public void schedule(TimerTask task,long delay) 普通 安排指定的任务在一段时间(单位：ms)后执行 10 public void schedule(TimerTask task,long delay,long period) 普通 安排指定的任务在一段时间后(单位：ms)执行，然后以固定的频率(单位：ms)重复执行 11 public void scheduleAtFixedRate(TimerTask task,Date firstTime,long period) 普通 安排在指定的时间执行指定的任务，然后以近似固定的频率(单位：ms)重复执行 12 public void scheduleAtFixedRate(TimerTask task,long delay,long period) 普通 安排指定的任务在一段时间后(单位：ms)执行，然后以近似的频率(单位：ms)重复执行 注意：默认情况下定时器的后台程序并不是守护线程，除非在创建定时器时显式地指定该线程为守护线程。 schedule()与scheduleAtFixedRate()的区别 ​ 两者的区别在于重复执行任务时，时间间隔出现延迟的情况不同。 1、schedule()方法的执行时间间隔用于是固定的，就算之前出现了延迟的情况，之后也会按照已经设定好的间隔时间拉执行。 2、scheduleAtFixedRate()方法可以根据出现的延返时间自动调整下一次间隔的执行时间。 ​ Timer类是线程安全的。多个线程可以共享单个Timer对象而无序进行外部同步，并且不提供实时保证但可以使用Object.wait(long)方法来安排任务。 TimerTask类 ​ 使用通用定时器需要编写TimerTask的一个子类，将定时任务编写在该子类的run()方法中。由定时器调度的所有任务均需表达为TimerTask的实例，类似Runnable接口，程序员必须在其子类中重定义run()方法以描述自己的定时任务；然后还需分别创建一个Timer类的实例和一个自定义TimerTask子类的实例；最后调用Timer实例的schedule()方法调度定时任务，调用schedule()方法时会将新任务添加到定时器的任务队列中。TimerTask类的常用方法如下表所示。 序号 方法 类型 说明 1 public boolean cancel() 普通 取消此计时器任务。 如果任务已安排为一次性执行且尚未运行，或尚未安排，则它将永远不会运行。 如果任务已安排重复执行，则它将永远不会再运行。(如果在发生此调用时任务正在运行，则任务将运行完成，但永远不会再次运行) 2 public abstract void run() 抽象 此计时器任务要执行的操作编写在该方法中，子类必须重写该方法，与Runnable接口的run()方法类似 3 public long scheduledExecutionTime() 普通 返回此任务最近要执行的任务时间。若该任务正在执行，返回该任务执行的计划执行时间。该方法一般会在run()方法中调用，可以用于判断当前是否有足够的时间来完成该任务。 代码示例： 1234567891011121314151617181920212223import java.util.Date;import java.util.Timer;import java.util.TimerTask;class RemindTask extends TimerTask //任务调度类继承TimerTask&#123; public void run() &#123; System.out.println(&quot;执行时间：&quot;+(new Date())); &#125;&#125;public class Test&#123; public Test(int seconds,int lenTime) &#123; Timer tm=new Timer(); //建立Timer类对象 tm.schedule(new RemindTask(),seconds,lenTime); //执行任务 &#125; public static void main(String[] args) &#123; System.out.println(&quot;任务调度开始...&quot;); new Test(500,1000); //设置任务，0.5秒后开始，每1秒重复一次 &#125;&#125; 运行结果： 1234567任务调度开始...执行时间：Sun Aug 08 12:42:33 CST 2021执行时间：Sun Aug 08 12:42:34 CST 2021执行时间：Sun Aug 08 12:42:35 CST 2021执行时间：Sun Aug 08 12:42:36 CST 2021执行时间：Sun Aug 08 12:42:37 CST 2021.... ​ 以上程序主要是打印定时任务执行时系统的时间。 参考书目： 《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"运行时操作类：Runtime类","slug":"java/常用类库/运行时操作类：Runtime类","date":"2021-08-08T00:32:23.000Z","updated":"2021-10-27T04:47:22.783Z","comments":true,"path":"2021/08/08/java/常用类库/运行时操作类：Runtime类/","link":"","permalink":"https://silenthly.github.io/2021/08/08/java/%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%BA%93/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B1%BB%EF%BC%9ARuntime%E7%B1%BB/","excerpt":"​ java.lang.Runtime类封装了运行时的环境，每个java程序都有一个与之对应的Runtime实例，使应用程序能够与其运行环境相连接。","text":"​ java.lang.Runtime类封装了运行时的环境，每个java程序都有一个与之对应的Runtime实例，使应用程序能够与其运行环境相连接。 认识Runtime类 ​ 应用程序一般不能实例化一个Runtime对象，Runtime对象是由JVM运行时为其实例化。在API帮助文档中Runtime类是没有构造方法定义的，因为Runtime类本身的构造方法是私有化的。所以应用程序是不能创建自己的Runtime类实例，但可以通过getRuntime()方法获取当前Runtime运行时对象的引用，如以下代码： 1Runtime rt=Runtime.getRuntime(); ​ Runtime类代表java程序的运行时环境，可以调用Runtime对象的方法控制java虚拟机的状态和行为，如处理器数目、内存信息等。Runtime类的常用方法如下表所示。 序号 方法 类型 说明 1 public int availableProcessors() 普通 向JVM返回可用处理器数目 2 public Process exec(String command) throws IOException 普通 在单独的进程中执行指定的字符串命令 3 public void exit(int status) 普通 通过启动虚拟机的关闭序列，终止当前正在运行的JVM 4 public long freeMemory() 普通 返回JVM中的空闲内存量 5 public void gc() 普通 运行垃圾回收器 6 public static Runtime getRuntime() 静态 返回当前java应用程序相关的运行时对象 7 public void halt(int status) 普通 强行终止目前正在运行的JVM 8 public void load(String filename) 普通 加载作为动态库的指定文件名 9 public void loadLibrary(String libname) 普通 加载具有指定库名的动态库 10 public long maxMemory() 普通 返回JVM试图使用的最大内存量 11 public long totalMemory() 普通 返回JVM中的内存总量 获取JVM信息 ​ 通过以下范例访问JVM的相关信息，如处理器数目、空闲内存量、最大内存量和内存总量等信息。 代码示例： 12345678910111213141516171819public class Test&#123; public static void main(String[] args) &#123; Runtime rt=Runtime.getRuntime(); System.out.println(&quot;JVM处理器的数目：&quot;+rt.availableProcessors()); System.out.println(&quot;JVM空闲内存量：&quot;+rt.freeMemory()); System.out.println(&quot;JVM内存总量：&quot;+rt.totalMemory()); System.out.println(&quot;JVM最大内存量：&quot;+rt.maxMemory()); String str=null; for(int i=0;i&lt;10000;i++) &#123; str=&quot;&quot;+i; &#125; System.out.println(&quot;操作str后，JVM空闲内存量：&quot;+rt.freeMemory()); rt.gc(); System.out.println(&quot;回收垃圾后，JVM空闲内存量：&quot;+rt.freeMemory()); &#125;&#125; 运行结果： 123456JVM处理器的数目：16JVM空闲内存量：246939608JVM内存总量：249561088JVM最大内存量：3679977472操作str后，JVM空闲内存量：245628888回收垃圾后，JVM空闲内存量：247604200 ​ 以上程序中，String类型的变量内容不可改变，只会改变变量的指向。使用for循环修改str会产生大量的垃圾，所以JVM的空余内存量会变小。但是执行gc()方法回收垃圾后，JVM空余内存就变大了。 Runtime类与Process类 ​ Process类是一个抽象类，方法都是抽象的，通过Process类可用来控制进程并获取相关信息。该类提供进程的输入、执行输出到进程、等待进程的完成和检查进程的退出状态及销毁进程的方法。Process类的常用方法如下表所示。 序号 方法 类型 说明 1 public abstract void destroy() 抽象 关闭子进程 2 public abstract int exitValue() 抽象 返回子进程的出口值 3 public abstract InputStream getErrorStream() 抽象 获取子进程的错误流 4 public abstract InputStream getInputStream() 抽象 获取子进程的输入流 5 public abstract OutputStream getOutputStream() 抽象 获取子进程的输出流 6 public abstract int waitFor() throws InterruptedException 抽象 导致当前线程等待，如果必要，一直等到由该Process对象表示的进程已经终止 调用本机可执行程序 123456789101112131415public class Test&#123; public static void main(String[] args) &#123; Runtime rt=Runtime.getRuntime(); Process pcs=null; try &#123; pcs=rt.exec(&quot;calc.exe&quot;); //调用本机的计算机 &#125;catch(Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; ​ 程序执行时，windows操作系统的计算器软件就会弹出。虽然不使用Process类直接运行rt.exec(“calc.exe”)也是可以调用计算器的，但是不能对计算器线程进行控制了。 改进上面的程序 1234567891011121314151617181920212223public class Test&#123; public static void main(String[] args) &#123; Runtime rt=Runtime.getRuntime(); Process pcs=null; try &#123; pcs=rt.exec(&quot;calc.exe&quot;); //调用本机的计算机 &#125;catch(Exception e) &#123; e.printStackTrace(); &#125; try &#123; Thread.sleep(5000); &#125;catch(Exception e) &#123; e.printStackTrace(); &#125; process.destroy(); &#125;&#125; ​ 以上程序，计算器启动5秒后进程会关闭。 参考书目： 《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Object类","slug":"java/常用类库/Object类","date":"2021-08-07T12:52:54.000Z","updated":"2021-10-27T04:47:07.297Z","comments":true,"path":"2021/08/07/java/常用类库/Object类/","link":"","permalink":"https://silenthly.github.io/2021/08/07/java/%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%BA%93/Object%E7%B1%BB/","excerpt":"​ java中所有的类都直接或间接地继承自Object类，即使没有显式地使用extends关键字指定Object为父类，系统也会自动继承该类。所以说，Object类是整个java语言继承树的唯一根。 注意：数组和枚举类也是Object类的子类。","text":"​ java中所有的类都直接或间接地继承自Object类，即使没有显式地使用extends关键字指定Object为父类，系统也会自动继承该类。所以说，Object类是整个java语言继承树的唯一根。 注意：数组和枚举类也是Object类的子类。 ​ 根据继承特性，任何java对象都可以调用Object类的方法。常用的Object类方法被人们熟知，本文主要介绍Object类中的clone()、equals()和toString()等方法，功能如下表所示。 序号 方法 类型 说明 1 protected native Object clone() throws CloneNotSupportedException 普通 创建并返回与该对象相同的新对象，即克隆该对象 2 public boolean equals(Object obj) 普通 比较两个对象是否“相等” 3 protected void finalize() throws Thowable 普通 当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法 4 public final Class&lt;? extends Object&gt;getClass() 普通 返回一个对象的运行时类 5 public int hashCode() 普通 返回该对象的哈希码值 6 public String toString() 普通 放回该对象的字符串表示 重写toString()方法 ​ java中的大多数类都会重写该方法，通常的方式是将类名及类成员的状态信息转换为字符串后返回。 代码示例： 123456789101112131415161718192021222324class Person&#123; private String name; private int age; public Person()&#123;&#125; public Person(String name,int age) &#123; this.name=name; this.age=age; &#125; public String toString() &#123; return (&quot;姓名&quot;+name+&quot;，年龄&quot;+age); &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; Person p=new Person(&quot;小强&quot;,18); System.out.println(p.toString()); System.out.println(p); &#125;&#125; 运行结果： 12姓名小强，年龄18姓名小强，年龄18 ​ 以上程序中，为了缩减代码量，没有写入setter和getter方法，但是在类中最好是写上。可以发现两次打印的结果都是相同的，这是因为System.out.println()在打印引用数据类型时，若不为空，则首先调用引用对象的toString()方法获取字符串，然后再打印字符串内容。如果没有重写toString()方法将大隐输出的是引用对象的内存地址。 equals()比较 ​ 在比较两个字符串的内容是否相等时，我们就使用到了equals()方法。其实equals()方法源自Object类，而在Stirng类中对equals()方法进行类重写，以满足比较字符串的内容是否相等的要求。在Object类中equals()方法的定义如下： 1234public boolean equals(Object obj)&#123; return (this==obj);&#125; ​ 可以看出，Object类中的equals()方法并没有比较两个对象是否相等的功能，只是判断两个引用是否指向同一个对象。在Object类中设计equals()方法就是让其子类来重写，以满足比较不同类的对象是否相等的要求。 代码示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Person&#123; private String name; private int age; public Person()&#123;&#125; public Person(String name,int age) &#123; this.name=name; this.age=age; &#125; public boolean equals(Object obj) &#123; if(this==obj) //判断当前对象与指定对象是否相等 &#123; return true; &#125; if(this==null) &#123; return false; &#125; if(!(obj instanceof Person)) //判断指定对象是否为Person的示例 &#123; return false; &#125; Person per=(Person)obj; //将指定对象转化为Person对象 if(this.name.equals(per.name)&amp;&amp;this.age==per.age) //比较对象的属性是否相等 &#123; return true; &#125;else &#123; return false; &#125; &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; Person p1=new Person(&quot;小强&quot;,18); Person p2=new Person(&quot;小强&quot;,18); Person p3=new Person(&quot;小明&quot;,19); if(p1.equals(p2)) &#123; System.out.println(&quot;p1和p2相同&quot;); &#125;else &#123; System.out.println(&quot;p1和p2不相同&quot;); &#125; if(p1.equals(p3)) &#123; System.out.println(&quot;p1和p3相同&quot;); &#125;else &#123; System.out.println(&quot;p1和p3不相同&quot;); &#125; &#125;&#125; 运行结果： 12p1和p2相同p1和p3不相同 ​ 从程序的运行结果可以看出，重写equals()方法后可以比较两个对象是否相等。在很多时候，如果需要重写equals()方法，则必须重写hashCode()方法。 注意：equals()方法的形参必须是Object类型，不能是其他类型。 重写hashCode()方法 ​ 在java中对equals()方法和hashCode()方法有以下的约定： 1、在程序的执行期间，如果一个对象的equals()方法做比较所用到的信息没有被修改，则该对象多次调用的hashCode()方法返回的结果值必然是同一个整数。 2、如果两个对象根据equals()方法结果值是true，则调用这两个对象中任一对象的hashCode()方法必须返回同一个整数值。 3、如果两个对象数据equals()方法结果值为false，则调用这两个对象中人任一个对象的hashCode()方法，不要求尝试不同的整数结果。但如果不同，则可以提高散列表的性能。就是说，这两个对象的hashCode()值相同，并不代表这两个对象相等。 代码示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class Person&#123; private String name; private int age; public Person()&#123;&#125; public Person(String name,int age) &#123; this.name=name; this.age=age; &#125; public boolean equals(Object obj) &#123; if(this==obj) //判断当前对象与指定对象是否相等 &#123; return true; &#125; if(this==null) &#123; return false; &#125; if(!(obj instanceof Person)) //判断指定对象是否为Person的示例 &#123; return false; &#125; Person per=(Person)obj; //将指定对象转化为Person对象 if(this.name.equals(per.name)&amp;&amp;this.age==per.age) //比较对象的属性是否相等 &#123; return true; &#125;else &#123; return false; &#125; &#125; public int hashCode() //重写hashCode()函数 &#123; final int prime=13; int result=13; result=prime*result+((name==null)?0:name.hashCode()); result=prime*result+age; return result; &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; Person p1=new Person(&quot;小强&quot;,18); Person p2=new Person(&quot;小强&quot;,18); Person p3=new Person(&quot;小明&quot;,19); System.out.println(&quot;p1的哈希码：&quot;+p1.hashCode()); System.out.println(&quot;p2的哈希码：&quot;+p2.hashCode()); System.out.println(&quot;p3的哈希码：&quot;+p3.hashCode()); if(p1.equals(p2)) &#123; System.out.println(&quot;p1和p2相同&quot;); &#125;else &#123; System.out.println(&quot;p1和p2不相同&quot;); &#125; if(p1.equals(p3)) &#123; System.out.println(&quot;p1和p3相同&quot;); &#125;else &#123; System.out.println(&quot;p1和p3不相同&quot;); &#125; &#125;&#125; 运行结果： 12345p1的哈希码：9816630p2的哈希码：9816630p3的哈希码：9839355p1和p2相同p1和p3不相同 ​ 从程序运行结果可以发现，p1和p2的哈希码值相同，而p1与p3的哈希码值不同。 克隆对象 ​ java语言支持对象的克隆。可以通过Object类中的clone()方法，创建一个和该对象的内容完全一样的对象，新的对象也会拥有独立的内存空间。 在Object类中clone()方法定义格式： 1protected native Object clone() throws CloneNotSupportedException ​ 从格式可以看到，在Object类中的clone()是被protected修饰的，若要从系统中任意位置的类访问它，那么在重写clone()方法时，应该扩大访问权限为public。但具体的克隆方法还是在Object类中实现，所以只需在重写clone()方法中的调用Object类的clone()方法即可。需要注意的是，在对象所在的类要实现Cloneable接口，该接口只是一个标识接口，表示该对象可以被克隆。 代码示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class Person implements Cloneable&#123; private String name; private int age; public Person()&#123;&#125; public Person(String name,int age) &#123; this.name=name; this.age=age; &#125; public boolean equals(Object obj) &#123; if(this==obj) //判断当前对象与指定对象是否相等 &#123; return true; &#125; if(this==null) &#123; return false; &#125; if(!(obj instanceof Person)) //判断指定对象是否为Person的示例 &#123; return false; &#125; Person per=(Person)obj; //将指定对象转化为Person对象 if(this.name.equals(per.name)&amp;&amp;this.age==per.age) //比较对象的属性是否相等 &#123; return true; &#125;else &#123; return false; &#125; &#125; public int hashCode() //重写hashCode()函数 &#123; final int prime=13; int result=13; result=prime*result+((name==null)?0:name.hashCode()); result=prime*result+age; return result; &#125; public Object clone() throws CloneNotSupportedException //重写clone()方法 &#123; return super.clone(); //调用Object类的clone()方法 &#125; public String toString() &#123; return (&quot;姓名&quot;+name+&quot;，年龄&quot;+age); &#125;&#125;public class Test&#123; public static void main(String[] args) throws CloneNotSupportedException &#123; Person p1=new Person(&quot;小强&quot;,18); Person p2=(Person)p1.clone(); System.out.println(p1+&quot;p1的哈希码：&quot;+p1.hashCode()); System.out.println(p2+&quot;p2的哈希码：&quot;+p2.hashCode()); if(p1.equals(p2)) &#123; System.out.println(&quot;p1和p2相同&quot;); &#125;else &#123; System.out.println(&quot;p1和p2不相同&quot;); &#125; &#125;&#125; 运行结果： 123姓名小强，年龄18p1的哈希码：9816630姓名小强，年龄18p2的哈希码：9816630p1和p2相同 ​ 从程序的运行结果可以发现，通过clone()方法克隆出来的对象p1和p2的哈希码值相同，而且内容也完全相同。 参考链接： 重写clone方法时，为什么需要在Java中将它声明为public？ - 经验笔记 (nhooo.com) 参考书目： 《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"线程间的通信","slug":"java/线程/线程间的通信","date":"2021-08-07T02:45:23.000Z","updated":"2021-10-27T04:47:37.643Z","comments":true,"path":"2021/08/07/java/线程/线程间的通信/","link":"","permalink":"https://silenthly.github.io/2021/08/07/java/%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/","excerpt":"​ 多线程的主要作用是多个线程处理锁个不同的任务，这就必然存在多个线程的协调问题。在运用多线程时，除了可以使用synchronized关键字，让多个线程实现同步处理之外，还可以利用Object类中的notify()、notifyAll()和wait()方法，让多个同时处理的线程之间能能够主动的&quot;沟通协调&quot;。","text":"​ 多线程的主要作用是多个线程处理锁个不同的任务，这就必然存在多个线程的协调问题。在运用多线程时，除了可以使用synchronized关键字，让多个线程实现同步处理之外，还可以利用Object类中的notify()、notifyAll()和wait()方法，让多个同时处理的线程之间能能够主动的&quot;沟通协调&quot;。 ​ java.lang.Object类是所有类的父类，该类中有以上提到的notify()、notifyAll()和wait()方法，它们时专门用于线程通信的方法。它们的作用如下表所示。(等待池与锁池的概念在线程同步一文里面有介绍) 序号 方法 类型 说明 1 public final void notify() 普通 唤醒等待池中的线程。当执行该方法时，从此对象等待池中随机选择一个线程放到对象的锁池中 2 public final void notifyAll() 普通 唤醒等待池中的所有线程。当执行该方法时，从此对象等待池中随机选择一个线程放到对象的锁池中 3 public final void wait() throws InterruptedException 普通 使当前的线程等待，并让该线程释放对象锁，放进对象的等待池中，等待其他线程将其唤醒 4 public final void wait(long timeout) throws InterruptedException 普通 与前者类似，指定等待的最长时间，以毫秒为单位 5 public final void wait(long timeout,int nanos) throws InterruptedException 普通 与前者类似，指定等待的最长时间为毫秒加纳秒，时间精度更高 ​ 下面通过一个范例来介绍多线程的通信问题。有两个线程，分别为sf和gf，sf用来放置食物，gf用来取走食物，并规定： 1、sf一次只能放置一批次的食物，sf放置好食物后通知gf取走。 2、gf也只能一次取走一批次的食物，等到gf取走食物后通知sf放置食物。 3、sf不放置食物，则gf不能取走食物，若gf没有取走食物，则sf不能放置食物。 4、开始时，先由sf放置，再由gf取走 代码示例： 食物类： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class Food&#123; private int number=0; //食物批次 private String food=null; //食物名称 public Food()&#123;&#125; public Food(String food,int number) &#123; this.food=food; this.number=number; &#125; public synchronized void setFood(int n) //放置食物 &#123; if(number!=0) &#123; try &#123; wait(); //等待取走食物 &#125;catch(InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; number=n; //返回批次 System.out.println(&quot;放置&quot;+food+&quot;第&quot;+number+&quot;批次&quot;); notify(); //通知取走食物 &#125; public synchronized String getFood() //取走食物 &#123; if(number==0) &#123; try &#123; wait(); //等待放置食物 &#125;catch(InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(&quot;\\t取走第&quot;+number+&quot;批次&quot;+food); number=0; notify(); //通知放置食物 return food+number; &#125; public static void main(String[] args) &#123; Food f=new Food(&quot;火腿&quot;,0); SetFood sf=new SetFood(f); GetFood gf=new GetFood(f); new Thread(sf).start(); new Thread(gf).start(); &#125;&#125; 放置食物类：SetFood 12345678910111213141516171819202122public class SetFood implements Runnable&#123; private Food food; //创建对象引用 public SetFood(Food food) &#123; this.food=food; &#125; public void run() &#123; for(int number=1;number&lt;=5;number++) &#123; try &#123; Thread.sleep(100); &#125;catch(InterruptedException e) &#123; e.printStackTrace(); &#125; food.setFood(number); //放置食物 &#125; &#125;&#125; 取走食物类：GetFood 12345678910111213141516171819202122public class GetFood implements Runnable&#123; private Food food; public GetFood(Food food) &#123; this.food=food; &#125; public void run() &#123; for(int number=1;number&lt;=5;number++) &#123; try &#123; Thread.sleep(500); &#125;catch(InterruptedException e) &#123; e.printStackTrace(); &#125; food.getFood(); //放置食物 &#125; &#125;&#125; 运行结果： 12345678910放置火腿第1批次 取走第1批次火腿放置火腿第2批次 取走第2批次火腿放置火腿第3批次 取走第3批次火腿放置火腿第4批次 取走第4批次火腿放置火腿第5批次 取走第5批次火腿 ​ 从程序结果可以发现，每放置一批食物就要等待取走，每一次取走食物就要等待放置食物，避免了重复生成和重复取走的问题。 注意：在调用同一个对象的wait()和notify()方法的语句必须放在同步代码块中，并且同步代码块使用该对象的同步锁，否则在运行时将会抛出InterruptedException异常。 参考书目： 《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"线程同步","slug":"java/线程/线程同步","date":"2021-08-05T23:14:23.000Z","updated":"2021-10-27T04:46:00.561Z","comments":true,"path":"2021/08/06/java/线程/线程同步/","link":"","permalink":"https://silenthly.github.io/2021/08/06/java/%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/","excerpt":"​ 当一个多线程应用程序同时执行多个任务时，这些任务之间有时需要通信与同步，这时可能会出现线程冲突问题。线程安全问题是不容忽视的，但是线程安全问题很难被发现，如多个线程要操作统一资源时就有可能产生程序资源同步问题。(线程安全是指多线程访问同一代码，不会产生不确定的结果)","text":"​ 当一个多线程应用程序同时执行多个任务时，这些任务之间有时需要通信与同步，这时可能会出现线程冲突问题。线程安全问题是不容忽视的，但是线程安全问题很难被发现，如多个线程要操作统一资源时就有可能产生程序资源同步问题。(线程安全是指多线程访问同一代码，不会产生不确定的结果) 同步的必要性 ​ 如前面讲过的电影院售票系统，从表面上看是没有什么问题。但是在售票时网络是不能实时传输的，总是存在延迟的情况，所以在售出一张门票后，需要一点时间延迟。下面通过范例来了解线程不是同步时，将会出现什么情况。 1234567891011121314151617181920212223242526272829303132class Ticket implements Runnable&#123; private int ticket=10; public void run() &#123; while(ticket&gt;0) &#123; try &#123; Thread.sleep(100); //模拟售票耗时过程 &#125;catch(InterruptedException e) &#123; e.printStackTrace(); &#125; if(ticket&gt;0) &#123; System.out.println(Thread.currentThread().getName()+&quot; 售出第&quot;+(ticket--)+&quot;张门票&quot;); &#125; &#125; &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; Ticket window=new Ticket(); Thread t1=new Thread(window,&quot;第一窗口&quot;); Thread t2=new Thread(window,&quot;第二窗口&quot;); t1.start(); t2.start(); &#125;&#125; 运行结果： 123456789101112第二窗口卖出第10张门票.....第一窗口卖出第9张门票.....第二窗口卖出第8张门票.....第一窗口卖出第8张门票.....第二窗口卖出第7张门票.....第一窗口卖出第6张门票.....第二窗口卖出第5张门票.....第一窗口卖出第4张门票.....第一窗口卖出第3张门票.....第二窗口卖出第2张门票.....第一窗口卖出第1张门票.....第二窗口卖出第1张门票..... ​ 从程序的运行结果可以发现，第1张与第8张票被卖出两次，卖出的是重票，这是绝对不允许的。出现这样的情况，是由于一个线程在没有对票数进行减一操作时，其他线程已对票数进行了减一操作。在java语言中，解决同步问题的方法有两种，一种是同步代码块，另一种是同步方法。 同步机制 ​ 为了避免多线程在共享资源时发生冲突，所以要在线程使用该资源时，就为资源上一把“锁”。第一个访问资源的线程为资源上锁，其他线程若想访问该资源，则必须等到第一个访问线程对资源解锁。解锁的同时，另一个线程访问资源并为资源上锁。 同步机制的实现 ​ 同步机制的实现需要依赖Synchronized关键字，在多线程并发编程中Synchronized一直是元老级角色，很多人都会称呼它为重量级锁，但是随着Java SE1.6对synchronized进行了各种优化之后，有些情况下它并不那么重了。在了解锁的概念之前，需要记住，java中的每一个对象都有一个锁，且是唯一的。 同步代码块 格式： 1234synchronized(lock)&#123; //操作共享资源代码块&#125; 锁与锁池的概念 ​ 上述代码中，lock是一个锁对象，可以是任意类型的对象，它是同步代码块的关键。当线程执行同步代码块时，首先会检查锁对象的标志位(即锁对象的&quot;锁&quot;)，默认情况下标志位为1，此时线程会执行同步代码块，同时将锁对象的标志位设置为0(即线程获得锁对象的锁)。 ​ 当一个新的线程执行到这段同步代码块时，由于锁对象的标志位为0，新线程会发生阻塞**(线程的生命周期状态会被调整为BLOCKED)，此时新线程就会被放进锁池**，等待当前线程执行完同步代码块后，锁对象的标志位被置为1(即释放锁)，锁池中的任意一个线程会被唤醒**(只能有一个)，唤醒的线程与其他活跃线程(即不在锁池中，且线程的生命周期状态为RUNNABLE的线程)**抢占这个锁，若被唤醒的线程抢到锁，那么该线程就从锁池中移除，否则将再次暂停。这样循环往复，直到共享资源被处理完为止。 注意：实际上在java中并没有锁池的概念，真正的锁池并不是这个名字，这里使用“锁池”便于理解，若要了解同步阻塞的相关内容，必须回归其实质，否则将不得其法。(点击此处详细了解锁池的实质) 1、对象的同步锁在任何时刻最多只能被一个线程所拥有。 2、当拥有锁对象的锁的线程t执行完后，会自动释放锁对象的锁。若在执行中，线程t发生异常退出，也将自动释放锁对象的锁。 3、如果线程t在执行同步代码块时，调用了锁对象的wait()方法，则同样会自动释放锁对象的锁，线程t也将转为阻塞状态。 4、如果线程t在执行同步代码块时，调用了锁对象的sleep()方法，线程t将会放弃cpu运行权，但不会放弃锁对象的锁。 代码示例： 12345678910111213141516171819202122232425262728293031323334353637383940class Ticket implements Runnable&#123; private int ticket=1000; Object lock=new Object(); //定义任意一个对象，用作同步代码块的锁 public void run() &#123; while(ticket&gt;0) &#123; synchronized(lock) &#123; try &#123; Thread.sleep(10); //模拟售票耗时过程 &#125;catch(InterruptedException e) &#123; e.printStackTrace(); &#125; if(ticket&gt;0) &#123; System.out.println(Thread.currentThread().getName()+&quot; 售出第&quot;+(ticket--)+&quot;张门票&quot;); &#125; &#125; &#125; &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; Ticket window=new Ticket(); Thread t1=new Thread(window,&quot;窗口1 &quot;); Thread t2=new Thread(window,&quot;窗口2 &quot;); Thread t3=new Thread(window,&quot;窗口3 &quot;); Thread t4=new Thread(window,&quot;窗口4 &quot;); t1.start(); t2.start(); t3.start(); t4.start(); &#125;&#125; 运行结果： 12345678910窗口1 售出第10张门票窗口1 售出第9张门票窗口1 售出第8张门票窗口1 售出第7张门票窗口1 售出第6张门票窗口1 售出第5张门票窗口1 售出第4张门票窗口1 售出第3张门票窗口1 售出第2张门票窗口1 售出第1张门票 ​ 从运行结果发现，没有出现卖出重票的情况，解决了线程安全问题。但从结果上看似乎只有一个线程在执行，其他的三个线程似乎没有什么用。线程这个现象不好解释，在网上查找了许多资料，统合得出结论，这个现象与电脑的cpu有关。 cpu与线程的关系 ​ 前面我们讲过，当有多个线程在操作时，如果系统只有一个CPU，则它根本不可能真正同时进行一个以上的线程，它只能把CPU运行时间划分成若干个时间段，再将时间段分配给各个线程执行，在一个时间段的线程代码运行时，其它线程处于挂起状态。 ​ 所以一个线程的执行，需要cpu为其分配时间段。若线程用完了cpu分配的时间时，线程的run()方法还没执行完，那么cpu将会重新为其分配时间；若线程在时间结束前，完成了run()方法，将结束线程，并把时间分给其他线程。 ​ 在run()方法中，若程序把线程任务放在一个循环中，如while循环，那么线程只有在cpu分配的时间结束时或线程把while循环的任务内容全部做完后的情况下才结束线程。若cpu的性能比较高，那么线程可能会在给定的时间内提前完成while循环的内容，从而出现了上述只有一个线程运行的情况。 图1 图2 ​ 当把循环次数扩大到1000时，该程序一开始由线程2执行，在售出第317张票时，由cpu分配给线程2的时间耗尽，线程2结束。而此时并没有运行完循环的内容，将交给下一个线程去继续执行。需要注意的是，cpu给线程分配的时间并不是固定的，所以有可能当while循环内的任务完成，线程还没结束。 注意：同步代码块中的锁对象可以是任意类型的对象，它可以是虚假的对象，以实例对象的变量形式存在，仅为了发挥锁的作用而存在，以上代码便是以这种方式实现多线程同步。它也可以是真实的，以当前的实例对象作为锁对象。**但无论是真实的还是虚假的对象，必须满足多个线程共享的锁对象必须是相同的。**所以锁对象的创建代码不能放到run()方法中，否则每个线程运行到run()方法都会创建一个新对象，这样每个线程都会有一个不同的锁，每个锁都有自己的标志位，线程之间便不能产生同步的效果。 同步方法 ​ 除了可以使用synchronized关键字将需要的代码设置为同步代码块外，还可以使用synchronized关键字来修饰某个方法，该方法称为同步方法，可以实现多个线程间的同步。 格式： 12345[访问控制符] [static|final] synchronized 返回类型 方法名(参数列表)&#123; //同步代码 [return 返回值]&#125; ​ 从以上的定义格式可以发现，同步方法可以分为非静态同步方法和静态同步方法。 非静态同步方法 ​ 在同步方法的定义格式中，并没有发现锁对象，那同步方法是如何实现”锁“的功能？其实，非静态同步方法的锁对象为”调用该方法的当前实例对象“，当线程调用同步方法时，它将自动获取该方法对象的内在锁，在该方法释放锁之前，该对象的其他线程都无法访问该对象的任何同步方法，但可以调用其他非同步方法。需要注意的是，非静态同步方法的作用范围为一个对象，对其他对象是不起作用的，其他对象的线程也能调用该方法。当然，其他对象调用该方法只能调用那个对象的数据资源，而不能调用该对象的数据资源。 代码示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Ticket implements Runnable&#123; private int ticket=10; public void run() &#123; while(ticket&gt;0) &#123; try //当前线程让出cpu运行权 &#123; Thread.sleep(10); &#125;catch(InterruptedException e) &#123; e.printStackTrace(); &#125; sale(); //调用同步方法 &#125; &#125; public synchronized void sale() &#123; try &#123; Thread.sleep(10); //模拟售票耗时过程 &#125;catch(InterruptedException e) &#123; e.printStackTrace(); &#125; if(ticket&gt;0) &#123; System.out.println(Thread.currentThread().getName()+&quot; 售出第&quot;+(ticket--)+&quot;张门票&quot;); &#125; &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; Ticket window1=new Ticket(); Ticket window2=new Ticket(); Thread t1=new Thread(window1,&quot;窗口1-资源1&quot;); Thread t2=new Thread(window1,&quot;窗口2-资源1&quot;); Thread t3=new Thread(window2,&quot;窗口3-资源2&quot;); Thread t4=new Thread(window2,&quot;窗口4-资源2&quot;); t1.start(); t2.start(); t3.start(); t4.start(); &#125;&#125; 运行结果： 1234567891011121314151617181920窗口4-资源2 售出第10张门票窗口1-资源1 售出第10张门票窗口2-资源1 售出第9张门票窗口3-资源2 售出第9张门票窗口4-资源2 售出第8张门票窗口1-资源1 售出第8张门票窗口3-资源2 售出第7张门票窗口2-资源1 售出第7张门票窗口1-资源1 售出第6张门票窗口4-资源2 售出第6张门票窗口3-资源2 售出第5张门票窗口2-资源1 售出第5张门票窗口4-资源2 售出第4张门票窗口1-资源1 售出第4张门票窗口3-资源2 售出第3张门票窗口2-资源1 售出第3张门票窗口1-资源1 售出第2张门票窗口4-资源2 售出第2张门票窗口3-资源2 售出第1张门票窗口2-资源1 售出第1张门票 ​ 以上程序，为了观察线程的同步情况，在调用同步方法前，使用了sleep()方法把运行权让出，以便所有线程都有机会执行任务。从程序运行结果上看，这四个线程都调用了同步方法sale()方法，其中，线程t1和线程t2使用同一个实例对象window1创建多线程，所以他们使用的资源相同。而线程t3和线程t4使用另一个实例对象window2创建多线程，所以他们使用的资源相同。两者之间的数据互不影响，所以非静态同步方法的作用范围为一个对象，在该对象范围内不会出现线程安全问题。 静态同步方法 ​ 与非静态同步方法不同的是，当调用一个静态同步方法时，该方法的锁对象并不是调用该方法的当前实例对象，而是当前实例对象对应的class对象，即类对象。该方法的作用范围为当前类对象所有实例对象，当一个线程调用了某个类的静态同步方法，其他线程都不能调用该类的其他静态同步方法，但是可以调用非静态同步方法，对该类的所有实例对象都起作用。 ​ 为什么静态同步方法锁定的对象为class对象呢？由于在调用静态方法时，对象实例不一定被创建，因此，就不能使用this来同步静态方法，而必须使用class对象来同步静态方法。 代码示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243class Demo&#123; private static int ticket=10; public static int getTicket() &#123; return ticket; &#125; public static synchronized void methodLock() &#123; if(ticket&gt;0) &#123; System.out.println(Thread.currentThread().getName()+&quot; 售出第&quot;+(ticket--)+&quot;张门票&quot;); &#125; &#125;&#125;public class Test implements Runnable&#123; public void run() &#123; while(Demo.getTicket()&gt;0) &#123; try //当前线程让出cpu运行权 &#123; Thread.sleep(10); &#125;catch(InterruptedException e) &#123; e.printStackTrace(); &#125; Demo.methodLock(); //直接通过类名调用静态同步方法 &#125; &#125; public static void main(String[] args) &#123; Test window1=new Test(); Test window2=new Test(); Thread t1=new Thread(window1,&quot;窗口1 &quot;); Thread t2=new Thread(window2,&quot;窗口2 &quot;); Thread t3=new Thread(window2,&quot;窗口3 &quot;); t1.start(); t2.start(); t3.start(); &#125;&#125; 运行结果： 12345678910窗口2 售出第10张门票窗口1 售出第9张门票窗口3 售出第8张门票窗口2 售出第7张门票窗口3 售出第6张门票窗口1 售出第5张门票窗口3 售出第4张门票窗口2 售出第3张门票窗口1 售出第2张门票窗口3 售出第1张门票 ​ 同上面一样，为了观察线程活动情况，在调用静态同步方法时，使用sleep()方法让出运行权。从程序结果可以发现，线程t1与线程t2、线程t3使用了不同对象创建线程，而线程t2与线程t3是同一个对象的多线程，但这三个线程共同实现了资源同步，没有出现售卖重票的问题。 对象锁与类锁 ​ 上述同步机制使用同步代码块、同步方法解决了线程安全问题，虽然结果一样，但他们的运行过程大不一样，最明显的区别是同步代码块或同步方法在实现同步时所引用的锁对象不尽相同。 1、对于同步方法块，锁对象是Synchronized括号里配置的对象 2、对于非静态同步方法，锁对象是当前实例对象。 3、对于静态同步方法，锁对象是当前对象的Class对象。 ​ 根据锁对象的引用不同可分为对象锁和类锁，其中情况1和情况2属于对象锁，情况3属于类锁。对象锁。。。算了，累了，先看连接吧，后面再整理。 传送门：面试官：请说一下对象锁和类锁的区别 - 风的姿态 - 博客园 (cnblogs.com) 同步锁 ​ synchronized同步代码块和同步方法使用一种封闭式的锁机制，使用起来非常简单，也能够解决线程同步过程中出现的线程安全问题，但也有一些限制，例如它无法中断一个正在等候获得锁的过程，也无法通过轮询得到锁，如果不想等下去，也就没法得锁。 ​ 从JDk1.5开始，java增加了一个功能更加强大的Lock锁。Lock锁与synchronized隐式锁在功能上基本相同，其最大的优势在于Lock锁可以让某个线程在持续获取同步锁失败后返回，不再继续等待，另外Lock锁在使用时也更加灵活。 ​ 其中，可通过java.util.concurrent.locks.ReentrantLock类的对象调用lock()方法来实现加锁操作，此时可以进行同步操作。同步操作结束后，调用unlock()方法释放同步锁。 代码示例： 123456789101112131415161718192021222324252627282930313233343536import java.util.concurrent.locks.*; //*为通配符，在后面讲解class Ticket implements Runnable&#123; private final ReentrantLock lock=new ReentrantLock(); //创建锁 private int ticket=10; public void run() &#123; while(ticket&gt;0) &#123; lock.lock(); //加锁 try &#123; Thread.sleep(10); &#125;catch(InterruptedException e) &#123; e.printStackTrace(); &#125; if(ticket&gt;0) &#123; System.out.println(Thread.currentThread().getName()+&quot; 售出第&quot;+(ticket--)+&quot;张门票&quot;); &#125; lock.unlock(); //释放锁 &#125; &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; Ticket window=new Ticket(); Thread t1=new Thread(window,&quot;窗口1&quot;); Thread t2=new Thread(window,&quot;窗口2&quot;); t1.start(); t2.start(); &#125;&#125; 运行结果： 12345678910窗口1 售出第10张门票窗口1 售出第9张门票窗口1 售出第8张门票窗口1 售出第7张门票窗口1 售出第6张门票窗口1 售出第5张门票窗口1 售出第4张门票窗口1 售出第3张门票窗口1 售出第2张门票窗口1 售出第1张门票 死锁 ​ 每当你有两个线程与两个带锁的对象时，你都可能遇到死锁，就是其中每个对象都在等待另一个对象上的锁。若对象x有一个同步方法调用了对象y上的一个同步方法，而对象y反过来有一个同步方法又调用了对象x上的一个同步方法，两个对象都在等待对方结束以获得锁，因而两者都无法进行。这种情况就是死锁，也可以叫做“死亡拥抱”(deadly embrace)。 代码实例： 123456789101112131415161718192021222324252627282930313233343536373839404142class Friendly implements Runnable&#123; private Friendly partner; //创建一个空的对象引用 private String name; public Friendly(String name) //构造方法 &#123; this.name=name; &#125; public void becomeFriend(Friendly partner) //与partner引用的对象绑定朋友关系 &#123; this.partner=partner; &#125; public synchronized void hug() &#123; System.out.println(name+&quot;中的线程&quot;+Thread.currentThread().getName()+&quot;试图调用&quot;+partner.name+&quot;的同步方法hugBack()&quot;); partner.hugBack(); &#125; private synchronized void hugBack() &#123; System.out.println(name+&quot;中的线程&quot;+Thread.currentThread().getName()+&quot;成功调用hugBack()方法&quot;); &#125; public void run() &#123; hug(); &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; final Friendly jonh=new Friendly(&quot;john&quot;); final Friendly ashley=new Friendly(&quot;ashley&quot;); jonh.becomeFriend(ashley); ashley.becomeFriend(jonh); Thread t1=new Thread(jonh,&quot;线程1&quot;); Thread t2=new Thread(ashley,&quot;线程2&quot;); t1.start(); t2.start(); &#125;&#125; 运行结果： 12john中的线程线程1试图调用ashley的同步方法hugBack()ashley中的线程线程2试图调用john的同步方法hugBack() ​ 以上程序，当jonh.hug调用同步方法ashley.hugback时，线程1进入阻塞，等待ashley上的锁(当前由线程2拥有)释放。同时，ashley.hug调用同步方法jonh.hugback时，线程1进入阻塞，等待jonh上的锁(当前由线程1拥有)释放。至此出现了死锁——在ashley上的锁释放之前jonh无法继续运行，反之亦然。这样两个线程陷入永久的死锁状态。 ​ 当然，如果够幸运的话，一个线程可能在另一个线程还没有启动的情况下已经完成整个hug。比如线程1在线程2获取ashley上的锁之前提前获得ashley上的锁完成hug与hugBack。但是同一应用程序的另一次运行可能会仅仅由于线程调度器的不同选择而造成死锁，有几种好的设计形式可以解决这个问题。最简单的就是不用synchronized关键字去修饰hug与hugBack方法，但使这两个方法在被所有Friendly对象共享的单个对象上同步。这种设计意味着在一个运行期的所有线程中，每次只能有一个“拥抱”发生，这样排除了死锁的可能性。 ​ 死锁的问题调试起来很麻烦，并且不能通过编译去检测出死锁，因此在设计阶段就尽量避免出现死锁的可能性。 参考链接： Java8 中文教程 - 内在锁和同步 | Docs4dev 详解Java多线程编程中的线程同步方法_java_脚本之家 (jb51.net) 如果一个对象有多个方法加了 synchronized，那么该对象有几把锁？ - 高行行 - 博客园 (cnblogs.com) 【Java多线程】了解线程的锁池和等待池概念_墩墩分墩-CSDN博客 Monitor机制介绍 - 知乎 (zhihu.com) synchronized同步方法\\块只有一个线程执行\\运行_Eiji_g的博客-CSDN博客 java中 synchronized同步处理后 为什么只有一个线程在运行呢？_百度知道 (baidu.com) 面试官：请说一下对象锁和类锁的区别 - 风的姿态 - 博客园 (cnblogs.com) 关于在synchronized块中使用Thread.sleep()的问题【java吧】_百度贴吧 (baidu.com) java多线程学习之——多线程中几种释放锁和不释放锁的操作 - 沐易笙 - 博客园 (cnblogs.com) 参考书目： 《国外经典计算机科学教材：Java编程语言(第3版)》【摘要 书评 试读】- 京东图书 (jd.com) 《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com) 《Java基础入门 第2版 黑马程序员 经典Java入门教材书籍》【摘要 书评 试读】- 京东图书 (jd.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"线程状态和线程操作方法","slug":"java/线程/线程状态","date":"2021-08-05T06:14:23.000Z","updated":"2021-10-27T04:47:56.116Z","comments":true,"path":"2021/08/05/java/线程/线程状态/","link":"","permalink":"https://silenthly.github.io/2021/08/05/java/%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/","excerpt":"​ 线程的状态是一个动态的概念，每一个线程都有产生、存在和消亡的过程。一个线程在其整个生命周期内可处于不同的状态。每一个java程序都有一个默认的主线程，而多线程则是在主线程执行过程中，建立起来的多个线程在同一时间段内执行。","text":"​ 线程的状态是一个动态的概念，每一个线程都有产生、存在和消亡的过程。一个线程在其整个生命周期内可处于不同的状态。每一个java程序都有一个默认的主线程，而多线程则是在主线程执行过程中，建立起来的多个线程在同一时间段内执行。 线程状态的概念 ​ 由于计算机的CPU处理速度非常快，所以当线程启动后，不能让其一直霸占着CPU独立运行。因此，CPU需要在多个线程之间切换。线程在其生命周期内有多种状态，包括新建状态(New) 、就绪状态(Runnable)、运行状态(Running)、阻塞状态(Blocked) 和死亡状态(Dead) 。线程的装换图如下图所示。 （1）新建状态 ​ 使用Thread类的构造方法新建一个线程对象，此时新的线程对象便处于新建状态。它已经有了相应的内存空间和其他资源，但还是处于不可运行状态。线程的生命周期就是从新建状态开始的。 （2）就绪状态 ​ 新建线程对象后，调用该线程的start()方法时，线程就进入就绪状态。此时，java虚拟机就会为它创建方法调用栈和程序计数器。注意，此时线程并没有进入运行状态，只是处于这个状态的线程位于可运行池中，等待CPU的使用权，这表明了他已经具备了运行条件。 （3）运行状态 ​ 当就绪状态的线程被调用并获得JVM为其分配的CPU时，程序就进入运行状态，此时，该线程自动执行run()方法里定义的操作和功能。 （4）阻塞状态 ​ 阻塞状态是指线程因为某些原因放弃CPU，暂时停止运行，进入堵塞状态，如被人为挂起或要执行耗时的输入/输出操作。线程在运行状态下，如果调用sleep()、suspend()或wait()等方法，线程都将进入堵塞状态。当线程处于阻塞状态时，JVM不会为其分配CPU，必须等到该线程重新回到就绪状态后，JVM才有可能为其分配CPU，让它进入运行状态。阻塞的情况分三种： a、 等待阻塞。通过调用线程的wait()方法，让线程等待某工作的完成。 b、 同步阻塞。线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态。 c、 其他阻塞。通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态 （5）死亡状态 ​ 线程进入死亡状态的情况主要分两种，线程的run()方法执行完毕并退出或线程运行过程中产生异常。前者属于线程的正常死亡，而后者是线程的非正常死亡。处于死亡状态的线程不具有继续运行的能力，即使该线程对象是“活”的，但是其已经不是一个可执行的线程。程序员可以显示将其置为null，等待java垃圾回收器回收。 ​ 线程状态转换方法在下面介绍。 线程操作的相关方法 ​ 前面介绍过创建多线程程序有两种方法，虽然实现多线程一般都使用Runnable接口，但是操作线程的主要方法并不在Runnable接口内，而是在Thread类中。 ​ 无论是采用implements Runnable’还是使用extends Thread的方式，实际上都是以Thread类实现线程程序。下面介绍Thread类的常用方法。 序号 方法 类型 说明 1 public Thread() 构造 创建新的Thread对象 2 public Thread(Runnable target) 构造 创建新的Thread对象，并使用taget指定Runnable对象的run()实现 3 public Thread(String name) 构造 创建新的Thread对象，并以name参数为此Thread对象设定名称 4 public Thread(Runnable target,String name) 构造 创建新的Thread对象，使用target指定Runnable对象的run()实现，并以name参数为此Thread对象设定名称 5 public static int activeCount() 静态 返回当前线程的线程组中活动线程的数目 6 public void checkAccess() 普通 判断当前运行的线程是否有权修改该线程 7 public static Thread currentThread() 静态 返回对当前正在执行的线程对象的引用 8 public static int enumerate(Thread[] tarray) 静态 将当前线程的线程组及其子组中的每一个活动线程复制到指定的数组tarray中 9 public long getId() 普通 返回当前线程的标识符 10 public final String getName() 普通 返回当前线程的名称 11 public final int getPriority() 普通 返回当前线程的优先级 12 public Thread.State getState() 普通 返回当前线程的状态 13 public final ThreadGroup getThreadGroup() 普通 返回当前线程所属的线程组 14 public static boolean holdsLock(Object obj) 静态 判断当前线程是否拥有obj参数指定的对象监视锁。若有，则返回true，否则返回false(该方法与线程同步相关) 15 public void interrupt() 普通 中断当前线程 16 public static boolean interrupted() 静态 判断执行中的线程是否已被中断，若是，则返回true，否则返回false 17 public final boolean isAlive() 普通 判断当前线程是否处于激活状态，若是，则返回true，否则返回false 18 public final boolean isDaemon() 普通 判断当前线程是否为守护线程，若是，则返回true，否则返回false 19 public final boolean isInterruptde() 普通 判断当前线程是否已被中断，若是，则返回true，否则返回false 20 public final void join()throws InterruptedException 普通 当前线程暂停执行，等待调用该方法的线程终止，才能继续执行当前线程 21 public final void join(long millis)throws InterruptedException 普通 与前者相似，但等待该线程终止的时间最长为millis毫秒 22 public void join(long millis,int nanos)throws InterruptedException 普通 与前者相似，等待该线程终止的时间最长为millis毫秒+nanos纳秒，时间精度更高 23 public void run() 普通 如果该线程构造使用独立的Runnable运行对象，则调用该Runnable对象的run()方法，否则，该方法不执行任何操作 24 public final void setDaemon(boolean on) 普通 将当前线程标记为守护线程或用户线程 25 public final void setName(String name) 普通 设置线程名称 26 public final void setPriority(int newPriority) 普通 更改线程的优先级 27 public static void sleep(long millis)throws InterruptedException 静态 在指定的毫秒数内让当前正在执行的线程休眠(暂停执行) 28 public static void sleep(long millis,int nanos)throws InterruptedException 静态 在指定的毫秒数加指定的纳秒数内让当前正在执行的线程休眠(暂停执行) 29 public void start() 普通 是该线程开始执行，JVM调用该线程的run方法。但此线程已启动且仍然存活，若再使用该方法将引发异常 30 public String toString() 普通 返回该线程的字符串表示形式，包括线程名称、优先级和线程组 31 public static void yield() 静态 暂停当前正在执行的线程对象，并让其他线程有机会执行 获取并设置线程名称 ​ Thread类的getName()和setName()方法在前面已经多次使用了。如果在创建线程时，没有显式地为其设置名称，系统就会自动地为其分配一个名称，一般格式为：Thread-n(n表示从0开始的整数) 代码示例： 12345678910111213141516171819202122232425class ThreadDemo implements Runnable&#123; public void run() &#123; for(int i=1;i&lt;=5;i++) &#123; System.out.println(&quot;当前运行线程：&quot;+Thread.currentThread().getName()+&quot;,i=&quot;+i+&quot;，活动线程的数目：&quot;+Thread.activeCount()); &#125; &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; ThreadDemo tm=new ThreadDemo(); Thread t1=new Thread(tm); Thread t2=new Thread(tm,&quot;线程-1&quot;); Thread t3=new Thread(tm); t3.setName(&quot;线程-2&quot;); System.out.println(&quot;当前活动线程的数目：&quot;+Thread.activeCount()); t1.start(); t2.start(); t3.start(); &#125;&#125; 运行结果： 12345678910111213141516当前活动线程的数目：1当前运行线程：Thread-0,i=1，活动线程的数目：4当前运行线程：Thread-0,i=2，活动线程的数目：4当前运行线程：线程-2,i=1，活动线程的数目：4当前运行线程：线程-2,i=2，活动线程的数目：4当前运行线程：线程-2,i=3，活动线程的数目：4当前运行线程：线程-2,i=4，活动线程的数目：4当前运行线程：线程-2,i=5，活动线程的数目：4当前运行线程：线程-1,i=1，活动线程的数目：4当前运行线程：Thread-0,i=3，活动线程的数目：4当前运行线程：线程-1,i=2，活动线程的数目：3当前运行线程：Thread-0,i=4，活动线程的数目：3当前运行线程：Thread-0,i=5，活动线程的数目：3当前运行线程：线程-1,i=3，活动线程的数目：3当前运行线程：线程-1,i=4，活动线程的数目：2当前运行线程：线程-1,i=5，活动线程的数目：2 ​ 从程序运行结果可以看出，在多线程没启动前，线程组中只有一个线程在运行，这个线程就是主线程main()。 线程的优先级 ​ 在java中每个线程都有其优先级，优先级的取值范围为1~10，默认为5。可以使用Thread类中的setPriority()方法设置一个线程的优先级，但必须在1~10范围内，否则会产生异常。在java的线程中一个有3种优先级。如下表所示。 序号 定义 说明 表示常量 1 public static final int MIN_PRIORITY 线程可以具有的最低优先级 1 2 public static final int NORM_PRIORITY 分配给线程的默认优先级 5 3 public static final int MAX_PRIORITY 线程可以具有的最高优先级 10 代码示例： 1234567891011121314151617181920212223242526272829class ThreadDemo implements Runnable&#123; public void run() &#123; for(int i=1;i&lt;=5;i++) &#123; System.out.println(&quot;当前运行线程：&quot;+Thread.currentThread().getName()+&quot;,i=&quot;+i); &#125; &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; ThreadDemo tm=new ThreadDemo(); Thread t1=new Thread(tm,&quot;线程-1&quot;); Thread t2=new Thread(tm,&quot;线程-2&quot;); Thread t3=new Thread(tm,&quot;线程-3&quot;); Thread t4=new Thread(tm,&quot;线程-4&quot;); t1.setPriority(Thread.MIN_PRIORITY); t2.setPriority(2); t3.setPriority(Thread.NORM_PRIORITY); t4.setPriority(Thread.MAX_PRIORITY); t1.start(); t2.start(); t3.start(); t4.start(); &#125;&#125; 运行结果： 1234567891011121314151617181920当前运行线程：线程-4,i=1当前运行线程：线程-3,i=1当前运行线程：线程-1,i=1当前运行线程：线程-2,i=1当前运行线程：线程-2,i=2当前运行线程：线程-2,i=3当前运行线程：线程-2,i=4当前运行线程：线程-2,i=5当前运行线程：线程-1,i=2当前运行线程：线程-1,i=3当前运行线程：线程-3,i=2当前运行线程：线程-4,i=2当前运行线程：线程-3,i=3当前运行线程：线程-3,i=4当前运行线程：线程-3,i=5当前运行线程：线程-1,i=4当前运行线程：线程-4,i=3当前运行线程：线程-1,i=5当前运行线程：线程-4,i=4当前运行线程：线程-4,i=5 ​ 从运行结果可以发现，线程的优先级决定了线程获得CPU的优先权，也就是运行的优先权。需要注意的是，优先级高的线程只是优先获得CPU，不是绝对获得CPU。主线程的优先级为5。 让线程休眠 ​ 线程休眠是指线程暂时处于阻塞状态，就是说线程停止运行。当一个程序在执行sleep()方法后，它就会放弃CPU，转到阻塞状态。sleep()方法是Thread类中的静态方法，有两种重载形式。 代码示例： 12345678910111213141516171819202122232425262728293031import java.util.Date;class ThreadDemo implements Runnable&#123; public void run() &#123; for(int i=1;i&lt;=5;i++) &#123; System.out.println(&quot;当前运行线程：&quot;+Thread.currentThread().getName()+&quot;,i=&quot;+i+&quot;时间：&quot;+(new Date())); try &#123; Thread.sleep(1000); //线程休眠1s &#125;catch(InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; ThreadDemo tm=new ThreadDemo(); Thread t1=new Thread(tm,&quot;线程-1&quot;); Thread t2=new Thread(tm,&quot;线程-2&quot;); Thread t3=new Thread(tm,&quot;线程-3&quot;); t1.start(); t2.start(); t3.start(); &#125;&#125; 运行结果： 123456789101112131415当前运行线程：线程-1,i=1时间：Thu Aug 05 08:08:31 CST 2021当前运行线程：线程-3,i=1时间：Thu Aug 05 08:08:31 CST 2021当前运行线程：线程-2,i=1时间：Thu Aug 05 08:08:31 CST 2021当前运行线程：线程-1,i=2时间：Thu Aug 05 08:08:32 CST 2021当前运行线程：线程-3,i=2时间：Thu Aug 05 08:08:32 CST 2021当前运行线程：线程-2,i=2时间：Thu Aug 05 08:08:32 CST 2021当前运行线程：线程-1,i=3时间：Thu Aug 05 08:08:33 CST 2021当前运行线程：线程-3,i=3时间：Thu Aug 05 08:08:33 CST 2021当前运行线程：线程-2,i=3时间：Thu Aug 05 08:08:33 CST 2021当前运行线程：线程-1,i=4时间：Thu Aug 05 08:08:34 CST 2021当前运行线程：线程-3,i=4时间：Thu Aug 05 08:08:34 CST 2021当前运行线程：线程-2,i=4时间：Thu Aug 05 08:08:34 CST 2021当前运行线程：线程-1,i=5时间：Thu Aug 05 08:08:35 CST 2021当前运行线程：线程-2,i=5时间：Thu Aug 05 08:08:35 CST 2021当前运行线程：线程-3,i=5时间：Thu Aug 05 08:08:35 CST 2021 ​ 以上程序在运行时，每一次输出的间隔都在1000ms，说明线程休眠了1000ms。 使用sleep()注意事项 1、当线程休眠结束后，该线程并不会立即进入运行状态，而是进入就绪状态，等待JVM为其分配CPU。 2、当线程处于休眠状态时，如果该线程被中断，则会抛出InterruptedException异常。中断线程可以使用interrupt()方法。 3、sleep()是静态方法。在主方法内，无论是通过线程对象t去调用sleep()还是直接通过Thread.sleep()形式去调用sleep()方法，都是休眠主线程。若想要线程实例休眠，sleep()方法应该放在run()内。 线程的唤醒 ​ 线程的唤醒是指使线程从休眠的阻塞状态转换为运行状态，可以通过Thread类的interrupt()方法实现。 代码示例： 123456789101112131415161718192021222324252627282930313233import java.util.Date;class ThreadDemo implements Runnable&#123; public void run() &#123; System.out.println(&quot;开始运行run()方法的时刻：&quot;+(new Date())); try &#123; Thread.sleep(5000); //线程休眠 &#125;catch(Exception e) &#123; System.out.println(&quot;线程已被唤醒&quot;); &#125; System.out.println(&quot;结束运行run()方法的时刻：&quot;+(new Date())); &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; ThreadDemo tm=new ThreadDemo(); Thread t1=new Thread(tm,&quot;线程-1&quot;); t1.start(); try &#123; t1.sleep(2000); &#125;catch(Exception e) &#123; e.printStackTrace(); &#125; t1.interrupt(); //唤醒线程 &#125;&#125; 运行结果： 123开始运行run()方法的时刻：Thu Aug 05 09:13:18 CST 2021线程已被唤醒结束运行run()方法的时刻：Thu Aug 05 09:13:20 CST 2021 ​ 从程序的运行结果可以发现，t1线程启动后立即进入休眠，原本需要5000ms，但是主线程启动后两秒就将其中断。前面说过，将休眠的线程唤醒会抛出异常，所以会执行run()方法中catch语句块的内容。 判断线程是否中断的两个方法 1、isInterrupted()：这是一个实例方法，用于判断当前线程是否已被中断。若是，则返回true，否则返回false。线程中的中断状态不受该方法影响。 2、interrupted()：这是一个静态方法，用于判断执行中的线程是否已被中断。若是，则返回true，否则返回false。调用此方法后，线程的中断状态将被消除，即处于中断状态的线程将变为非中断状态。 后台线程 ​ 后台线程是指在后台执行的服务线程，后台线程也可以称为守护线程。JVM的垃圾回收线程就是经典的后台线程。后台线程的任务就是为其他线程提供服务，仅当所有的非后台线程都结束时，后台线程才会结束。可以使用Thread类的setDaemon()方法将一个线程设置为后台线程。 ​ 若要将一个线程设置为后台线程，则必须在该线程启动之前调用setDaemon()方法。设置后台线程后，还可以通过isDaemon()方法判断该线程是否已成为后台线程。 代码示例： 12345678910111213141516171819202122232425class ThreadDemo implements Runnable&#123; public void run() &#123; int i=0; while(true) &#123; System.out.println(&quot;i=&quot;+i++); &#125; &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; ThreadDemo tm=new ThreadDemo(); Thread t1=new Thread(tm,&quot;线程-1&quot;); t1.setDaemon(true); if(t1.isDaemon()) &#123; t1.start(); &#125; System.out.println(&quot;当前线程存活数：&quot;+Thread.activeCount()); &#125;&#125; ​ 以上程序中，若t1不为后台线程，run()方法就是死循环。但将t1设置为后台程序，在非后台线程结束后，后台线程t1也将结束。 线程礼让 ​ 线程礼让是指当前正在运行的线程退出运行状态，暂时让其他线程先执行，可以通过Thread()类的yield()方法来实现，该方法只能把运行权让出来，不能让给指定的线程。 ​ yield()的作用是让步，它能够让当前线程从“运行状态”进入到“就绪状态”，从而让其他等待线程获取执行权，但是不能保证在当前线程调用yield()之后，其他线程就一定能获得执行权，也有可能是当前线程又回到“运行状态”继续运行。注意：这里将上面的“具有相同优先级”的线程直接改为了线程，很多资料都写的是让具有相同优先级的线程开始竞争，但其实不是这样的，优先级低的线程在拿到CPU执行权后也是可以执行，只不过优先级高的线程拿到CPU执行权的概率比较大而已，并不是一定能拿到。 代码示例： 123456789101112131415161718192021222324252627282930313233class ThreadDemo implements Runnable&#123; public void run() &#123; for(int i=1;i&lt;=10;i++) &#123; System.out.println(&quot;当前运行线程：&quot;+Thread.currentThread().getName()+&quot;,i=&quot;+i); Thread.currentThread().yield(); &#125; &#125;&#125;class ThreadDemo1 implements Runnable&#123; public void run() &#123; for(int i=1;i&lt;=10;i++) &#123; System.out.println(&quot;当前运行线程：&quot;+Thread.currentThread().getName()+&quot;,i=&quot;+i); &#125; &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; ThreadDemo tm1=new ThreadDemo(); ThreadDemo1 tm2=new ThreadDemo1(); Thread t1=new Thread(tm1,&quot;线程-1&quot;); Thread t2=new Thread(tm2,&quot;线程-2&quot;); t1.start(); t2.start(); &#125;&#125; 运行结果： 1234567891011121314151617181920当前运行线程：线程-1,i=1当前运行线程：线程-2,i=1当前运行线程：线程-1,i=2当前运行线程：线程-2,i=2当前运行线程：线程-2,i=3当前运行线程：线程-2,i=4当前运行线程：线程-2,i=5当前运行线程：线程-2,i=6当前运行线程：线程-2,i=7当前运行线程：线程-2,i=8当前运行线程：线程-2,i=9当前运行线程：线程-1,i=3当前运行线程：线程-1,i=4当前运行线程：线程-1,i=5当前运行线程：线程-2,i=10当前运行线程：线程-1,i=6当前运行线程：线程-1,i=7当前运行线程：线程-1,i=8当前运行线程：线程-1,i=9当前运行线程：线程-1,i=10 ​ 从程序运行结果可以发现，t1线程比t2线程运行的几率要小，因为t1总是让其他线程先执行。 sleep()和yield()的区别 sleep()和yield()都可以让出运行权，但它们还是有很大的不同 1、sleep()方法让出运行权时，在暂停运行直到结束之前不参与竞争，不考虑其他线程的优先级。而yield()方法只是将运行权让出，但仍与其他不同优先级的线程进行竞争。 2、调用sleep()方法会让当前线程转到阻塞状态。而调用yield()方法则将当前线程转到就绪状态。 3、sleep()方法声明抛出InterruptedException异常，而yield()方法不抛出异常。 4、sleep()方法比yield()方法具有更好的移植性，不能依靠yield()方法来提高程序的并发性。 线程插队 ​ 现实生活中经常能碰到“插队”的情况，同样，在Thread类中也提供了一个join()方法来实现这个功能。当在某个线程中调用其他线程的join()方法时，调用的线程将会被阻塞。直到被join()方法加入的线程执行完成后他才会继续运行。比如在线程B中调用了线程A的Join()方法，直到线程A执行完毕后，才会继续执行线程B。 代码示例： 123456789101112131415161718192021222324252627282930313233class ThreadDemo implements Runnable&#123; public void run() &#123; for(int i=1;i&lt;=5;i++) &#123; System.out.println(&quot;当前运行线程：&quot;+Thread.currentThread().getName()+&quot;,i=&quot;+i); &#125; &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; ThreadDemo tm=new ThreadDemo(); Thread t1=new Thread(tm,&quot;线程-1&quot;); t1.start(); try &#123; for(int i=1;i&lt;=5;i++) &#123; System.out.println(&quot;当前运行线程：&quot;+Thread.currentThread().getName()+&quot;,i=&quot;+i); if(i==2) &#123; t1.join(); &#125; &#125; &#125;catch(InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 运行结果： 12345678910当前运行线程：main,i=1当前运行线程：线程-1,i=1当前运行线程：main,i=2当前运行线程：线程-1,i=2当前运行线程：线程-1,i=3当前运行线程：线程-1,i=4当前运行线程：线程-1,i=5当前运行线程：main,i=3当前运行线程：main,i=4当前运行线程：main,i=5 ​ 从程序结果可以看出，在mian线程中的循环变量为2前，main线程与t1线程会互相争夺cpu使用权。而当mian线程中的循环变量为2时，调用t1线程的join()方法，这时，t1线程就会“插队”优先执行，并且整个线程执行完毕后才会执行其他线程。 ​ Thread类中除了提供一个无参数的线程插队join()方法外，还提供了两个带有时间参数的线程插队方法，可前往前面表格查看或者前往API帮助文档查看。join()方法是通过wait()实现的，[点击此处进行了解](Java中join()方法的理解 - 天涯海角路 - 博客园 (cnblogs.com)) 参考链接： Java线程状态以及 sheep（）、wait()、yield() 的区别_Java笔记-CSDN博客 JAVA 线程状态及转化 - Happy-Coder - 博客园 (cnblogs.com) Java守护线程和main线程整理_贝西晨的博客-CSDN博客 启动一个最简单的Java main程序时，有多少个线程被创建_Gabriel576282253的专栏-CSDN博客 守护线程与普通线程 - jason.bai - 博客园 (cnblogs.com) Java中join()方法的理解 - 天涯海角路 - 博客园 (cnblogs.com) 参考书目： 《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com) 《Java基础入门 第2版 黑马程序员 经典Java入门教材书籍》【摘要 书评 试读】- 京东图书 (jd.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"线程的创建","slug":"java/线程/线程的创建","date":"2021-08-04T03:45:46.000Z","updated":"2021-10-27T04:48:01.425Z","comments":true,"path":"2021/08/04/java/线程/线程的创建/","link":"","permalink":"https://silenthly.github.io/2021/08/04/java/%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA/","excerpt":"​ java程序中的线程被设计为一个对象，但不是每一个对象都是线程，只有实现了Runnable接口的类才能称为线程，也就是说，创建线程必须使用“实现Runnable接口的类创建的对象”。java语言提供了两种途径实现多线程，一种是继承Thread类(该类已实现Runnable接口)，另一种是直接实现Runnable接口。下面分别介绍这两种途径的使用及其区别。","text":"​ java程序中的线程被设计为一个对象，但不是每一个对象都是线程，只有实现了Runnable接口的类才能称为线程，也就是说，创建线程必须使用“实现Runnable接口的类创建的对象”。java语言提供了两种途径实现多线程，一种是继承Thread类(该类已实现Runnable接口)，另一种是直接实现Runnable接口。下面分别介绍这两种途径的使用及其区别。 通过继承Thread类创建线程 ​ Thread类属于java.lang包，系统在运行时会自动导入，所以不需要使用import关键字显式导入Thread类。 Thread类的定义： 1public class Thread extends Object implemments Runnable ​ 可以发现Thread类已经实现了Runnable接口，所以只要让一个类继承Thread类，并将线程的程序代码写在run()方法内，即重写Thread类的run()方法即可创建线程。 多线程的定义格式： 1234567[public] class 类名 extends Thread //继承Thread类&#123; //属性； //方法 public void run() //重写Thread类的run()方法 &#123;...&#125;&#125; ​ 注意，Thread只是创建了一个线程，而创建线程需要一个实现Runnable接口的类创建的对象，子类继承Thread类实际上已经间接实现了Runnable接口，通过该子类创建的实例，实质是包含了一个对象的线程。 Thread类创建多线程类 1234567891011121314151617181920212223public class Test extends Thread&#123; private String name; public Test()&#123;&#125; public Test(String name) &#123; setName(name); //调用Thread类中的setName()方法 &#125; public void run() &#123; for(int i=1;i&lt;=10;i++) &#123; System.out.println(&quot;当前运行的线程&quot;+getName()+&quot;,i=&quot;+i); //输出当前运行的线程 &#125; &#125; public static void main(String[] args) &#123; Test t1=new Test(&quot;线程-1&quot;); //创建线程t1 Test t2=new Test(&quot;线程-2&quot;); //创建线程t2 t1.start(); //启动线程t1 t2.start(); //启动线程t2 &#125;&#125; 运行结果：（其中一种运行结果，以上程序每次运行结果可能不同，这是正常现象） 1234567891011121314151617181920当前运行的线程线程-1,i=1当前运行的线程线程-1,i=2当前运行的线程线程-2,i=1当前运行的线程线程-2,i=2当前运行的线程线程-1,i=3当前运行的线程线程-2,i=3当前运行的线程线程-1,i=4当前运行的线程线程-2,i=4当前运行的线程线程-2,i=5当前运行的线程线程-2,i=6当前运行的线程线程-1,i=5当前运行的线程线程-2,i=7当前运行的线程线程-1,i=6当前运行的线程线程-2,i=8当前运行的线程线程-1,i=7当前运行的线程线程-2,i=9当前运行的线程线程-1,i=8当前运行的线程线程-2,i=10当前运行的线程线程-1,i=9当前运行的线程线程-1,i=10 ​ 从程序的运行结果可以发现，“线程-1”和“线程-2”是交替运行的，也就是说程序是采用了多线程机制运行了。在Test类中没有定义setName()和getName()方法，是因为Thread类中已经定义了final类型的的setName()和getName()方法，所以子类Test不能冲洗定义这些方法，直接使用即可。 ​ 还可以发现Test类中并没有调用run()方法，而是调用了start()方法，这是为什么呢？run()方法是线程需要执行的内容，但是启动线程并不是直接调用run()方法，而是调用start()方法。Thread类中的start()方法用于启动一个线程，并在该线程上运行Thread类对象的run()方法。通过start()方法启动线程，是因为线程的运行需要本机操作系统的支持。 注意：一个线程对象只能调用一次start()方法，若多次调用将会抛出&quot;IllegalThreadStateException&quot;异常。 通过实现Runnable接口创建线程 ​ 一般情况下，实现多线程都可以通过Runnable接口来实现。 Runnable接口的定义： 1234public interface Runnable&#123; public abstract void run();&#125; ​ 可以发现，Runnable接口中仅仅提供了一个抽象方法run()。 多线程的定义格式： 1234567[public] class 类名 implements Runnable //实现Runnable接口&#123; //属性； //方法 public void run() //实现Runnable接口的run()方法 &#123;...&#125;&#125; Runnable接口创建多线程 123456789101112131415161718192021222324252627282930313233public class Test implements Runnable&#123; private String name; public Test()&#123;&#125; public Test(String name) &#123; setName(name); &#125; public void setName(String name) &#123; this.name=name; &#125; public String getName() &#123; return name; &#125; public void run() &#123; for(int i=1;i&lt;=10;i++) &#123; System.out.println(&quot;当前运行的线程&quot;+getName()+&quot;,i=&quot;+i); //输出当前运行的线程 &#125; &#125; public static void main(String[] args) &#123; Test r1=new Test(&quot;线程-1&quot;); //创建对象r1 Test r2=new Test(&quot;线程-2&quot;); Thread t1=new Thread(r1); //以对象r1创建线程 Thread t2=new Thread(r2); t1.start(); //启动线程t1 t2.start(); //启动线程t2 &#125;&#125; 运行结果： 1234567891011121314151617181920当前运行的线程线程-1,i=1当前运行的线程线程-1,i=2当前运行的线程线程-1,i=3当前运行的线程线程-1,i=4当前运行的线程线程-1,i=5当前运行的线程线程-2,i=1当前运行的线程线程-2,i=2当前运行的线程线程-2,i=3当前运行的线程线程-2,i=4当前运行的线程线程-2,i=5当前运行的线程线程-2,i=6当前运行的线程线程-2,i=7当前运行的线程线程-2,i=8当前运行的线程线程-2,i=9当前运行的线程线程-2,i=10当前运行的线程线程-1,i=6当前运行的线程线程-1,i=7当前运行的线程线程-1,i=8当前运行的线程线程-1,i=9当前运行的线程线程-1,i=10 ​ 由于Runnable接口对线程没有任何支持，因此在获得线程实例后，必须通过Thread类的构造方法来实现。 java主线程——main() ​ 一个java应用程序的主类main()方法是它的主线程。当java程序启动时，一个主线程自动的被创建并运行。执行的进入点是main()方法，可以将其视为主线程的run()方法。 ​ 由于主线程是自动建立的，因此很容易忽略它是线程的事实，但我们不能忽略。主线程是产生应用程序所有其他线程的线程，就是说，程序中只要有其他非守护线程尚未结束，主线程就不会结束，即使main()方法中使用了return语句或main()方法的内容已执行结束也是一样的。 ​ 在Thread类中定义了一个类方法currentThread()，程序员可利用该方法获取主线程对象引用。借此可以对主线程做各种控制处理，因为主线程也是一个对象。 代码示例： 12345678910111213141516171819202122public class Test implements Runnable&#123; public void run() &#123; for(int i=1;i&lt;=10;i++) &#123; System.out.println(&quot;当前运行的线程：&quot;+Thread.currentThread()+&quot;,i=&quot;+i); //输出当前运行的线程 &#125; &#125; public static void main(String[] args) &#123; Thread mt=Thread.currentThread(); //获取主线程 System.out.println(&quot;线程信息：&quot;+mt); System.out.println(&quot;线程名称：&quot;+mt.getName()); mt.setName(&quot;主线程&quot;); //设置主线程名称 System.out.println(&quot;线程名称：&quot;+mt.getName()); Test mtThread=new Test(); Thread t=new Thread(mtThread); t.start(); mtThread.run(); //直接调用run方法 &#125;&#125; 运行结果： 1234567891011121314151617181920当前运行的线程：Thread[主线程,5,main],i=1当前运行的线程：Thread[主线程,5,main],i=2当前运行的线程：Thread[主线程,5,main],i=3当前运行的线程：Thread[Thread-0,5,main],i=1当前运行的线程：Thread[主线程,5,main],i=4当前运行的线程：Thread[Thread-0,5,main],i=2当前运行的线程：Thread[主线程,5,main],i=5当前运行的线程：Thread[主线程,5,main],i=6当前运行的线程：Thread[主线程,5,main],i=7当前运行的线程：Thread[主线程,5,main],i=8当前运行的线程：Thread[主线程,5,main],i=9当前运行的线程：Thread[主线程,5,main],i=10当前运行的线程：Thread[Thread-0,5,main],i=3当前运行的线程：Thread[Thread-0,5,main],i=4当前运行的线程：Thread[Thread-0,5,main],i=5当前运行的线程：Thread[Thread-0,5,main],i=6当前运行的线程：Thread[Thread-0,5,main],i=7当前运行的线程：Thread[Thread-0,5,main],i=8当前运行的线程：Thread[Thread-0,5,main],i=9当前运行的线程：Thread[Thread-0,5,main],i=10 ​ 从程序运行结果可以发现，默认情况下主线程的名称为main，优先级为5。所以说，一个java程序运行至少会启动两个线程，一个是JVm的垃圾收集线程，一个是主线程。 比价继承Thread类和实现Runnable接口 ​ 继承Thread类和实现Runnable接口都可以实现多线程，但是在一般情况下都会选择后者。与继承Thread类相比，实现Runnable接口有以下好处： （1）可以避免由于java单继承特性带来的局限。一个java类继承继承一个类，但是可以实现多个接口。 （2）适合多个相同程序代码的线程去处理同一资源的情况，有利于程序的健壮性。把线程相同程序的代码、数据有效分离，代码能够被多个线程共享，代码与数据是独立的。可以让多个线程共享一个实例的数据，因为通过Runnable接口实现多线程，可以通过一个对象实例创建多个线程。 案例讲解： ​ 某电影院有两个售票窗口发售某影片的门票，假设VIP门票只有10张，下面编写一个售票系统，每个窗口用一个线程表示。 Thread类设计系统 123456789101112131415161718192021222324252627class Ticket extends Thread&#123; private int ticket=10; private String name; public Ticket()&#123;&#125; public Ticket(String name) &#123; setName(name); &#125; public void run() &#123; while(ticket&gt;0) &#123; System.out.println(Thread.currentThread().getName()+&quot;卖出第&quot;+(ticket--)+&quot;张门票...&quot;); &#125; &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; Ticket window1=new Ticket(&quot;第一窗口&quot;); //创建线程window1 Ticket window2=new Ticket(&quot;第二窗口&quot;); window1.start(); window2.start(); &#125;&#125; 运行结果： 1234567891011121314151617181920第一窗口卖出第10张门票...第一窗口卖出第9张门票...第二窗口卖出第10张门票...第一窗口卖出第8张门票...第二窗口卖出第9张门票...第二窗口卖出第8张门票...第二窗口卖出第7张门票...第二窗口卖出第6张门票...第二窗口卖出第5张门票...第二窗口卖出第4张门票...第二窗口卖出第3张门票...第二窗口卖出第2张门票...第二窗口卖出第1张门票...第一窗口卖出第7张门票...第一窗口卖出第6张门票...第一窗口卖出第5张门票...第一窗口卖出第4张门票...第一窗口卖出第3张门票...第一窗口卖出第2张门票...第一窗口卖出第1张门票... ​ 以上程序通过继承Thread类实现了多线程，程序中启动了两个程序，但是这两个线程却分别卖出了各自的10张门票，没有达到预期资源共享的目的。 Runnable接口设计系统 12345678910111213141516171819202122232425262728class Ticket extends Thread&#123; private int ticket=10; private String name; public Ticket()&#123;&#125; public Ticket(String name) &#123; setName(name); &#125; public void run() &#123; while(ticket&gt;0) &#123; System.out.println(Thread.currentThread().getName()+&quot;卖出第&quot;+(ticket--)+&quot;张门票...&quot;); &#125; &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; Ticket window=new Ticket(); Thread window1=new Thread(window,&quot;第一窗口&quot;); //以对象window创建线程window1 Thread window2=new Thread(window,&quot;第二窗口&quot;); //以对象window创建线程window2 window1.start(); window2.start(); &#125;&#125; 运行结果： 12345678910第二窗口卖出第10张门票...第二窗口卖出第8张门票...第二窗口卖出第7张门票...第一窗口卖出第9张门票...第一窗口卖出第5张门票...第二窗口卖出第6张门票...第二窗口卖出第3张门票...第二窗口卖出第2张门票...第二窗口卖出第1张门票...第一窗口卖出第4张门票... ​ 上面程序创建了两个线程，每一个线程都是调用同一个Ticket类中的run()方法，访问的是同一个对象(window)的变量ticket的实例。通过Runnable接口可以实现多线程可以满足资源共享，达到预期目的。 static实现数据共享 ​ 也可以使用static变量达到数据共享的目的。在前面讲过static成员是类中的所有实例共享的，因此可以通过static变量达到共享数据的目的。 123456789101112131415161718192021222324252627class Ticket extends Thread&#123; private static int ticket=10; private String name; public Ticket()&#123;&#125; public Ticket(String name) &#123; setName(name); &#125; public void run() &#123; while(ticket&gt;0) &#123; System.out.println(Thread.currentThread().getName()+&quot;卖出第&quot;+(ticket--)+&quot;张门票...&quot;); &#125; &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; Ticket window1=new Ticket(&quot;第一窗口&quot;); Ticket window2=new Ticket(&quot;第二窗口&quot;); window1.start(); window2.start(); &#125;&#125; 运行结果： 12345678910第二窗口卖出第10张门票...第二窗口卖出第8张门票...第一窗口卖出第9张门票...第二窗口卖出第7张门票...第二窗口卖出第5张门票...第二窗口卖出第4张门票...第二窗口卖出第3张门票...第二窗口卖出第2张门票...第二窗口卖出第1张门票...第一窗口卖出第6张门票... ​ 不过使用上述代码很容易发生只有一个窗口在卖票，而另一个窗口却没有卖票，这是因为有一个窗口一直在占有CPU。这是可以使用Thread类提供的sleep()方法让其休眠，以便让出CPU给另一个窗口。 参考链接： 创建多个线程对同一个对象操作是什么意思？线程与对象的关系是什么？_百度知道 (baidu.com) 参考书目： 《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"多线程的基本概念","slug":"java/线程/多线程的基本概念","date":"2021-08-03T23:13:48.000Z","updated":"2021-10-27T04:48:06.953Z","comments":true,"path":"2021/08/04/java/线程/多线程的基本概念/","link":"","permalink":"https://silenthly.github.io/2021/08/04/java/%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","excerpt":"​ 传统的编程语言如c/c++语言，本身并没有提供多线程编程功能，但它们可以调用操作系统的多线程功能。java语言本身就提供了多线程编程能力。为了很好的理解多线程，我们必须先了解什么是程序、什么是进程。","text":"​ 传统的编程语言如c/c++语言，本身并没有提供多线程编程功能，但它们可以调用操作系统的多线程功能。java语言本身就提供了多线程编程能力。为了很好的理解多线程，我们必须先了解什么是程序、什么是进程。 程序 ​ “程序(Program)”是一个静态的概念，一般对应与操作系统中的一个可执行文件，比如：我们要启动酷狗听音乐，则对应酷狗的可执行程序。当我们双击酷狗，则加载程序到内存中，开始执行该程序，于是产生了“进程”。 进程 ​ 执行中的程序叫做进程(Process)，是一个动态的概念。现代的操作系统都可以同时启动多个进程。比如：我们在用网易云听音乐，也可以使用idea 写代码，也可以同时用浏览器查看网页。进程的具有以下特性： **独立性。**进程是一个实体，每一个进程都有它自己的内存空间和系统资源，是一个能独立运行的基本单位，同时也是系统中独立获得资源和独立调度的基本单位。 **动态性。**动态性是进程最基本的特性，可表现为由创建而产生，由调度而执行，因得不到资源而暂停执行，以及由撤销而消亡，因而进程由一定的生命期； 并发性。并发不是并行，并发是逻辑上同时发生，是指在某一段时间内同时运行多个进程，而并行是物理上同时发生，是指在某一个时间点内同时运行多个进程。在单cpu的计算机中，某一时刻实际上只能运行一个进程，多进程实际是cpu交替轮流执行多个进程的结果，是并发的。 程序与进程的区别 1、动态性与静态性。程序是静态的，而进程是动态的。进程是一个能独立运行的单位，能与其他进程并发执行，而对于未建立任何进程的程序，都不能作为一个独立的单位来运行。 2、临时性与永久性。程序是永久的，而进程是临时的。程序可以作为一种软件资源长期保存，而进程仅是运行的程序，具有一定的生命周期，会动态的产生和消亡。 3、组成不同。进程包括了程序、数据和进程控制块(PCB)。 注意：程序与进程不一定具有一一对应的关系。一方面，一个程序可由多个进程共用，例如输入法。另一方面，一个进程在其活动中可顺序的执行若干程序。 线程 ​ 在一个进程内部又可以执行多个任务，一般将进程内部的任务称为线程。对线程的理解如下： 一个进程内部的一个执行单元，它是程序中的一个单一的顺序控制流程。（程序使用cpu的基本单位） 一个进程至少包含一个线程，可拥有多个并行的线程。 线程除了在运行时占用cpu资源外，不能拥有系统资源，只能使用进程的资源。 同多个进程可以共享操作系统的某些资源一样，同一进程的多个线程也可以共享此进程的某些资源（比如：代码、数据），所以线程又被称为轻量级进程。 线程与进程的区别 1、地址空间和其他资源。每个进程占有独立的地址空间，包括代码、数据及其他资源，然而，属于统一个进程中的线程智能共享这些资源，不具有独立的地址空间和其他资源。 2、通信。进程之间的通信(简称IPC)开销较大且受到诸多的吸纳在，必须具有明确的对象或操作接口并采用统一的通信协议。而线程将可以直接读写进程数据段(如全局变量)来进行通信，需要进程同步和互斥手段的辅助，以保证数据的一致性，开销较少且比较简单。 3、切换。进程将的切换开销比较大，而线程间的开销较小。在多进程程序中需要切换进程时，需要改变地址空间位置。而在多线程程序只需要改变执行次序，因为他们都位于一个存储空间内。 4、控制表。进程的控制表为PCB，线程的控制表为TCP，TCP中保存的线程状态远少于PCB。 参考链接： 从动态性、并发性、独立性、上比较进程和程序_百度知道 (baidu.com) 参考书目： 《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com) 实战Java程序设计 - 北京尚学堂科技有限公司 编著 | 豆瓣阅读 (douban.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"对象序列化","slug":"java/基本知识/对象序列化","date":"2021-08-03T01:14:23.000Z","updated":"2021-10-27T04:43:52.605Z","comments":true,"path":"2021/08/03/java/基本知识/对象序列化/","link":"","permalink":"https://silenthly.github.io/2021/08/03/java/%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96/","excerpt":"​ 对象序列化是个非常复杂的问题，java API文档规范中有关于对象序列化的规范。本文不对此问题进行详细深入的介绍，只介绍对象流最简单的用法。我们只需要了解对象序列化的基本概念、对象输出流ObjectOutputStream及对象输入流ObjectInputStream即可。","text":"​ 对象序列化是个非常复杂的问题，java API文档规范中有关于对象序列化的规范。本文不对此问题进行详细深入的介绍，只介绍对象流最简单的用法。我们只需要了解对象序列化的基本概念、对象输出流ObjectOutputStream及对象输入流ObjectInputStream即可。 对象序列化的简介 ​ 对象序列化是将对象状态转换为可保存或传输的格式的过程。一般的格式是与平台无关的二进制流（字节序列），可以将这种二进制持久保存在磁盘上，也可以通过网络将这种二进制流传输到另一个网络结点，即将对象写入输入流。与对象序列化相对应的是对象反序列化，是指由输入流将这种二进制流读入，重新恢复成原来的对象。将对象反序列化和对象序列化这两个过程结合起来，可以轻松地存储和传输数据，使对象可以脱离程序的运行而独立存在。 提示：对象序列化只是实现一种轻量级的对象持久性。之所以是轻量级，是因为这种对象持久性的实现手段实际上只适合于较小的对象。 ​ 一般而言，对象序列化主要有以下几个作用。 RMI（Remote Method Invocation，远程方法调用）机制，它是 java EE 技术的基础。 通过各个 Socket 作为对象之间的通信，从而实现程序组件在不同操作系统之间的通信。RMI 可以大大增强 java 开发分布式应用的能力。 将对象转换成文件，可保存在硬盘上，以备将来继续使用对象。 通过序列化在进程间传递对象。 ​ java的对象可以分为可序列化和不可序列化对象，若需要某个对象能支持序列化机制。必须让它实现Serialization接口。Serialization接口的定义如下： 12public interface Serialization&#123;&#125; ​ 可以发现。Serialzation接口值是一个标记接口。实现接口无须实现任何方法，仅仅表明该类的对象是可序列化的。 代码示例：(定义可序列化的类) 123456789101112131415161718import java.io.Serializable;public class Student implements Serializable&#123; private String name; private int age; private String school; public Student()&#123;&#125; public Student(String name,int age,String school) &#123; this.name=name; this.age=age; this.scool=school; &#125; public void tell() &#123; System.out.println(&quot;名字：&quot;+name+&quot;\\n年龄：&quot;+age+&quot;\\n学校：&quot;+school); &#125;&#125; ​ 在以上的程序中，若不使用import关键字导入java.io.Seriablizable，则可以使用public class Student implements java.io.Serializable。由于Seriablizable接口并没有需要实现顶点方法，所以实现它的过程非常简单。 提示：如果一个对象可以被序列，那么对象中的哪些成员参与了序列化呢？ ​ java对象被序列化时参与序列化的内容如下。 属性：如基本数据类型、数组和其他对象的引用。 类名。 ​ 不能被序列化的内容有 方法：类中的所有方法。 static关键字和transient关键字修饰的属性。 对象输出流：ObjectOutputStream ​ java.io.ObjectOutputStream类用于对象的序列化，即将一个对象输出。此类的定义为： 1public class ObjectOutputStream extends OutputStream implements ObejctOutput,ObjectStreamConstants ​ 可以发现ObjectOutputStreamWriter类实现了ObjectOutput接口，提供了基本的写入操作。ObjectOutputStream类的常用方法如下表所示。 序号 方法 类型 说明 1 public ObjectOutputStream(OutputStream out)throws IOException 构造 创建写入指定OutputStream的ObjectOutputStream对象 2 public void reset()throws IOException 普通 重置将丢弃已写入流中的所有对象的状态 3 public writeObject(Object obj)throws IOException 普通 将指定的对象写入ObjectOutputStream 4 public void writeUnshared(Object obj)throws IOException 普通 将“未共享”对象写入ObjectOutputStream 提示：ObjectOutputStream类与其他的输出流一样，也包含write()、flush()和close()等方法，在此不再赘述。 代码示例：(将对象保存在文件中) 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.io.File;import java.io.IOException;import java.io.FileOutputStream;import java.io.ObjectOutputStream;import java.io.Serializable;class Student implements Serializable&#123; private String name; private int age; private String school; public Student()&#123;&#125; public Student(String name,int age,String school) &#123; this.name=name; this.age=age; this.school=school; &#125; public void tell() &#123; System.out.println(&quot;名字：&quot;+name+&quot;\\n年龄：&quot;+age+&quot;\\n学校：&quot;+school); &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; Student stu1=new Student(&quot;小强&quot;,18,&quot;CUMT&quot;); Student stu2=new Student(&quot;小明&quot;,19,&quot;WHU&quot;); File file=new File(&quot;Objectstudent.txt&quot;); FileOutputStream fout=null; ObjectOutputStream oos=null; try &#123; fout=new FileOutputStream(file); oos=new ObjectOutputStream(fout); oos.writeObject(stu1); //序列化对象stu1 oos.writeObject(stu2); //序列化对象stu2 oos.close(); &#125;catch(Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; ​ 以上程序中，Student类要与Test类在同一个文件夹中，否则需要使用import关键字进行导入Student类。程序可将对象的内容保存在文件中，但是保存的内容是二进制数据，所以不能在文件中直接修改数据，否则会破坏数据的结构。 对象输入流：ObjectInputStream ​ ObjectInputStream类用于对对象进行反序列化操作。ObjectInputStream类的定义如下; 1public class ObjectInputStream extends InputStream implements ObjectInput,ObjectStreamConstants; ​ 可以发现ObjectInputStream类实现了ObjectInput接口，提供了基本类型的输入方法。ObjectInputStream类的常用方法如下表所示。 序号 方法 类型 说明 1 puclic ObjectInputStream(InputStream in)throws IOException 构造 创建从指定InputStream读取的ObjectInputStream对象 2 public final readObject()throws IOException,ClassNotFoundException 普通 从ObjectInputStream中读取对象 3 public Object readUnshared()throws IOException 普通 从ObjectInputStream读取&quot;非共享&quot;对象 提示：ObjectInputStream 类与其他输入流类一样，具有 available()、read()和 close()等方 法。详情可以查看 API 帮助文档。 代码示例：(从文件中将对象反序列化) 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.io.File;import java.io.IOException;import java.io.FileInputStream;import java.io.ObjectInputStream;import java.io.Serializable;class Student implements Serializable&#123; private String name; private int age; private String school; public Student()&#123;&#125; public Student(String name,int age,String school) &#123; this.name=name; this.age=age; this.school=school; &#125; public void tell() &#123; System.out.println(&quot;名字：&quot;+name+&quot;\\n年龄：&quot;+age+&quot;\\n学校：&quot;+school); &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; File file=new File(&quot;Objectstudent.txt&quot;); FileInputStream fis=null; ObjectInputStream ois=null; try &#123; fis=new FileInputStream(file); ois=new ObjectInputStream(fis); Student stu1=(Student)ois.readObject(); //反序列化stu1对象 Student stu2=(Student)ois.readObject(); //反序列化stu2对象 ois.close(); //关闭输入流 stu1.tell(); //调用tell()方法输出对象信息 stu2.tell(); &#125;catch(Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 运行结果： 123456名字：小强年龄：18学校：CUMT名字：小明年龄：19学校：WHU ​ 以上程序依次从文件读出了各个对象的数据。 提示：前面使用对象的序列化和反序列化操作并不是最好的，仅在一些比较特殊的情况下使用，因为需要知道文件中对象的先后顺序，否则转换数据类型时将会出错。在更多的情况下会使用集合保存多个对象，然后再对集合中的对象进行序列化和反序列化操作。 Externalizable接口 ​ java 序列化有两种实现方法，一种是在类定义的时候实现 Serializable 接口，另一种是实现 Externalizable 接口。实现了这两种接口类的对象，均可以完成对象的序列化和反序列化。被 Serializable 接口声明的类对象的内容都将被序列化。而 Externalizable 接口声明的类的对象可以选择需要序列化的内容。 ​ 但一般选择使用 Serializable 接口实现序列化，因为该接口不需要实现任何方法；而Externalizable 接口定义了 readExternal() 和 writeExternal() 方法，实现该接口的类必须要实现这两种方法。这两个方法会在序列化和反序列化还原的过程中被自动调用，以便执行一些特殊的操作。 序号 方法 类型 说明 1 public void readExternal(ObjectInput in) 抽象 调用对象需要实现该方法，通过ObjectInput类的readObject方法来为对象、字符串、数组进行反序列化 2 public void writeExternal(ObjectOutput out) 抽象 调用对象需要实现该方法，通过ObjectOutput类的writeObject方法来为对象、字符串、数组进行序列化 代码示例：(实现Externalizable接口) 12345678910111213141516171819202122232425262728293031import java.io.Externalizable;import java.io.ObjectInput;import java.io.ObjectOutput;import java.io.IOException;class Student implements Externalizable&#123; private String name; private int age; private String school; public Student()&#123;&#125; public Student(String name,int age,String school) &#123; this.name=name; this.age=age; this.school=school; &#125; public void tell() &#123; System.out.println(&quot;名字：&quot;+name+&quot;\\n年龄：&quot;+age+&quot;\\n学校：&quot;+school); &#125; public void writeExternal(ObjectOutput out)throws IOException &#123; out.writeObject(this.name); //序列化指定成员属性 out.writeObject(this.school); &#125; public void readExternal(ObjectInput in)throws IOException,ClassNotFountException &#123; this.name=(String)in.readObject(); //反序列化指定成员属性 this.school=(String)in.readObject(); &#125;&#125; ​ 以上程序中，因为 Externalizable 接口含有 writeExternal()和 readExternal()方法，所以可以选择对象具体的属性进行序列化。例如，以上程序只对 name 属性和 school 属性序列化，而不对 age 属性序列化。但在程序设计中，一般为了程序的完整性和统一性，都会将属性全部保存起来。 代码示例：(序列化与反序列化) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import java.io.File;import java.io.IOException;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Externalizable;class Student implements Externalizable&#123; private String name; private int age; private String school; public Student()&#123;&#125; public Student(String name,int age,String school) &#123; this.name=name; this.age=age; this.school=school; &#125; public void tell() &#123; System.out.println(&quot;名字：&quot;+name+&quot;\\n年龄：&quot;+age+&quot;\\n学校：&quot;+school); &#125; public void writeExternal(ObjectOutput out)throws IOException &#123; out.writeObject(this.name); //序列化指定成员属性 out.writeObject(this.school); &#125; public void readExternal(ObjectInput in)throws IOException,ClassNotFountException &#123; this.name=(String)in.readObject(); //反序列化指定成员属性 this.school=(String)in.readObject(); &#125;&#125;public class Test&#123; public static void serialize(File file) &#123; Student stu1=new Student(&quot;小强&quot;,18,&quot;CUMT&quot;); Student stu2=new Student(&quot;小明&quot;,19,&quot;WHU&quot;); FileOutputStream fout=null; ObjectOutputStream oos=null; try &#123; fout=new FileOutputStream(file); oos=new ObjectOutputStream(fout); oos.writeObject(stu1); //序列化对象stu1 oos.writeObject(stu2); //序列化对象stu2 oos.close(); &#125;catch(Exception e) &#123; e.printStackTrace(); &#125; &#125; public static void deserialization(File file) &#123; FileInputStream fis=null; ObjectInputStream ois=null; try &#123; fis=new FileInputStream(file); ois=new ObjectInputStream(fis); Student stu1=(Student)ois.readObject(); //反序列化stu1对象 Student stu2=(Student)ois.readObject(); //反序列化stu2对象 ois.close(); //关闭输入流 stu1.tell(); //调用tell()方法输出对象信息 stu2.tell(); &#125;catch(Exception e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; File file=new File(&quot;Es.txt&quot;); serialize(file); //对象序列化 deserialization(file); //对象反序列化 &#125;&#125; 运行结果： 123456名字：小强年龄：0学校：CUMT名字：小明年龄：0学校：WHU ​ 从程序运行结果可以发现，age 属性没有被序列化。 transient 关键字 ​ 虽然 Externalizable 接口可以选择需要的属性序列化，但是其实现序列化的过程明显比使用 Serializable 接口复杂。为此 java 语言为我们提供了 transient 关键字，当使用 Serializable 接口实现序列化操作时，若不需要对某个对象的属性序列化，可以使用 transient 关键字进行声明。 代码示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import java.io.File;import java.io.IOException;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable;class Student implements Serializable&#123; private String name; private transient int age; private String school; public Student()&#123;&#125; public Student(String name,int age,String school) &#123; this.name=name; this.age=age; this.school=school; &#125; public void tell() &#123; System.out.println(&quot;名字：&quot;+name+&quot;\\n年龄：&quot;+age+&quot;\\n学校：&quot;+school); &#125;&#125;public class Test&#123; public static void serialize(File file) &#123; Student stu1=new Student(&quot;小强&quot;,18,&quot;CUMT&quot;); Student stu2=new Student(&quot;小明&quot;,19,&quot;WHU&quot;); FileOutputStream fout=null; ObjectOutputStream oos=null; try &#123; fout=new FileOutputStream(file); oos=new ObjectOutputStream(fout); oos.writeObject(stu1); //序列化对象stu1 oos.writeObject(stu2); //序列化对象stu2 oos.close(); &#125;catch(Exception e) &#123; e.printStackTrace(); &#125; &#125; public static void deserialization(File file) &#123; FileInputStream fis=null; ObjectInputStream ois=null; try &#123; fis=new FileInputStream(file); ois=new ObjectInputStream(fis); Student stu1=(Student)ois.readObject(); //反序列化stu1对象 Student stu2=(Student)ois.readObject(); //反序列化stu2对象 ois.close(); //关闭输入流 stu1.tell(); //调用tell()方法输出对象信息 stu2.tell(); &#125;catch(Exception e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; File file=new File(&quot;st.txt&quot;); serialize(file); //对象序列化 deserialization(file); //对象反序列化 &#125; &#125; 运行结果： 123456名字：小强年龄：0学校：CUMT名字：小明年龄：0学校：WHU ​ 从程序运行结果可以发现，age 属性为0，说明 age 属性没有被序列化保存下来。 参考书目： 《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"压缩流","slug":"java/常用类库/压缩流","date":"2021-08-02T00:31:58.000Z","updated":"2021-10-27T04:43:45.933Z","comments":true,"path":"2021/08/02/java/常用类库/压缩流/","link":"","permalink":"https://silenthly.github.io/2021/08/02/java/%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%BA%93/%E5%8E%8B%E7%BC%A9%E6%B5%81/","excerpt":"​ 在日常的使用中经常会使用到WinRAR或7-zip等压缩文件，通过这些软件可以把一个很大的文件进行压缩以方便运输。在java中为了减少传输时的数据量也提供了专门的压缩流，可以将文件或文件夹压缩成ZIP、JAP、GZIP等文件形式。在java中要实现ZIP的压缩需要导入java.util.zip包，该包中最经常使用的类有ZipEntry、ZipFile、ZipInputStream和ZipOutputStream。","text":"​ 在日常的使用中经常会使用到WinRAR或7-zip等压缩文件，通过这些软件可以把一个很大的文件进行压缩以方便运输。在java中为了减少传输时的数据量也提供了专门的压缩流，可以将文件或文件夹压缩成ZIP、JAP、GZIP等文件形式。在java中要实现ZIP的压缩需要导入java.util.zip包，该包中最经常使用的类有ZipEntry、ZipFile、ZipInputStream和ZipOutputStream。 ZipEntry类 ​ ZipEntry类的对象是用来表示ZIp文件条目，代表Zip文件内的进入点(entry)。ZipEntry类的常用方法如下表所示。 序号 方法 类型 说明 1 public ZipEntry(String name) 构造 使用指定名称创建新的ZipEntry对象 2 public ZipEntry(ZipEntry e) 构造 建立一个实例内各字段皆由e参数指定的ZipEntry对象取得 3 public Object clone() 方法 返回此ZipEntry的副本 4 public String getComment() 方法 返回条目的注释字符，如果没有，则返回null 5 public long getCompressdSize() 方法 返回压缩条目数据的大小，如果未知，则返回-1 6 public long getCrc() 方法 返回此entry所指向的数在未压缩时的CRC-32校验和，如果未知，则返回-1 7 public byte[] getExtra() 方法 返回此entry的额外字段数据，如果没有，则返回null 8 public int getMethod() 方法 返回此entry的压缩方法，如果未指定，则返回-1 9 public String getName() 方法 返回此entry名称 10 public long getSize() 方法 返回此entry数据的未压缩大小，如果未知，则返回-1 11 public long getTime() 方法 返回此entry的修改时间，如果为指定，则返回-1 12 public int hashCode() 方法 返回此entry的哈希码值 13 public boolean isDirectory() 方法 判断此entry是否为目录，若是目录，则返回ture 14 public void setComment(String comment) 方法 设置此entry的注释字符 15 public void setComment(long csize) 方法 设置此entry所指的数据压缩后大小 16 public void setCrc() 方法 设置此entry所指的数据在未压缩前的CRC-32校验和 17 public void setMethod(int method) 方法 设置此entry的压缩方法 18 public void setTime() 方法 设置此entry的修改时间 19 public String toString() 方法 返回一个能代表ZipEntry对象的字符串 ZipOutputStream类 ​ java.util.zip.ZipOutputStream类是FilterOutputStream的子类，用来写出zip文件，即可以将一个文件或文件夹压缩为一个zip文件，而且所支持的包括有压缩及未压缩的进入点(entry)。ZipOutputStream类的常用方法如下表所示。 序号 方法 类型 说明 1 public ZipOutputStream(OutputStream out) 构造 创建新的zip输出流 2 public void close() 普通 关闭zip输出流和正在过滤的流 3 public void closeEntry() throws IOException 普通 关闭当前ZipEntry并让流内的内容指到适当的位置，以便定位写入下一个entry 4 public void finish() 普通 完成写入zip输出流的内容，但不关闭与其配合的OutputStream流 5 public void putNextEntry(ZipEntry e) throws IOException 普通 开始写入新的ZipEntry并将流定位到entry数据的开始处，弱现在的entry没有结束，它将会被关闭。若压缩方法为被指定，将会采用默认的压缩方法。而且新的entry的时间未指定，则采用现在的时间 6 public void setComment(String comment) 普通 设置ZipEntry的注释文字 7 public setLevel(int level) 普通 设定其压缩方法为ZipEntry.DEFLATED的所有entry的压缩程度，压缩程度介于0~9之间 8 public void setMethod(int Method) 普通 设置其后所有entry的默认压缩方法，为ZipInputStream.DEFLATED或ZipOutputStream.DEFLATED 9 public void write(byte[] b,int off,int len) throws IOException 普通 将字节数组的某部分写入当前ZipEntry数据 ZipOutputStream压缩文件 123456789101112131415161718192021222324252627282930313233343536import java.io.File;import java.io.IOException;import java.io.FileInputStream;import java.io.FileOutputStream;import java.util.zip.ZipEntry;import java.util.zip.ZipOutputStream;public class Test&#123; public static void main(String[] args) &#123; File f1=new File(&quot;D:\\\\myjava\\\\123.txt&quot;); File f2=new File(&quot;D:\\\\myjava\\\\111.zip&quot;); byte b[]=new byte[1024]; int temp=0; try &#123; FileInputStream fis=new FileInputStream(f1); FileOutputStream fout=new FileOutputStream(f2); ZipOutputStream zout=new ZipOutputStream(fout); zout.putNextEntry(new ZipEntry(f1.getName())); //设置压缩条目的名字 zout.setComment(&quot;Use ZipOutputStream compression 123.txt&quot;); //设置注释 while((temp=fis.read(b))!=-1) //读取内容 &#123; zout.write(b,0,temp); //输出压缩文件 &#125; zout.close(); fout.close(); fis.close(); System.out.println(&quot;压缩成功！&quot;); &#125;catch(IOException e) &#123; System.out.println(&quot;压缩失败！&quot;); e.printStackTrace(); &#125; &#125;&#125; ZipOutputStream压缩文件夹 ​ ZipOutputStream类不仅可以压缩文件，还可以压缩文件夹，甚至可以方便地压缩多个文件。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.io.File;import java.io.IOException;import java.io.FileInputStream;import java.io.FileOutputStream;import java.util.zip.ZipEntry;import java.util.zip.ZipOutputStream;public class Test&#123; public static void main(String[] args) &#123; File f1=new File(&quot;D:\\\\myjava\\\\111&quot;); File f2=new File(&quot;D:\\\\myjava\\\\zip111.zip&quot;); String fileName[]=null; byte b[]=new byte[1024]; int temp=0; try &#123; FileOutputStream fout=new FileOutputStream(f2); ZipOutputStream zout=new ZipOutputStream(fout); FileInputStream fis=null; zout.setComment(&quot;Use ZipOutputStream compression orgDirectory&quot;); //设置注释 if(f1.isDirectory()) //判断是否为目录 &#123; fileName=f1.list(); //获取文件夹内所有文件或文件夹的名称 for(int i=0;i&lt;fileName.length;i++) &#123; fis=new FileInputStream(fileName[i]); //在默认路径下读取文件 zout.putNextEntry(new ZipEntry(fileName[i])); System.out.println(&quot;正在压缩&quot;+fileName[i]+&quot;.......&quot;); while((temp=fis.read(b))!=-1) &#123; zout.write(b,0,temp); &#125; System.out.println(&quot;压缩&quot;+fileName[i]+&quot;完成&quot;); &#125; &#125; zout.close(); fout.close(); fis.close(); System.out.println(&quot;压缩成功！&quot;); &#125;catch(IOException e) &#123; System.out.println(&quot;压缩失败！&quot;); e.printStackTrace(); &#125; &#125;&#125; ​ 以上程序，能且仅能压缩&quot;类路径&quot;下的文件(不包括文件夹)，若想要压缩类路径以外其他文件夹的文件或者压缩类路径下子目录的文件时，就会出现&quot;java.io.FileNotFoundException: XXX (系统找不到指定的文件。)&quot;的异常。原因是在创建读取文件流时，使用了文件名进行实例化，在读取文件时，系统在默认的“类路径”下寻找该文件并进行压缩，而当类路径中不存在该文件时，就会抛出异常。解决方法是在获取目录下的所有文件时，使用listFiles()返回文件的绝对路径名，由于listFiles()返回的是对象而不是字符串，所以接收数组类型也要更改为File。代码如下，注释部分为更改部分。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.io.File;import java.io.IOException;import java.io.FileInputStream;import java.io.FileOutputStream;import java.util.zip.ZipEntry;import java.util.zip.ZipOutputStream;public class Test&#123; public static void main(String[] args) &#123; File f1=new File(&quot;D:\\\\CloudMusic&quot;); File f2=new File(&quot;D:\\\\myjava\\\\zip111.zip&quot;); File fileName[]=null; //创建对象数组 byte b[]=new byte[1024]; int temp=0; try &#123; FileOutputStream fout=new FileOutputStream(f2); ZipOutputStream zout=new ZipOutputStream(fout); FileInputStream fis=null; zout.setComment(&quot;Use ZipOutputStream compression orgDirectory&quot;); if(f1.isDirectory()) &#123; fileName=f1.listFiles(); //获取文件夹内所有文件或文件夹的绝对路径 for(int i=0;i&lt;fileName.length;i++) &#123; fis=new FileInputStream(fileName[i]); //在绝对路径中读取文件 zout.putNextEntry(new ZipEntry(fileName[i].getName())); //以该文件的名称设置为压缩后的文件条目名称 System.out.println(&quot;正在压缩&quot;+fileName[i]+&quot;.......&quot;); while((temp=fis.read(b))!=-1) &#123; zout.write(b,0,temp); &#125; System.out.println(&quot;压缩&quot;+fileName[i]+&quot;完成&quot;); &#125; &#125; zout.close(); fout.close(); fis.close(); System.out.println(&quot;压缩成功！&quot;); &#125;catch(IOException e) &#123; System.out.println(&quot;压缩失败！&quot;); e.printStackTrace(); &#125; &#125;&#125; ​ 以上程序，只能实现压缩目标文件夹内的文件，不能压缩子文件夹，那么如何把目标文件里的子文件夹也压缩了呢？代码如下所示。 ZipOutputStream压缩多层嵌套文件夹 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import java.io.IOException;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.util.zip.ZipEntry;import java.util.zip.ZipOutputStream;public class Test&#123; private static final int SIZE=512; public static void compression(File file,ZipOutputStream zos,String name)throws IOException &#123; if(file.isDirectory()) //如果路径为目录（文件夹） &#123; File fileName[]=file.listFiles(); //取出文件夹中的文件（或子文件夹） if(fileName==null||fileName.length==0) //如果文件夹为空，则只需在目的地zip文件中写入一个目录进入点 &#123; zos.putNextEntry(new ZipEntry(name+&quot;/&quot;)); zos.closeEntry(); &#125;else //如果文件夹不为空，则递归调用compress，文件夹中的每一个文件（或文件夹）进行压缩 &#123; for(int i=0;i&lt;fileName.length;i++) &#123; compression(fileName[i],zos,name+&quot;/&quot;+fileName[i].getName()); &#125; &#125; &#125;else //如果不是目录（文件夹），即为文件，则先写入目录进入点，之后将文件写入zip文件中 &#123; byte b[]=new byte[SIZE]; int temp; zos.putNextEntry(new ZipEntry(name)); FileInputStream fis=new FileInputStream(file); System.out.println(&quot;正在压缩&quot;+file+&quot;.......&quot;); while((temp=fis.read(b))!=-1) &#123; zos.write(b,0,temp); &#125; System.out.println(&quot;压缩&quot;+file+&quot;完成&quot;); zos.closeEntry(); fis.close(); &#125; &#125; public static void main(String[] args) &#123; try &#123; File f1=new File(&quot;D:/myjava/org&quot;); //源文件（带压缩的文件或文件夹） File f2=new File(&quot;D:/myjava/org.zip&quot;); //目的地Zip文件 FileOutputStream fout=new FileOutputStream(f2); ZipOutputStream zos=new ZipOutputStream(fout); //创建zip输出流 compression(f1,zos,f1.getName()); //调用函数 zos.close(); fout.close(); System.out.println(&quot;压缩成功！&quot;); &#125;catch(IOException e) &#123; System.out.println(&quot;压缩终止！&quot;); e.printStackTrace(); &#125; &#125;&#125; ZipInputStream类 ​ ZipInputStream类是FilterInputStream的子类，通过此类可以方便的读取zip压缩格式的文件，而且支持用压缩或没有压缩的进入点(entry)。ZipInputStream类的常用方法如下表所示。 序号 方法 类型 说明 1 public ZipInputStream(InputStream in) 构造 创建新的ZipInputStream输入流 2 public int avaliable() throws IOException 普通 判断是否读完当前的entry所指的数据。若读取完毕(EOF)，则返回0，否则返回1 3 public close() throws IOException 普通 关闭zip输入流并释放与此流关联的所有系统资源 4 public void closeEntry() throws IOException 普通 关闭当前ZipEntry并定位流以备读取下一个entry 5 public protected ZipEntry createZipEntry(String name) 普通 创建一个指定名称为name的新ZipEntry对象 6 public ZipEntry getNextEntry() 普通 读取下一个ZipEntry 并将流定位到该entry所指示数据的开始处 7 public int read(byte[] ,int off,int len) throws IOException 普通 从当前ZipEntry 读入字节数据 8 public long skip(long n) throws IOException 普通 跳过当前ZipEntry中指定的n个字节数 ​ 使用ZipInputStream类可以将zip压缩格式的文件解压缩。需要注意的是，若需要解压缩的zip文件本身含有文件夹，在解压前，应根据zip文件中的文件夹的名称，在相应的磁盘位置创建一个对应的文件夹。 ZipInputStream类解压缩 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.io.IOException;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.util.zip.ZipEntry;import java.util.zip.ZipInputStream;public class Test&#123; public static void main(String[] args) &#123; File dirf=new File(&quot;D:/myjava&quot;); //压缩文件存放的目录 File zipf=new File(&quot;D:/myjava/org.zip&quot;); //需要解压的zip文件 byte b[]=new byte[512]; int temp=0; ZipEntry z=null; try &#123; ZipInputStream zin=new ZipInputStream(new FileInputStream(zipf)); while((z=zin.getNextEntry())!=null) &#123; System.out.println(&quot;正在解压缩&quot;+z.getName()+&quot;......&quot;); File f=new File(dirf+File.separator+z.getName()); if(z.isDirectory()) //判断该ZipEntry对象是否为目录 &#123; f.mkdirs(); //每次都貌似从最底层开始遍历的 &#125;else &#123; if(!f.getParentFile().exists()) //检查父类路径是否存在 &#123; f.getParentFile().mkdirs(); //创建父类路径 &#125; FileOutputStream fout=new FileOutputStream(f); while((temp=zin.read(b))!=-1) //读取内容 &#123; fout.write(b,0,temp); &#125; fout.close(); &#125; System.out.println(&quot;解压缩&quot;+z.getName()+&quot;完成！&quot;); &#125; zin.close(); System.out.println(&quot;解压成功！&quot;); &#125;catch(IOException e) &#123; System.out.println(&quot;解压中止！&quot;); e.printStackTrace(); &#125; &#125;&#125; ​ 上面的程序中，只有在创建文件时才需检测存放解压文件的目录是否存在，仅有空目录时，若此目录的父目录不存在，mkdirs()会自动创建父目录。需要注意的是，实际上getNextEntry()似乎每次都是从底层开始读取的，所以在有文件的文件夹中，不会先检测到目录，而是先检测到目录中的文件，所以此时需先创建目录再进行读取，否则会出现系统找不到指定的路径的异常。 ZipFile类 ​ ZipFile类可以表示一个压缩文件，用来读取一个zip文件含有的文件的进入点，还可以取得某个进入点对应文件的输入流，ZipFile类的常用方法如下表所示。 序号 方法 类型 说明 1 public ZipFile(File file)throws IOException 构造 在给定指定的File对象的情况下打开ZIP文件以进行读取 2 public ZipFile(File file,int mode) throws IOException 构造 打开新的 ZipFile以从指定模式下的指定File对象读取 3 public ZipFile(String name) throws IOException 构造 打开ZipFile进行阅读，由name参数指定的对象 4 public void close() throws IOException 普通 关闭ZipFile 5 public Enumeration&lt;? extends ZipEntry&gt; entries() 普通 返回zip文件内所有的entry枚举对象 6 public void finalize() throws IOException 普通 确保在没有对此ZipFile对象的引用时释放此ZipFile对象所拥有的系统资源。 7 public ZipEntry getEntry(String name) 普通 返回指定名称的zip文件条目，如果未找到，则返回null 8 public InputStream getInputStream(ZipEntry entry) throws IOException 普通 返回用于读取指定zip文件条目内容的输入流 9 public String getName() 普通 返回ZIP文件的路径名 10 public int size() 普通 返回ZIP文件中的条目(entry)数 获取zip文件的属性 12345678910111213141516171819202122import java.io.IOException;import java.io.File;import java.util.zip.ZipFile;public class Test&#123; public static void main(String[] args) &#123; File f=new File(&quot;D:/myjava/org.zip&quot;); try &#123; ZipFile zip=new ZipFile(f); System.out.println(&quot;文件名称：&quot;+zip.getName()); System.out.println(&quot;压缩文件内文件数：&quot;+zip.size()); System.out.println(&quot;文件大小：&quot;+f.length()); System.out.println(&quot;文件最后修改时间&quot;+f.lastModified()); zip.close(); &#125;catch(IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 运行结果： 1234文件名称：D:\\myjava\\org.zip压缩文件内文件数：3文件大小：5696834文件最后修改时间1628423124341 ZipFile类读取zip中指定文件 1234567891011121314151617181920212223242526272829303132import java.io.IOException;import java.io.File;import java.io.InputStream;import java.io.FileOutputStream;import java.util.zip.ZipEntry;import java.util.zip.ZipFile;public class Test&#123; public static void main(String[] args) &#123; File f=new File(&quot;D:/myjava/z123.txt&quot;); //自定义解压缩文件 File zipf=new File(&quot;D:/myjava/org.zip&quot;); //需要解压的zip文件 int temp=0; byte b[]=new byte[512]; try &#123; ZipFile zip=new ZipFile(zipf); //zip对象表示该压缩文件 ZipEntry z=new ZipEntry(&quot;org/123.txt&quot;); //以zip文件内指定文件的进入点创建对象 InputStream in=zip.getInputStream(z); //从压缩文件中读取指定文件的进入点 FileOutputStream fout=new FileOutputStream(f); //创建输出流 while((temp=in.read(b))!=-1) &#123; fout.write(b,0,temp); &#125; zip.close(); fout.close(); &#125;catch(IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; ​ 以上程序，只能适用于给定ZipEntry对象的情况。如果文件中含有多个文件夹或多个ZipEntry时，实用性不强。但是与ZipInputStream相比，其用于读取zip文件中的某一个文件会更加合适。 参考链接： Zip条目_Ltp_zy的博客-CSDN博客 java.io.FileNotFoundException: student.txt (系统找不到指定的文件。)_Ustinian0的博客-CSDN博客 Java实现将文件或者文件夹压缩成zip - zeng1994 - 博客园 (cnblogs.com) Java Zip压缩实现 - 青儿哥哥 - 博客园 (cnblogs.com) java 解压缩ZIP文件方法_AresYM-CSDN博客 参考书目： 《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"随机访问文件类：RandomAccessFile类","slug":"java/常用类库/随机访问文件类：RandomAccessFile类","date":"2021-08-01T13:39:22.000Z","updated":"2021-10-27T04:48:17.209Z","comments":true,"path":"2021/08/01/java/常用类库/随机访问文件类：RandomAccessFile类/","link":"","permalink":"https://silenthly.github.io/2021/08/01/java/%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%BA%93/%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%E6%96%87%E4%BB%B6%E7%B1%BB%EF%BC%9ARandomAccessFile%E7%B1%BB/","excerpt":"​ java.io.RandomAccessFile类不属于流，是Object的子类，但它融合了流类InputStream和OutputStream的功能，既提供InputStream类似的read()方法，又提供与OutputStream类似的write()方法，还提供更高级的直接读写各种基本数据类型的读写方法，例如readInt()个writeInt()等。","text":"​ java.io.RandomAccessFile类不属于流，是Object的子类，但它融合了流类InputStream和OutputStream的功能，既提供InputStream类似的read()方法，又提供与OutputStream类似的write()方法，还提供更高级的直接读写各种基本数据类型的读写方法，例如readInt()个writeInt()等。 ​ RandomAccessFile类的中文翻译是随机访问文件类，但是实际含义是“任意访问文件类”。因为随机不具有确定性，而RandomAccessFile类有明确的读写位置。RandomAccessFile类不需要从头读到尾，可以从文件的任意位置开始访问文件，这是其他“流”类的不同之处。 ​ 为支持读写，RandomAccessFile类将文件内容存储在一个大型的byte数据中。RandomAccessFile设置指向该隐含的B数组的索引，称为文件指针，通过从文件开头就开始计算的偏移量来计算当前读写的位置。RandomAccessFile类的常用方法如下表所示。 序号 方法 类型 说明 1 public RandomAccessFile(File file,String mode) 构造 访问file参数指定的文件，访问的形式由mode参数指定 2 public RandomAccessFile(String name,String mode) 构造 访问name参数指定的文件，访问的形式由mode参数指定 3 public void close() throws IOException 普通 关闭此随机存取文件流并释放与该流关联的所有系统资源 4 public long length() throws IOException 普通 返回指定文件的长度 5 public int read() throws IOException 普通 从指定文件的当前的指针位置读取一个数据字节 6 public int read(byte[] b) throws IOException 普通 一次读取多个字节，读取的长度为byte数组b的长度，将读取的内容存放在byte数组中 7 public byte readByte()throws IOException 普通 从指定文件读取一个字节，即一个有符号的八位值，可更换为其他类型 8 public String readLine()throws IOException 普通 从此文件读取文本的下一行 9 public String readUTF()throws IOException 普通 从指定文件读取一个字符串 10 public void seek(long pos)throws IOException 普通 指定从文件起始位置开始的指针偏移量 11 public int skipByte(int n)throws IOException 普通 指针跳过输入的n个字节 12 public void write(byte[] b)throws IOException 普通 在指定文件的当前指针位置写入多个字节，写入的长度为byte数组b的长度 13 public void write(int b)throws IOException 普通 向指定文件写入指定的字节 14 public void writeBytes(String s)throws IOException 普通 按字节序列将该字符串写入该文件 15 public void writeInt(int v)throws IOException 普通 按4个字节将int写入该文件，先写高字节 16 public void writeUTF(String str)throws IOException 普通 使用modified UTF-8编码以与机器无关的方式将一个字符串写入指定文件 ​ 以上构造方法中，第一个参数指定了文件，第二个参数mode用于指定访问模式，可使用的模式如下表所示。 序号 参考值 说明 1 “r” 以只读的方式打开文件。调用结果对象的任何write()方法都会导致抛出IOException异常 2 “rw” 用读写方式打开文件。如果文件不存在，则尝试创建该文件 3 “rws” 用读写方式打开文件。相对于rw，还要求对文件的内容或元数据的每一个更新都同步写入到底层存储设备 4 “rwd” 用读写方式打开文件。相对于rw，还要求文件内容的每一个更新都同步写入到底层存储设备 RandomAccessFile写入文件 1234567891011121314151617181920212223import java.io.File;import java.io.IOException;import java.io.RandomAccessFile;public class Test&#123; public static void main(String[] args) &#123; File f=new File(&quot;D:\\\\myjava\\\\测试.txt&quot;); try &#123; RandomAccessFile raf=new RandomAccessFile(f,&quot;rw&quot;); raf.writeUTF(&quot;中国共产党成立&quot;); raf.writeInt(100); raf.writeChar(&#x27;周&#x27;); raf.writeChar(&#x27;年&#x27;); raf.close(); System.out.println(&quot;写入成功！&quot;); &#125;catch(IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; ​ 以上程序生成的文件，在打开时发现很多是乱码的，原因在于一部分方法是以二进制的表示写入文件，如writeInt()，点击此处了解。 RandomAccessFile类随机读取 12345678910111213141516171819202122232425262728293031323334import java.io.File;import java.io.IOException;import java.io.RandomAccessFile;public class Test&#123; public static void main(String[] args) &#123; File f=new File(&quot;D:\\\\myjava\\\\测试.txt&quot;); try &#123; RandomAccessFile raf=new RandomAccessFile(f,&quot;rw&quot;); for(int i=0;i&lt;10;i++) //写入int类型数字0~9 &#123; raf.writeInt(i); &#125; System.out.println(&quot;当前指针位置：&quot;+raf.getFilePointer()); System.out.println(&quot;文件长度：&quot;+raf.length()+&quot;字节&quot;); raf.seek(0); //使指针指向文件开头 System.out.println(&quot;当前指针位置：&quot;+raf.getFilePointer()); System.out.println(&quot;读取数据&quot;); for(int i=0;i&lt;6;i++) &#123; System.out.println(&quot;数值：&quot;+raf.readInt()+&quot;---&gt;对应指针&quot;+raf.getFilePointer()); if(i==3) &#123; raf.seek(32); //指针跳过32个字节，即4个int类型数据4、5、6、7 &#125; &#125; &#125;catch(IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 运行结果： 12345678910当前指针位置：40文件长度：40字节当前指针位置：0读取数据数值：0---&gt;对应指针4数值：1---&gt;对应指针8数值：2---&gt;对应指针12数值：3---&gt;对应指针16数值：8---&gt;对应指针36数值：9---&gt;对应指针40 ​ 以上程序中，先向文件写入0~9。此时文件长度为40字节，数据指针位置为40。若要读取文件的数据，则需要将指针移到文件的起始位置，执行seek(0)即可。虽然开始时会循环读取数据，但在i=3时，将指针移到32，即跳过4、5、6、7，直接开始读取8和9。 参考链接： 使用RandomAccessFile类-解决readLine乱码问题 - 1130136248 - 博客园 (cnblogs.com) Java对文件的读、写随机访问，RandomAccessFile类的使用分析 - 旭东的博客 - 博客园 (cnblogs.com) 参考书目： 《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Scanner类","slug":"java/常用类库/Scanner类","date":"2021-08-01T07:44:52.000Z","updated":"2021-10-27T04:43:14.281Z","comments":true,"path":"2021/08/01/java/常用类库/Scanner类/","link":"","permalink":"https://silenthly.github.io/2021/08/01/java/%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%BA%93/Scanner%E7%B1%BB/","excerpt":"Scanner类简介 ​ java.util.Scanner类是JDK1.5以后新增的类，既是一个用于扫描输入文本的实用程序，也是使用正则表达式来分析基本类型和字符串的简单文本扫描器。除了能使用正则表达式之外，Scanner类还可以任意的对字符串和基本类型的数据进行分析。Scanner类的常用方法如下表所示。","text":"Scanner类简介 ​ java.util.Scanner类是JDK1.5以后新增的类，既是一个用于扫描输入文本的实用程序，也是使用正则表达式来分析基本类型和字符串的简单文本扫描器。除了能使用正则表达式之外，Scanner类还可以任意的对字符串和基本类型的数据进行分析。Scanner类的常用方法如下表所示。 序号 方法 类型 说明 1 public Scanner(File source) 构造 构造一个新的Scanner类对象，从指定文件获取内容 2 public Scanner(InputStream source) 构造 构造一个新的Scanner类对象，从指定输入流获取内容 3 public boolean hasNext(Pattern pattern) 普通 判断输入的数据是否符合指定的正则式，若符合，则返回ture，否则返回false 4 public boolean hasNextInt() 普通 判断输入的数据是否为int值，若符合，则返回ture，否则返回false 5 public boolean hasNextLine() 普通 判断输入的数据是否还有下一行(包括空行)，若有，则返回ture，否则返回false 6 public String next() 普通 接收输入内容，不能读取空白符及其后的数据 7 public int nextInt() 普通 接收int类型数据 8 public String next(Pattern pattern) 普通 接收输入的内容并进行正则式验证 9 public Scanner useDelimiter(String patten) 普通 设置读取的分隔符 ​ Scanner类的方法很多是可以重载的，详情可以查阅API帮助文档。 ​ 需要注意的是，Scanner是一个扫描器，它扫描数据都是去内存中的一块缓冲区中进行扫描并读入数据的，而我们在控制台中输入的数据也都是被先存入缓冲区中等待扫描器的扫描读取。这个扫描器在扫描过程中判断停止的依据就是&quot;空白符&quot;，空格、回车也算是空白符。 ​ nextInt()方法在扫描到空白符的时候会将前面的数据读取走，但会丢下空白符&quot;\\r&quot;在缓冲区中，但是，nextLine()方法在扫描的时候会将扫描到的空白符接收进来，然后把缓冲区的空白符一同清理掉。在这个过程，nextInt()方法是执行过的，并没有不执行 。 使用Scanner类输入数据 从键盘获取数据 ​ Scanner类最简单方便的功能就是可以直接获取键盘输入的数据，可以使用next()方法获取字符串，也可以使用nextInt()获取int值。 代码示例： 123456789101112131415161718192021222324252627282930313233import java.util.Scanner;public class Test&#123; public static void main(String[] args) &#123; Scanner scan=new Scanner(System.in); int num=0; float f=0.0f; System.out.println(&quot;请输入int型整数：&quot;); if(scan.hasNextInt()) //判断输入的数据是否为int型 &#123; num=scan.nextInt(); &#125;else &#123; System.out.println(&quot;输入的不是整数！&quot;); System.exit(0); //退出程序 &#125; System.out.println(&quot;请输入float型小数：&quot;); if(scan.hasNextFloat()) //判断输入的数据是否为float型 &#123; f=scan.nextFloat(); &#125;else &#123; System.out.println(&quot;输入的不是小数！&quot;); System.exit(0); //退出程序 &#125; System.out.println(&quot;请输入字符串：&quot;); String str=scan.next(); System.out.println(&quot;整数：&quot;+num+&quot;\\n小数：&quot;+f+&quot;\\n字符串：&quot;+str); &#125;&#125; 运行结果： 123456789请输入int型整数：645请输入float型小数：3.14159请输入字符串：Scanner整数：645小数：3.14159字符串：Scanner ​ 上面程序中，在使用nextXxx()方法时最好要验证，否则容易产生异常。若输入的字符串中间含有空格，那么空格之后的数据就没有了。可以使用useDelimiter()将分隔符修改为换行符“\\n”。 123456789101112import java.util.Scanner;public class Test&#123; public static void main(String[] args) &#123; Scanner scan=new Scanner(System.in); scan.useDelimiter(&quot;\\n&quot;); System.out.println(&quot;请输入字符串：&quot;); String str=scan.next(); System.out.println(str); &#125;&#125; 运行结果： 123请输入字符串：java is a programming languagejava is a programming language 使用正则式验证输入的数据 ​ 前面介绍过，Scanner类可以使用正则表达式来分析基本类型和字符串的简单文本扫描器。下面使用正则式验证邮箱的格式。 123456789101112131415161718import java.util.Scanner;public class Test&#123; public static void main(String[] args) &#123; Scanner scan=new Scanner(System.in); String pattern=&quot;^[a-zA-z0-9_\\\\.]+@[a-zA-z0-9-]+[\\\\.a-zA-Z]+$&quot;; System.out.println(&quot;请输入邮箱地址：&quot;); if(scan.hasNext(pattern)) &#123; String mail=scan.next(); System.out.println(&quot;您输入的邮箱为：&quot;+mail); &#125;else &#123; System.out.println(&quot;您输入的邮箱格式不正确！&quot;); &#125; &#125;&#125; 运行结果： 123请输入邮箱地址：123456789@qq.com您输入的邮箱为：123456789@qq.com 从文件中获取数据 ​ Scanner类不但可以方便、简洁地从键盘获取数据，还可以从文件获取相应的数据，只需使用Scanner类的public Scanner(InputStream source)构造方法收取文件数据即可。 代码示例： 12345678910111213141516171819202122232425262728293031import java.io.IOException;import java.io.File;import java.io.FileInputStream;import java.util.Scanner;public class Test&#123; public static void main(String[] args) &#123; File f=new File(&quot;D:\\\\myjava\\\\测试.txt&quot;); if(!(f.exists())) //判断文件是否存在 &#123; System.out.println(&quot;文件不存在！&quot;); System.exit(0); &#125; Scanner scan=null; try &#123; FileInputStream fis=new FileInputStream(f); scan=new Scanner(fis); &#125;catch(IOException e) &#123; e.printStackTrace(); &#125; StringBuffer sbu=new StringBuffer(); while(scan.hasNext()) //判断是否还有内容 &#123; sbu.append(scan.next()).append(&quot;\\n&quot;); //读取内容 &#125; System.out.println(sbu); //输入获取的数据 &#125;&#125; 运行结果： 12342021年08月01日09时37分33秒123圆周率：3.14159 原文： 1232021年08月01日09时37分33秒123圆周率： 3.14159 ​ next()一定要读取到有效字符后才可以结束输入，对输入有效字符之前遇到的空格键、Tab键或Enter键等结束符，next()方法会自动将其去掉，只有在输入有效字符之后，next()方法才将其后输入的空格键、Tab键或Enter键等视为分隔符或结束符。 参考链接： java中Scanner类nextLine()和next()的区别和使用方法 - Boblim - 博客园 (cnblogs.com) Scanner.next()无法识别字符串中的空格_凋敝臣楷鸽的博客-CSDN博客 java输入hasNext()和hasNextLine()方法的区别ghimi的博客-CSDN博客_hasnext和hasnextline 参考书目： 《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"顺序输入流：SequencelnputStream类","slug":"java/常用类库/顺序输入流：SequencelnputStream类","date":"2021-08-01T00:34:15.000Z","updated":"2021-10-27T04:43:58.892Z","comments":true,"path":"2021/08/01/java/常用类库/顺序输入流：SequencelnputStream类/","link":"","permalink":"https://silenthly.github.io/2021/08/01/java/%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%BA%93/%E9%A1%BA%E5%BA%8F%E8%BE%93%E5%85%A5%E6%B5%81%EF%BC%9ASequencelnputStream%E7%B1%BB/","excerpt":"​ SequencelnputStream类可以将多个输入流串流在一起，合并为一个输入流，因此SequencelnputStream类亦称合并流。它从输入流的有序集合开始，依次读取每个输入流中的内容。SequencelnputStream类的常用方法如下表所示。","text":"​ SequencelnputStream类可以将多个输入流串流在一起，合并为一个输入流，因此SequencelnputStream类亦称合并流。它从输入流的有序集合开始，依次读取每个输入流中的内容。SequencelnputStream类的常用方法如下表所示。 序号 方法 类型 说明 1 public SequencelnputStream(InputStream s1,InputStream s2) 构造 参数s1和s2代表两个需要被串联的输入流。顺序输入流先读取s1中的数据，再读取s2中的数据 2 public int available() 普通 返回当前流中可用的字节数 代码示例： 123456789101112131415161718192021222324252627282930313233343536import java.io.IOException;import java.io.SequenceInputStream;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;public class Test&#123; public static void main(String[] args) &#123; File f1=new File(&quot;D:\\\\myjava\\\\1.txt&quot;); File f2=new File(&quot;D:\\\\myjava\\\\2.txt&quot;); File f3=new File(&quot;D:\\\\myjava\\\\《题龙阳县青草湖》.txt&quot;); int temp=0; byte b[]=new byte[256]; try &#123; FileInputStream in1=new FileInputStream(f1); FileInputStream in2=new FileInputStream(f2); FileOutputStream out=new FileOutputStream(f3); SequenceInputStream sis=new SequenceInputStream(in1,in2); //合并输入流in1和in2 while((temp=sis.read(b))!=-1) //循环读取合并流的内容并写入输出流 &#123; out.write(b,0,temp); &#125; //in1.close(); //in2.close(); sis.close(); out.close(); System.out.println(&quot;合并成功！&quot;); &#125;catch(IOException e) &#123; System.out.println(&quot;合并失败！&quot;); e.printStackTrace(); &#125; &#125;&#125; ​ 以上程序将按照顺序一次读取打印in1和in2输入流的数据。在关闭输入流时，可只执行sis.close()关闭输入流，因为顺序输入流的close()方法将依次关闭被串联的输入流，但不会关闭输出流，所以需要单独关闭输出流。 参考书目： 《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"内存操作流","slug":"java/常用类库/内存操作流","date":"2021-07-31T07:15:48.000Z","updated":"2021-10-27T04:49:05.600Z","comments":true,"path":"2021/07/31/java/常用类库/内存操作流/","link":"","permalink":"https://silenthly.github.io/2021/07/31/java/%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%BA%93/%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9C%E6%B5%81/","excerpt":"​ java的流有字节流和字符流之分，所以流的数据也有byte[]和char[]之分，本文主要讲解java.io包提供的ByteArrayInputStream和ByteArrayOutputStream类，用于实现字节数据的输入/输出操作。","text":"​ java的流有字节流和字符流之分，所以流的数据也有byte[]和char[]之分，本文主要讲解java.io包提供的ByteArrayInputStream和ByteArrayOutputStream类，用于实现字节数据的输入/输出操作。 内存输入流：ByteArrayInputStream类 ​ ByteArrayInputStream是一个把字节数组作为源的输入流实现，可以将数据写入内存中，ByteArrayInputStream类的常用方法如下表所示。 序号 方法 类型 说明 1 public ByteArrayInputStream(byte[] buf) 构造 创建一个ByteArrayInputStream对象，使用buf作为其缓冲区数组 2 public ByteArrayInputStream(byte[] buf,int offset,int length) 构造 创建ByteArrayInputStream对象，使用buf作为缓冲区数组。其中，offset 指定数组中开始读取字节的起始下标。length指定读取元素的个数。 ​ ByteArrayInputStream继承了InputStream类，其有close()、mark()、read()和skip()等方法，但close()方法没有实际操作。ByteArrayInputStream类的read()方法重写了InputStream类的read()方法后，没有抛出异常。 代码示例： 123456789101112131415161718192021222324import java.io.ByteArrayInputStream;import java.io.IOException;public class Test&#123; public static void main(String[] args) &#123; byte b[]=&#123;&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;D&#x27;&#125;; ByteArrayInputStream bis=new ByteArrayInputStream(b); int temp=bis.read(); try //关闭流 &#123; bis.close(); &#125;catch(IOException e) &#123; e.printStackTrace(); &#125; System.out.println(); while(temp!=-1) &#123; System.out.print((char)temp+&quot;\\t&quot;); temp=bis.read(); &#125; &#125;&#125; 运行结果： 12A B C D ​ 从上面程序可以发现，ByteArrayInputStream类的实例化对象和执行read()方法都不需要处理异常。但调用close()方法需要处理异常，可调用close()方法后，仍可以调用ByteArrayInputStream类中的方法这是为什么？对象本身是一个数组，只是通过流的方式进行封装了，当这个数组不再使用变成垃圾的时候，Java的垃圾回收机制会将它回收。所以不需要关流，可调用的close方法没有任何操作的一个空方法，在关闭字节数组输入流后仍可被调用，而不会产生任何 IOException。 内存输出流：ByteArrayOutputStream ​ ByteArrayOutputStream类是一个将字节数组作为源的输出流实现，可以将内存中的数据输出。ByteArrayOutputStream类的主要方法如下表所示。 序号 方法 类型 说明 1 public ByteArrayOutputStream() 构造 创建一个新的字节数组输出流对象，输出流缓冲区的初始容量默认为32字节 2 public ByteArrayOutputStream(int size) 构造 创建一个指定大小的缓冲区容量的新的字节数组输出流对象 3 public void reset() 普通 将此字节数组输出流的count字段重置为0，从而丢弃输出流中目前已积累的所有输出 4 public int size() 普通 返回缓冲区的当前大小 5 public byte[] toByteArray() 普通 创建一个新的字节数组，其长度和内容与输出流的数组相同 6 public String toString() 普通 将缓冲区的内容转换为字符串，根据平台的默认字符编码将字节转换成字符 7 public void writeTo(OutputStream out) 普通 将此字节数组输出流的全部内容写入到指定的输出流参数中，这与使用out.write(buf,0,count)调用该输出流的write()方法效果一样 代码示例： 1234567891011121314151617import java.io.ByteArrayOutputStream;import java.io.IOException;public class Test&#123; public static void main(String[] args) &#123; byte b[]=&#123;&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;D&#x27;,&#x27;R&#x27;&#125;; ByteArrayOutputStream bos=new ByteArrayOutputStream(); bos.write(b,0,b.length); System.out.println(&quot;缓冲区的字节数：&quot;+bos.size()); byte bout[]=bos.toByteArray(); //将输出流中的内容转换为字节数组 for(int i=0;i&lt;bout.length;i++) &#123; System.out.print((char)bout[i]+&quot;\\t&quot;); &#125; &#125;&#125; 运行结果： 12缓冲区的字节数：5A B C D R ​ 上面程序中，没有执行close()方法关闭输出流。和ByteArrayInputStream的close()方法一样，没有任何实际的操作，是一个空方法。 ​ 内存操作流一般用于处理临时信息，因为临时信息不需要保存，使用后就可以删除。 参考链接： java关闭 ByteArrayInputStream 无效_百度知道 (baidu.com) (1条消息) ByteArrayOutputStream或ByteArrayInputStream不需要关闭流原因分析_u012668925的博客-CSDN博客 (1条消息) java基础之IO流–ByteArrayInputStream(没有使用系统资源不会抛异常的IO流对象)_ljh_learn_from_base的博客-CSDN博客 [转载]java.ByteArrayInputStream与ByteArrayOutputStream再次理解 - chen2013 - 博客园 (cnblogs.com) toByteArray()这个方法怎么用_百度知道 (baidu.com) Java ByteArrayOutputStream.toByteArray()转换成byte字符数组输出字符串 (51gjie.com) toByteArray()方法是什么意思？-黑马程序员技术交流社区 (itheima.com) 参考书目： 《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"打印流：PrintStream类","slug":"java/常用类库/打印流：PrintStream类","date":"2021-07-31T03:24:55.000Z","updated":"2021-10-27T04:48:59.151Z","comments":true,"path":"2021/07/31/java/常用类库/打印流：PrintStream类/","link":"","permalink":"https://silenthly.github.io/2021/07/31/java/%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%BA%93/%E6%89%93%E5%8D%B0%E6%B5%81%EF%BC%9APrintStream%E7%B1%BB/","excerpt":"​ 打印流可以方便地将不同类型的数据打印输出到另一个输出流。PrintStream类可以配合不同的输出流，用来输出数据到各个目的地，如文件、数组等。 ​ PrintStream类是FileOutputStream的子类。在System类中内置两个PrintStream类型的字段out和err。PrintStream类常用的方法如下表所示。","text":"​ 打印流可以方便地将不同类型的数据打印输出到另一个输出流。PrintStream类可以配合不同的输出流，用来输出数据到各个目的地，如文件、数组等。 ​ PrintStream类是FileOutputStream的子类。在System类中内置两个PrintStream类型的字段out和err。PrintStream类常用的方法如下表所示。 序号 方法 类型 说明 1 public PrintStream(File file) 构造 创建具有指定文件但不带自动行刷新(flush)的新的打印流 2 public PrintStream(OutputStream out) 构造 创建新的打印流但不带自动行刷新(flush) 3 public PrintStream(OutputStream out,boolean autoFlush) 构造 创建新的打印流，由参数autoFlush决定是否要自动刷新 4 public PrintStream(OutputStream out,boolean autoFlush,String encoding) 构造 创建新的打印流，由参数autoFlush决定是否要自动刷新,encoding参数指定此流使用的字符编码 5 public PrintStream format(Locale I,String format,Object…args) 普通 根据“Locale值(区域属性)”来格式化数据 6 public void print(String s) 普通 打印String，然后终止运行。此方法被重载，可以输出任何数据 7 public PrintStream print(Locale I,String format,Object…args) 普通 将“数据args”根据“Locale值(区域属性)”按照format格式化，并写入到“PrintStream输出流”中 8 public PrintStream print(String format,Object…args) 普通 将“数据args”根据“默认Locale值(区域属性)”按照format格式化，并写入到“PrintStream输出流”中 9 public void println(String x) 普通 打印String，然后终止运行。此方法被重载，可以输出任何数据 代码示例： 123456789101112131415161718192021222324import java.io.IOException;import java.io.FileOutputStream;import java.io.PrintStream;import java.util.Date;public class Test&#123; public static void main(String[] args) &#123; try &#123; FileOutputStream fos=new FileOutputStream(&quot;D://myjava//测试.txt&quot;); PrintStream ps=new PrintStream(fos); ps.format(&quot;%1$tY年%1$tm月%1$td日%1$tH时%1$tM分%1$tS秒&quot;, new Date()); ps.println(&quot;\\n&quot;+123); //输出数据 ps.print(&quot;圆周率：\\t&quot;); ps.print(3.14159); ps.close(); fos.close(); &#125;catch(IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 新创建的文档内容： 1232021年07月31日12时37分33秒123圆周率： 3.14159 ​ 上面程序中format()的使用可参考文章：Java String.format 方法使用介绍_GarfieldEr007的专栏-CSDN博客，更多详细内容参考下面链接。 参考链接： java io系列16之 PrintStream(打印输出流)详解 - 如果天空不死 - 博客园 (cnblogs.com) Java String Format函数使用说明_wd_cloud的专栏-CSDN博客 String.format()方法 “%101d”&quot;01d” &quot;%101d”&quot;tY-%1tm−tm-%1tm−td %1tH:tH:%1tH:tM:%1$tS&quot;日期转换等记录 - liuyunche - 博客园 (cnblogs.com) JAVA中String.format的用法 - xytop - 博客园 (cnblogs.com) java String.Format() 日期格式用法 - solo.du - ITeye博客 参考书目： 《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"转换流","slug":"java/常用类库/转换流","date":"2021-07-30T13:43:25.000Z","updated":"2021-10-27T04:49:21.026Z","comments":true,"path":"2021/07/30/java/常用类库/转换流/","link":"","permalink":"https://silenthly.github.io/2021/07/30/java/%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%BA%93/%E8%BD%AC%E6%8D%A2%E6%B5%81/","excerpt":"​ 从继承关系来看，InputStreamReader类与OutputStreamWriter类都是属于字符流的，但它们主要是用来将已存在的字节流转换为字符流。转换流在转换时，可依照系统默认的字符编码来中，或者开发人员指定的字符编码。","text":"​ 从继承关系来看，InputStreamReader类与OutputStreamWriter类都是属于字符流的，但它们主要是用来将已存在的字节流转换为字符流。转换流在转换时，可依照系统默认的字符编码来中，或者开发人员指定的字符编码。 输入字节流——字符流：InputStreamReader类 ​ InputStreamReader类是Reader类的子类，可以将一个字节输入流转变为字符输入流，在转换时默认使用本地操作系统的字符编码或者指定其他字符编码。InputStreamReader类的常用方法如下表所示。 序号 方法 类型 说明 1 public InputStreamReader(InputStream in) 构造 创建一个使用默认字符集的InputStreamReader对象 2 public InputStreamReader(InputStream in,Charset cs) 构造 创建一个使用给定字符集的InputStreamReader对象 3 public InputStreamReader(InputStream in,CharsetDecoder dec) 构造 创建一个使用给定字符集解码器的InputStreamReader对象 4 public InputStreamReader(InputStream in,String charsetName) 构造 创建一个使用指定字符集的InputStreamReader对象 5 public String getEncoding() 普通 返回此流使用的字符编码器名称 代码示例： 123456789101112131415161718192021222324252627import java.io.File;import java.io.FileInputStream;import java.io.InputStreamReader;import java.io.IOException;public class Test&#123; public static void main(String[] args) &#123; try &#123; File f=new File(&quot;D:\\\\myjava\\\\存在的文档.txt&quot;); FileInputStream fin=new FileInputStream(f); InputStreamReader isr=new InputStreamReader(fin); //使用系统默认字符集创建对象 System.out.println(&quot;系统默认字符编码：&quot;+isr.getEncoding()); int temp=0; while((temp=isr.read())!=-1) //循环读取文本内容 &#123; System.out.print((char)temp); &#125; isr.close(); //关闭字符流 fin.close(); //关闭字节流 &#125;catch(IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 运行结果： 12系统默认字符编码：GBKjava是面向对象的编程语言 ​ 在上面程序中，使用的是系统默认的字符编码GBK，通过InputStreamReader将字节流转换为字符流。若没有InputStreamReader类进行转化就会出现乱码。 123456789101112131415161718192021222324import java.io.File;import java.io.FileInputStream;import java.io.InputStreamReader;import java.io.IOException;public class Test&#123; public static void main(String[] args) &#123; try &#123; File f=new File(&quot;D:\\\\myjava\\\\存在的文档.txt&quot;); FileInputStream fin=new FileInputStream(f); int temp=0; while((temp=fin.read())!=-1) //循环读取文本内容 &#123; System.out.print((char)temp); &#125; fin.close(); //关闭字节流 &#125;catch(IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 运行结果： 1java?????ò???ó??±à?????? 输出字节流——字符流：OutputStreamWriter类 ​ 使用OutputStreamWriter类可以将一个字节输出流转变为字符输出流，在转换时默认使用本地操作系统的字符编码或者指定其他字符编码。OutputStreamWriter类的常用方法如下表所示。 序号 方法 类型 说明 1 public OutputStreamWriter(InputStream out) 构造 创建一个使用默认字符集的OutputStreamWriter对象 2 public OutputStreamWriter(InputStream out,Charset cs) 构造 创建一个使用给定字符集的OutputStreamWriter对象 3 public OutputStreamWriter(InputStream out,CharsetDecoder dec) 构造 创建一个使用给定字符集解码器的OutputStreamWriter对象 4 public OutputStreamWriter(InputStream out,String charsetName) 构造 创建一个使用指定字符集的OutputStreamWriter对象 5 public String getEncoding() 普通 返回此流使用的字符编码器名称 代码示例： 1234567891011121314151617181920212223import java.io.File;import java.io.FileOutputStream;import java.io.OutputStreamWriter;import java.io.IOException;public class Test&#123; public static void main(String[] args) &#123; try &#123; File f=new File(&quot;D:\\\\myjava\\\\《题龙阳县青草湖》.txt&quot;); FileOutputStream fout=new FileOutputStream(f); OutputStreamWriter osw=new OutputStreamWriter(fout); //使用系统默认字符集创建对象 String str=&quot;醉里不知天在水，满船星梦压星河。&quot;; osw.write(str); osw.close(); //关闭字符流 fout.close(); //关闭字节流 &#125;catch(IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; ​ 以上程序中，将新建一个《题龙阳县青草湖》.txt文件，并将str字符串的内容写入。其中要注意的是，一定要执行osw.close()方法再执行fout.close()方法，否则将会产生异常。 关于编码 ​ 此处不详细讲述编码，在JAVA几种常见的编码格式（转） - 挟天子以令诸侯 - 博客园 (cnblogs.com)该网站可了解较为详细的内容。 参考书目： 《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"缓冲流:BufferedReader类","slug":"java/常用类库/缓冲流BufferedReader类","date":"2021-07-30T07:27:40.000Z","updated":"2021-10-27T04:44:37.733Z","comments":true,"path":"2021/07/30/java/常用类库/缓冲流BufferedReader类/","link":"","permalink":"https://silenthly.github.io/2021/07/30/java/%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%BA%93/%E7%BC%93%E5%86%B2%E6%B5%81BufferedReader%E7%B1%BB/","excerpt":"​ 在读写数据时，让数据有缓冲区能减少系统实际对原始数据来源做存取的次数，因为一次能做多个数据单位的操作。相较而言，对于从文件读取数据或将数据写入文件，比起对缓冲区的读写要慢得多了。因此使用缓冲区的流，一般都会比没有缓冲区的流效率更高。拥有缓冲区的流称为缓冲流。包括BufferedInoutStream、BufferedOutoutStream类和BufferedReader类和BufferedWriter类。","text":"​ 在读写数据时，让数据有缓冲区能减少系统实际对原始数据来源做存取的次数，因为一次能做多个数据单位的操作。相较而言，对于从文件读取数据或将数据写入文件，比起对缓冲区的读写要慢得多了。因此使用缓冲区的流，一般都会比没有缓冲区的流效率更高。拥有缓冲区的流称为缓冲流。包括BufferedInoutStream、BufferedOutoutStream类和BufferedReader类和BufferedWriter类。 BufferedReader类 ​ BufferedReader类是Reader的子类，Reader类的read()方法每次都从数据源读入一个字符，为了提高效率，可以采用BufferedReader来配合其他字节流。BufferedReader带有缓冲区，它可以先把一批数据读到缓冲区内。接下来的读操作都是从缓冲区内获取数据，避免每次都从数据源读取数据并进行字符编码转换，从而提高操作的效率。BufferedReader类的常用方法如下表所示。 序号 方法 类型 说明 1 public BufferedReader(Reader in) 构造 创建一个使用默认大小输入缓冲区的缓冲字符输入流对象 2 public BufferedReader(Reader in,int sz) 构造 创建一个使用指定大小输入缓冲区的缓冲字符输入流对象 3 public String readLine()throws IOException 普通 读取一个文本行 BufferedReader是针对Reader的，是需要与其他字符流配合使用的，不直接针对文件读取。 代码示例： 12345678910111213141516171819202122232425import java.io.File;import java.io.FileReader;import java.io.BufferedReader;import java.io.IOException;public class Test&#123; public static void main(String[] args) &#123; File f=new File(&quot;D:\\\\myjava\\\\存在的文档.txt&quot;); String str=&quot;&quot;; try &#123; FileReader read=new FileReader(f); BufferedReader bin=new BufferedReader(read); //与文件字符流配合使用 str=bin.readLine(); bin.close(); read.close(); &#125;catch(IOException e) &#123; System.out.println(&quot;读取失败！&quot;); e.printStackTrace(); &#125; System.out.println(str); &#125;&#125; 运行结果： 1java是面向对象的编程语言 ​ 以上程序结果输出只有一行，而文本中的内容却是有两行。 接收键盘输入流 ​ BufferedReader类还可以接收来自键盘输入的字节流，但需要使用InputStreamReader将键盘的字节流System.in转化为字符流。 代码示例： 12345678910111213141516171819202122import java.io.InputStreamReader;import java.io.BufferedReader;import java.io.IOException;public class Test&#123; public static void main(String[] args) &#123; String str=&quot;&quot;; try &#123; BufferedReader bin=new BufferedReader(new InputStreamReader(System.in)); System.out.println(&quot;请输入内容：&quot;); str=bin.readLine(); bin.close(); &#125;catch(IOException e) &#123; System.out.println(&quot;读取失败！&quot;); e.printStackTrace(); &#125; System.out.println(&quot;您输入的内容为：\\n&quot;+str); &#125;&#125; 运行结果： 1234请输入内容：人间四月芳菲尽，山寺桃花始盛开。您输入的内容为：人间四月芳菲尽，山寺桃花始盛开。 BufferedWriter类 ​ BufferedWriter类是Writer的子类，与Writer相比，BufferedWriter类主要的改变是重写了flush()方法，该方法可以确保缓冲区里的数据确实被写到输出流中。实验BufferedWriter类时，写入的数据并不会先输出到目的地，而是先存储到缓冲区中。BufferedWriter类的常用方法如下表所示。 序号 方法 类型 说明 1 public BufferedWriter(Writer out) 构造 创建一个使用默认大小输出缓冲区的缓冲字符输出流对象 2 public BufferedWriter(Writer out,int sz) 构造 创建一个使用指定大小输出缓冲区的缓冲字符输出流对象 3 public void newLine()throws IOException 普通 写入一个行分隔符 代码示例： 1234567891011121314151617181920212223242526272829import java.io.File;import java.io.FileWriter;import java.io.BufferedWriter;import java.io.IOException;public class Test&#123; public static void main(String[] args) &#123; File f=new File(&quot;D:\\\\myjava\\\\题都城南庄.txt&quot;); String str[]=&#123;&quot;人面不知何处去&quot;,&quot;桃花依旧笑春风&quot;&#125;; try &#123; FileWriter fw=new FileWriter(f); BufferedWriter bw=new BufferedWriter(fw); for(int i=0;i&lt;str.length;i++) &#123; bw.write(str[i]); bw.newLine(); &#125; bw.close(); fw.close(); System.out.println(&quot;写入成功！&quot;); &#125;catch(IOException e) &#123; System.out.println(&quot;写入失败！&quot;); e.printStackTrace(); &#125; &#125;&#125; 文档内容： 12人面不知何处去桃花依旧笑春风 参考书目： 《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"字符流","slug":"java/常用类库/字符流","date":"2021-07-30T05:27:17.000Z","updated":"2021-10-27T04:49:26.531Z","comments":true,"path":"2021/07/30/java/常用类库/字符流/","link":"","permalink":"https://silenthly.github.io/2021/07/30/java/%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%BA%93/%E5%AD%97%E7%AC%A6%E6%B5%81/","excerpt":"​ 在程序设计中，绝大多数应用程序都是使用字符流读取或写入“文本数据”，因为字符流支持Unicode标准字符集产生的各种字符集，而字节字符集仅支持“ISO 8859-1(Latin-1)”字符集。因此处理“文本数据”时，建议使用字符流。 ps：字符流不能处理二进制文件的主要原因，是因为字符流对象在读写文件时会解释和处理文件中的特殊字符，例如回车符(\\0x0d)、换行符(\\0x0a)等。特别地，当它碰到文件结束符时就会认为文件已经结束，而二进制文件可能在文件中间就出现文件结束符。","text":"​ 在程序设计中，绝大多数应用程序都是使用字符流读取或写入“文本数据”，因为字符流支持Unicode标准字符集产生的各种字符集，而字节字符集仅支持“ISO 8859-1(Latin-1)”字符集。因此处理“文本数据”时，建议使用字符流。 ps：字符流不能处理二进制文件的主要原因，是因为字符流对象在读写文件时会解释和处理文件中的特殊字符，例如回车符(\\0x0d)、换行符(\\0x0a)等。特别地，当它碰到文件结束符时就会认为文件已经结束，而二进制文件可能在文件中间就出现文件结束符。 字符输入流：Reader类 ​ 字符输入流都是Reader的子类，而Reader是根类Object的子类，是对字符输入流基本功能的抽象。Reader类提供的主要方法和Read类极为相似，最大的区别就是Reader的类读取数据的单位是字符(char)，也就是每次最少读入两个字节的数据，Reader体系中读数据的方法都以字符作为最基本的单位。 ​ 同样地，Reader的方法没有实质的实现，但在子类被重写后将完成实质的输入功能。Reader类本身就是一个抽象类，如果要使用Reader类，则需要使用其子类为其实例化。Reader类的常用方法如下表所示。 序号 方法 类型 说明 1 public abstract void close()throws IOException 抽象 关闭字符流。当字符流关闭后，就不能再对此字符流进行任何操作，否则抛出IllegalArgumerntException 2 public void mark(int readAheadLimit)throws IOException 方法 标记字符流中的当前位置。并非所有的字符流都支持mark()语法 3 public boolean markSupported() 方法 判断此流是否支持mark()操作 4 public int read()throws IOException 方法 读取单个字符，并将其转换为0~65535(0x00-0xffff)之间的整数。如果返回-1，则表示已经到达了输入流的结尾 5 public int read(char[] cbuf)throws IOException 方法 将字符读入数组，并返回读入的字符数。如果返回-1，则表示已经到达了输入流的结尾 6 public abstract int read(char[] cbuf,int off,int len)throws IOException 抽象 将字符读入数组的一部分，并返回读入的字符数。其中，off指定在字符数组开始保存的初始位置。len指定读取的字符数。如果返回-1，则表示已经到达了输入流的结尾 7 public void reset()throws IOException 方法 重置设定流 8 public long skip(long n)throws IOException 方法 跳过字符，并返回所跳过的字符数。若n为负数，将抛出IllegalArgumerntException ​ 下面以Reader的子类FileReader为例，对Reader类的常用方法进行介绍。FileReader的构造方法如下： 1public FileReader(File file) throws IOException 代码示例： 123456789101112131415161718192021222324import java.io.File;import java.io.IOException;import java.io.Reader;import java.io.FileReader;public class Test&#123; public static void main(String[] args) &#123; File f=new File(&quot;D:/myjava/不存在的文档.txt&quot;); //创建File类实例 Reader read=null; //声明Reader对象 char c[]=new char[(int)f.length()]; try &#123; read=new FileReader(f); read.read(c); read.close(); //关闭输入流 &#125;catch(IOException e) &#123; System.out.println(&quot;读取失败！&quot;); e.printStackTrace(); &#125; System.out.println(new String(c)); //输出读取的内容 &#125;&#125; 运行结果： 1java是一种可以撰写跨平台应用软件的面向对象的程序设计语言。 还可以使用循环的方式读取文件内容。代码如下： 123456789101112131415161718192021222324252627282930import java.io.File;import java.io.IOException;import java.io.Reader;import java.io.FileReader;public class Test&#123; public static void main(String[] args) &#123; File f=new File(&quot;D:/myjava/不存在的文档.txt&quot;); //创建File类实例 Reader read=null; //声明Reader对象 char c[]=new char[(int)f.length()]; int temp=0; int len=0; try &#123; read=new FileReader(f); while((temp=read.read())!=-1) &#123; c[len]=(char)temp; len++; &#125; read.close(); //关闭输入流 &#125;catch(IOException e) &#123; System.out.println(&quot;读取失败！&quot;); e.printStackTrace(); &#125; System.out.println(new String(c)); //输出读取的内容 &#125;&#125; 字符输出流：Writer类 ​ Writer类和OutputStream类，在功能上是一致的，但两者还是存在区别的，前者写入数据的单位是字符，而后者写入的是字节。Writer类本身也是一个抽象类，不能示例化，需要通过子类实例化。Writer类的常用方法如下表所示。 序号 方法 类型 说明 1 public Writer append(char c)throws IOException 方法 将指定的字符c添加都输出流中 2 public abstract void close()throws IOException 抽象 关闭输入流 3 public abstract void flush()throws IOException 抽象 将输出流中未输出的数据强制清出。如果字符流内经有write()方法在缓冲区暂存了数据，使用此方法会令数据立即输出到目的地。 4 public void write(char[] cbuf)throws IOException 方法 将字符数组内的字符写到输出流中 5 public void write(char[] cbuf,int off,int len)throws IOException 抽象 将字符数组内部分字符写到输出流中。其中，off指定在字符数组的初始位置。len指定元素个数 6 public void write(char c)throws IOException 方法 向输出流写入一个字符 7 public void write(String str)throws IOException 方法 写入字符串 8 public void write(String str,int off,int len)throws IOException 方法 将字符串的指定部分写入输出流。其中，off指定了字符串中的起始偏移量。len指定字符个数 ​ 下面以Writer的子类FileWriter为例，对Writer类的常用方法进行介绍。FileWriter的构造方法如下： 12public FileWriter(File file) throws IOExceptionpublic FileWriter(File file,boolean append) throws IOException 向文件写入内容 使用write(char[] cbuf) 12345678910111213141516171819202122232425import java.io.File;import java.io.IOException;import java.io.Writer;import java.io.FileWriter;public class Test&#123; public static void main(String[] args) &#123; File f=new File(&quot;D:/myjava/存在的文档.txt&quot;); //创建File类实例 Writer out=null; //声明Writer对象 String str=&quot;java是面向对象的编程语言&quot;; char c[]=str.toCharArray(); try &#123; out=new FileWriter(f); out.write(c); out.close(); //关闭输入流 System.out.println(&quot;写入成功！&quot;); &#125;catch(IOException e) &#123; System.out.println(&quot;写入失败！&quot;); e.printStackTrace(); &#125; &#125;&#125; 使用write(String str) 123456789101112131415161718192021222324import java.io.File;import java.io.IOException;import java.io.Writer;import java.io.FileWriter;public class Test&#123; public static void main(String[] args) &#123; File f=new File(&quot;D:/myjava/存在的文档.txt&quot;); //创建File类实例 Writer out=null; //声明Writer对象 String str=&quot;java是面向对象的编程语言&quot;; try &#123; out=new FileWriter(f); out.write(str); out.close(); //关闭输入流 System.out.println(&quot;写入成功！&quot;); &#125;catch(IOException e) &#123; System.out.println(&quot;写入失败！&quot;); e.printStackTrace(); &#125; &#125;&#125; ​ 上面的程序可以直接输出字符串，不需要再转换成数组。 在文件末尾追加内容 ​ 使用字符输出流操作时，可以实现文件的追加功能。有两个方式可以实现追加功能，一个是使用Writer类的append()方法，另一个是使用FileWriter的构造方法FileWriter(File file,boolean append)。两者最大的区别是append()可以实现内容的追加，但是无论重复执行多少此，写入的内容都是相同的。而FileWriter(File file,boolean append)则可以不断更新内容。 使用append()追加 12345678910111213141516171819202122232425import java.io.File;import java.io.IOException;import java.io.Writer;import java.io.FileWriter;public class Test&#123; public static void main(String[] args) &#123; File f=new File(&quot;D:/myjava/存在的文档.txt&quot;); //创建File类实例 Writer out=null; //声明Writer对象 String str=&quot;java是一门面向对象的编程语言&quot;; try &#123; out=new FileWriter(f); out.write(str); //写入数据 out.append(&quot;\\nHello world!&quot;); out.close(); //关闭输入流 System.out.println(&quot;写入成功！&quot;); &#125;catch(IOException e) &#123; System.out.println(&quot;写入失败！&quot;); e.printStackTrace(); &#125; &#125;&#125; 文档内容： 12java是一门面向对象的编程语言Hello world! 使用FileWriter构造方法追加 ​ 上面程序重复执行三次后，其写入的数据没有任何改变。append()方法仅仅是追加字符串的内容。下面使用FileWriter的构造方法FileWriter(File file,boolean append)来说实现文件内容的追加。 123456789101112131415161718192021222324import java.io.File;import java.io.IOException;import java.io.Writer;import java.io.FileWriter;public class Test&#123; public static void main(String[] args) &#123; File f=new File(&quot;D:/myjava/存在的文档.txt&quot;); //创建File类实例 Writer out=null; //声明Writer对象 String str=&quot;java是一门面向对象的编程语言\\n&quot;; try &#123; out=new FileWriter(f,true); out.write(str); out.close(); //关闭输入流 System.out.println(&quot;写入成功！&quot;); &#125;catch(IOException e) &#123; System.out.println(&quot;写入失败！&quot;); e.printStackTrace(); &#125; &#125;&#125; 程序执行三次结果： 123java是一门面向对象的编程语言java是一门面向对象的编程语言java是一门面向对象的编程语言 与字节流的区别 ​ 字节流与字符流非常的相似，除了在处理数据单位上的不同之处外，还有哪些不同呢？实际上，字节流是对文件本身进行操作，不需要通过缓冲区。而字节流则需要通过缓冲流来操作文件。也就是说，使用字节流时，就算是没有执行close()方法关闭字节流的操作，还是可以向文件输出内容的。但是在字符流中，若不执行close()方法，就无法向文件写入内容，但可以使用flush()强制刷新内容。 123456789101112131415161718192021222324import java.io.File;import java.io.IOException;import java.io.Writer;import java.io.FileWriter;public class Test&#123; public static void main(String[] args) &#123; File f=new File(&quot;D:/myjava/存在的文档.txt&quot;); //创建File类实例 Writer out=null; //声明Writer对象 String str=&quot;java是面向对象的编程语言&quot;; try &#123; out=new FileWriter(f); out.write(str); out.flush(); //强制清除内容 System.out.println(&quot;写入成功！&quot;); &#125;catch(IOException e) &#123; System.out.println(&quot;写入失败！&quot;); e.printStackTrace(); &#125; &#125;&#125; 执行close()方法时会默认执行flush()方法，因此close()方法可以将缓冲区的内容清除。 参考书目： 《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"字节流","slug":"java/常用类库/字节流","date":"2021-07-29T11:56:45.000Z","updated":"2021-10-27T04:44:06.579Z","comments":true,"path":"2021/07/29/java/常用类库/字节流/","link":"","permalink":"https://silenthly.github.io/2021/07/29/java/%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%BA%93/%E5%AD%97%E8%8A%82%E6%B5%81/","excerpt":"​ 在程序设计中，程序若要读取或写出8位byte的字节数据，应当使用字节流来处理。字节流一般用于读取或写入二进制数据，如图片、音频文件。一般而言，只要是“非文本数据”就应该使用字节流来处理，因为字符流无法保证“非文本数据”的完整性。","text":"​ 在程序设计中，程序若要读取或写出8位byte的字节数据，应当使用字节流来处理。字节流一般用于读取或写入二进制数据，如图片、音频文件。一般而言，只要是“非文本数据”就应该使用字节流来处理，因为字符流无法保证“非文本数据”的完整性。 字节输入流：InputStream类 ​ 所有的字节输入流都是InputStream的子类，InputStream提供的方法可以说是各种字节输入流基本的I/O方法接口。但InputStream类却是抽象类，不能实例化，程序中实际使用的是它的各种’子类对象。InputStream类的常用方法如下表所示。 序号 方法 类型 说明 1 public int available()throws IOException 普通 可以取得输入流中读取的字节数 2 public void close()throws IOException 普通 关闭输入流。在读操作结束后，应该关闭输入流，系统才会释放与这个输入流相关的资源。但InputStream类的close()方法没有任何作用，是它的子类重写该方法。 3 public void mark(int readlimit) 普通 在此输入流中标记当前的位置。但InputStream类的mark()方法没有任何作用，是它的多个子类重写该方法 4 public boolean markSupported 普通 判断当前输入流是否允许标记。若允许，则返回ture，否则返回false 5 public abstract int read()throws IOException 抽象 从输入流读取下一个数据字节作为返回值，但B值会以int类型的值显示，其值介于0~225.若已到达了结尾，则放回-1。 6 public int read(byte[] b)throws IOException 普通 从输入流中读取一定数量的字节并将其存储在缓冲区数组b中。然后将读取的B数据的数量以int值返回。若已到了结尾，则返回-1。 7 public int read(byte[] b,int off,int len)throws IOException 普通 从输入流中读取一定数量的字节并将其存储在缓冲区数组b中。然后将读取的B数据的数量以int值返回。若已到了结尾，则返回-1。其中，off指定在字节数组中开始保存数据的起始下标。len指读取的字节数 8 public void reset()throws IOException 普通 将输入流的指针返回到设置标记的起点 9 public long skip(long n)throws IOException 普通 从输入流中跳过n个指定的字符，并返回跳过的字节数 ​ 下面以InputStream的子类FileInputStream的实例，对InputStream类的常用方法进行介绍。FileInputStream类的详细方法可以参考API帮助文档。 使用read(byte b[])读取文本内容 1234567891011121314151617181920212223import java.io.File;import java.io.IOException;import java.io.InputStream;import java.io.FileInputStream;public class Test&#123; public static void main(String[] args) &#123; File f=new File(&quot;D:/myjava/不存在的文档.txt&quot;); //创建File类实例 InputStream input=null; //声明InputStream对象 byte b[]=new byte[512]; //定义大小为512的字节数组 try &#123; input=new FileInputStream(f); //使用FileInputSteam为InputSteam实例化 input.read(b); input.close(); //关闭输入流 &#125;catch(IOException e) &#123; e.printStackTrace(); &#125; System.out.println(new String(b)); //输出读取的内容 &#125;&#125; 运行结果： 1java是一种可以跨平台应用软件的面向对象的程序设计语言。 ​ 从程序的运行结果可以发现，内容是可以被读取出来的。但是后面还有很多空格，这是因为B类型数组b开辟的空间远大于内容所需空间。剩下的空格会浪费内存空间，这在程序设计中是不合理的。为此，可将上面的程序改为如下范例。 开辟大小合理的byte数组 1234567891011121314151617181920212223import java.io.File;import java.io.IOException;import java.io.InputStream;import java.io.FileInputStream;public class Test&#123; public static void main(String[] args) &#123; File f=new File(&quot;D:/myjava/不存在的文档.txt&quot;); //创建File类实例 InputStream input=null; //声明InputStream对象 byte b[]=new byte[(int)f.length()]; //根据文件内容的大小定义数组空间 try &#123; input=new FileInputStream(f); //使用FileInputSteam为InputSteam实例化 input.read(b); input.close(); //关闭输入流 &#125;catch(IOException e) &#123; e.printStackTrace(); &#125; System.out.println(new String(b)); //输出读取的内容 &#125;&#125; 运行结果： 1java是一种可以跨平台应用软件的面向对象的程序设计语言。 ​ 除了上述的方法，还可以循环地从文件中将一个个字节读取进来。这个方式直接使用read()方法。 循环读取文件内容 1234567891011121314151617181920212223242526272829import java.io.File;import java.io.IOException;import java.io.InputStream;import java.io.FileInputStream;public class Test&#123; public static void main(String[] args) &#123; File f=new File(&quot;D:/myjava/不存在的文档.txt&quot;); //创建File类实例 InputStream input=null; //声明InputStream对象 byte b[]=new byte[(int)f.length()]; //根据文件内容的大小定义数组空间 int temp=0; //接收每一个读取的内容 int len=0; //读取数据的个数 try &#123; input=new FileInputStream(f); //使用FileInputSteam为InputSteam实例化 while((temp=input.read())!=-1) &#123; b[len]=(byte)temp; len++; &#125; input.close(); &#125;catch(IOException e) &#123; e.printStackTrace(); &#125; System.out.println(new String(b)); //输出读取的内容 &#125;&#125; 运行结果： 1java是一种可以跨平台应用软件的面向对象的程序设计语言。 以上三种方式，在开发中都能用到，但建议使用第三种方式。还有一种方法可以书写代码，相对于上面的代码，以下代码可读性比价强。 1234567891011121314151617181920212223import java.io.File;import java.io.IOException;import java.io.InputStream;import java.io.FileInputStream;public class Test&#123; public static void main(String[] args) throws IOException &#123; File f=new File(&quot;D:/myjava/不存在的文档.txt&quot;); //创建File类实例 InputStream input=null; //声明InputStream对象 byte b[]=new byte[(int)f.length()]; //根据文件内容的大小定义数组空间 int temp=0; //接收每一个读取的内容 int len=0; //读取数据的个数 input=new FileInputStream(f); //使用FileInputSteam为InputSteam实例化 while((temp=input.read())!=-1) &#123; b[len]=(byte)temp; len++; &#125; input.close(); System.out.println(new String(b)); //输出读取的内容 &#125;&#125; ​ 上面程序中，在定义方法的同时使用throws关键字声明异常，这样在方法中可以不使用try…catch语句。虽然书写分别，但这样不能处理异常。当然，也可组合来写。 其他子类实例 ​ 在本文中，使用了子类FileInputStream对InputStream类进行实例化，这是以文件作为输入源的方式，除此之外，还有其他更多的方式。比如字节数组作为输入源(ByteArrayInputStream)、对象作为输入源(ObjectInputStream)、字符串作为输入源(StringBufferInputStream)、缓存输入流(BufferedInputStream)等等，以上样例可通过浏览常用输入字节流InputStream介绍_java_脚本之家 (jb51.net)简单了解 字节输出流：OutputStream类 ​ 所有的字节输入流都是InputStream的子类，InputStream类也是抽象类，不能实例化，程序中实际使用的是它的各种‘子类对象。InputStream类的常用方法如下表所示。 序号 方法 类型 说明 1 public void close()throws IOException 普通 关闭此输出流，并释放任何与之相关的系统资源。OutputStream类本身的close()方法没有任何作用，是它的子类重写该方法。 2 public void flush()throws IOException 普通 刷新缓冲区，但OutputStream的flush()方法没有任何操作。 3 public void write(byte[] b)throws IOException 普通 将B数组的数据写到输出流 4 public void write(byte[] b,int off,int len)throws IOException 普通 将B数组的部分数据写到输出流。其中，off指定数组的起始下标。len指读取的元素个数 5 public abstract void write(int b)throws IOException 抽象 将一个B数字写到输出流，但代表该B值的参数为int值 ​ 下面以OutputStream的子类FileOutputStream的实例，对OutputStream类的常用方法进行介绍。可以使用write()方法向指定的文件写入内容。 12345678910111213141516171819202122232425import java.io.File;import java.io.OutputStream;import java.io.FileOutputStream;import java.io.IOException;public class Test&#123; public static void main(String[] args) &#123; File f=new File(&quot;D:/myjava/存在的文档.txt&quot;); OutputStream out=null; String str=&quot;Hello java!&quot;; byte b[]=str.getBytes(); try &#123; out=new FileOutputStream(f); out.write(b); out.close(); System.out.println(&quot;写入成功&quot;); &#125;catch(IOException e) &#123; System.out.println(&quot;写入失败&quot;); e.printStackTrace(); &#125; &#125;&#125; ​ 在上面程序中，通过getBytes()方法把字符串转为byte数组类型。再通过FIleOutputStream类的write()方法将内容向文件写入。值得注意的是，若指定的文件在创建前不存在，则操作之后的系统会自动创建该文件，并将内容写入。 在文件末尾追加内容 ​ 上面的程序在重新执行时会覆盖原文件的内容，在FileOutputStream类的构造方法中，提供了在文件末尾追加内容的功能。 1public FileOutputStrream(File file,boolean append)throws FileNotFoundException 将传入FileOutputStream构造方法中的参数append赋值为ture即可，示例如下： 12345678910111213141516171819202122232425import java.io.File;import java.io.OutputStream;import java.io.FileOutputStream;import java.io.IOException;public class Test&#123; public static void main(String[] args) &#123; File f=new File(&quot;D:/myjava/存在的文档.txt&quot;); OutputStream out=null; String str=&quot;\\njava学习笔记&quot;; byte b[]=str.getBytes(); try &#123; out=new FileOutputStream(f,true); out.write(b); out.close(); System.out.println(&quot;写入成功&quot;); &#125;catch(IOException e) &#123; System.out.println(&quot;写入失败&quot;); e.printStackTrace(); &#125; &#125;&#125; 文件内容： 12Hello java!java学习笔记java学习笔记 文件输出流注意事项 1、目标文件名可以任意指定，但不能与已存在的目录同名，否则抛出FileNotFoundException异常。 2、目标文件存在的目录必须存在，否则抛出FileNotFoundException异常。 相关资源：java中FileInputStream的available() 方法的作用是什么？_百度知道 (baidu.com) 参考书目： 《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"文件类:File类","slug":"java/常用类库/文件类File类","date":"2021-07-29T03:28:24.000Z","updated":"2021-10-27T04:48:26.864Z","comments":true,"path":"2021/07/29/java/常用类库/文件类File类/","link":"","permalink":"https://silenthly.github.io/2021/07/29/java/%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%BA%93/%E6%96%87%E4%BB%B6%E7%B1%BBFile%E7%B1%BB/","excerpt":"​ 文件通常是程序中数据的初始源和目的地。对文件的输入/输出操作在编程语言中是普遍存在的。java提供了通过java.io包中File类实现对文件的操作。 File类简介 ​ java.io.File类不属于java流系统，但它是文件流进行文件操作的辅助类，主要用于操纵文件即文件目录，包括删除、重命名文件或目录、查询文件的属性、创建子目录、列出目录下的文件等。","text":"​ 文件通常是程序中数据的初始源和目的地。对文件的输入/输出操作在编程语言中是普遍存在的。java提供了通过java.io包中File类实现对文件的操作。 File类简介 ​ java.io.File类不属于java流系统，但它是文件流进行文件操作的辅助类，主要用于操纵文件即文件目录，包括删除、重命名文件或目录、查询文件的属性、创建子目录、列出目录下的文件等。 ​ File类的对象是一个“文件或目录”的抽象代表。File类的对象并不打开文件或目录，而是指定要操操作的文件或目录。File类的对象一旦创建，就不能再更改，就是说它代表的抽象路径是不能改变的。File类的常量、构造方法和常用方法如下表所示。 序号 常量或方法 类型 说明 1 public static String pathSeparator 常量 代表操作系统独特的名称分隔符。unix系统下，其值为冒号“:”，在windows下其值为分号“;” 2 public static String separator 常量 代表操作系统独特的名称路径分隔符。unix系统下，其值为斜杠“/”，在windows下其值为反斜杠“\\”，但在java中需要使用“\\\\”表示“\\”，所以其值为“\\\\” 3 pubic File(String pathname) 构造 创建File对象，pathname表示文件或目录的路径 4 pubic File(String parent,String child) 构造 创建File对象，parent表示指定的公共目录路径；child表示指定的子目录路径或文件名 5 pubic File(File parent,String child) 构造 创建File对象，parent表示指定的公共目录路径，这里直接使用的是File对象；child表示指定的子目录路径或文件名 6 public boolean canRead() 普通 检测应用程序是否可读此文件 7 public boolean canWrite() 普通 检测应用程序是否可写此文件 8 public int compare To(File pathname) 普通 按字母顺序比较两个抽象路径名。若为0，表示相同，否则不相同 9 public boolean createNewFile() throws IOException 普通 此文件若不存在，则创建新文件。创建成功返回true，否则返回false 10 public boolean delete() 普通 删除文件或目录。如果File对象表示的是目录，则该目录为空，方可删除。删除成功返回true，否则返回false 11 public boolean exists() 普通 判断指定的文件或目录是否存在。若存在，则返回true，否则返回false 12 public File getAbsolutePath() 普通 返回指定文件或目录的绝对路径 13 public File String getAbsolutePath() 普通 返回指定文件或目录的绝对路径并以字符串的形式表示 14 public String getName() 普通 返回此File对象表示的文件或目录的名称 15 public String getParent() 普通 返回此抽象路径名父项的路径名字符串，如果此路径名未指定父目录，则返回null 16 public File getParentFile() 普通 返回此抽象路径名父项的抽象路径名，如果此路径名未指定父目录，则返回 null 17 public String getPath() 普通 返回此File对象的抽象路径并以字符串的形式表示 18 public boolean isAbsolute() 普通 测试此File对象表示的文件或目录是否为绝对路径。如果是则返回true，否则返回false 19 public boolean isDirectory() 普通 测试此File对象表示的文件是否是一个目录。如果是则返回true，否则返回false 20 public boolean isFile() 普通 测试此File对象表示的文件是否是一个文件。如果是则返回true，否则返回false 21 public boolean isHidden() 普通 测试此File对象表示的文件是否是一个隐藏文件。如果是则返回true，否则返回false 22 public long lastModified() 普通 返回File对象表示的文件或目录最后一次被修改的时间 23 public long length() 普通 返回File对象表示的文件或目录的长度，单位为字节。若File对象表示的是一个目录，则返回值是不确定的 24 public String[] list() 普通 返回有此File对象表示的目录中的文件和目录的名称所组成字符串数组 25 public String[] list(FilenameFilter filter) 普通 返回由包含在目录中的文件和目录名称所组成的字符串数组。参数filter表示一个文件过滤器，此方法返回符合过滤器要求的所有文件和目录的字符串名称列表 26 public File[] listFiles() 普通 以File[]类型返回此File对象表示的所有子目录或文件。若File对象表示的是目录，则返回目录下所有的文件和目录；如果表示的是文件，则返回null 27 public File[] listFiles(FilenameFilter filter) 普通 与前者相同，但需要利用filter参数过滤出所有的子目录或文件 28 public static File[] listRoots() 普通 列出可用的文件系统根目录 29 public boolean mkdir() 普通 创建File对象指定的目录。如果创建成功则返回true，否则返回false 30 public boolean mkdirs() 普通 创建File对象指定的目录，如果此目录的父目录不存在，则还会创建父目录。如果创建成功则返回true，否则返回false。注意，如果创建的部分父目录出现异常，则已创建的父目录不会撤销 31 public boolean renameTo(File dest) 普通 重命名File对象表示的文件 32 public boolean setReadOnly() 普通 将此File对象表示的文件或目录设置为只读属性。成功则返回true，否则返回false 黑色加粗为在文章中被使用过，更多方法具体参考API帮助文档。 通过File类度文件进行操作 1、创建文件 ​ 从表中可以发现createNewFile()方法声明IOException异常，所以使用该方法时，必须使用一个try…catch语句进行异常处理。 123456789101112131415161718import java.io.File;import java.io.IOException;public class Test&#123; public static void main(String[] args) &#123; File f=new File(&quot;D:\\\\myjava&quot;,&quot;不存在的文档.txt&quot;); try &#123; f.createNewFile(); System.out.println(&quot;创建成功！&quot;); &#125;catch(IOException e) &#123; System.out.println(&quot;创建失败&quot;); e.printStackTrace(); &#125; &#125;&#125; 运行结果： 1创建成功！ ​ 在以上程序中，File f=new File(“D:\\myjava”,“不存在的文档.txt”)可以有多种写法，如： 12File f=new File(&quot;D:\\\\myjava\\\\不存在的文档.txt&quot;);File f=new File(&quot;D:&quot;+File.separator+&quot;myjava&quot;+File.separator+&quot;不存在的文档.txt&quot;); ​ 运行程序后可以在”D:\\myjava“目录下见到已创建好的&quot;不存在的文档.txt&quot;文件。 2、删除文件 ​ File类中含有删除文件的方法delete()。 123456789101112131415161718192021222324252627282930import java.io.File;import java.io.IOException;public class Test&#123; public static void main(String[] args) &#123; File f=new File(&quot;D:\\\\myjava\\\\不存在的文档.txt&quot;); //指向文件 if(f.exits()) &#123; f.delete(); //删除文件 System.out.println(&quot;删除成功！&quot;); &#125; else &#123; createFile(File f); //调用createFile()方法创建文件 &#125; &#125; public static void createFile(File f) &#123; try &#123; f.createNewFile(); System.out.println(&quot;创建成功！&quot;); &#125;catch(IOExcetion e) &#123; System.out.println(&quot;创建失败！&quot;); e.printStackTrace(); &#125; &#125;&#125; ​ 在以上程序中，若文件已存在，则执行delete()删除文件。如果文件不存在，先创建文件再删除。 3、取得文件的属性 ​ 在File类中提供了许多获取文件属性的方法，下面就常用的方法进行综合使用。 1234567891011121314151617181920import java.io.File;public class Test&#123; public static void main(String[] args) &#123; File f=new File(&quot;D:&quot;+File.separator+&quot;myjava&quot;+File.separator+&quot;不存在的文档.txt&quot;); if(f.exists()) &#123; System.out.println(&quot;文件名：&quot;+f.getName()); System.out.println(&quot;文件路径：&quot;+f.getPath()); System.out.println(&quot;文件大小：&quot;+f.length()); System.out.println(&quot;文件最后修改时间：&quot;+f.lastModified()); System.out.println(&quot;文件可读：&quot;+f.canRead()+&quot;\\n文件可写：&quot;+f.canWrite()); &#125; else &#123; System.out.println(&quot;该文件不存在！&quot;); &#125; &#125;&#125; 运行结果： 123456文件名：不存在的文档.txt文件路径：D:\\myjava\\不存在的文档.txt文件大小：0文件最后修改时间：1627673057096文件可读：true文件可写：true ​ 在以上程序中，如果文件存在，则输出文件的各个属性，否则输出“文件不存在！”。其中getPath()的返回值等于“getParent()+getName”。length()返回值的单位为字节。lastModified()方法返回值为最后一次修改时间与时间点(1970年1月1日，00:00:00GMT)之间的时间差毫秒数。 4、输出目录中的所有文件 1234567891011121314151617181920import java.io.File;public class Test&#123; public static void main(String[] args) &#123; File f=new File(&quot;D:\\\\myjava&quot;); String list[]=f.list(); System.out.println(&quot;——list()——&quot;); for(int i=0;i&lt;list.length;i++) &#123; System.out.println(list[i]); &#125; System.out.println(&quot;——listFile()——&quot;); File listFile[]=f.listFiles(); for(int i=0;i&lt;list.length;i++) &#123; System.out.println(listFile[i]); &#125; &#125;&#125; 运行结果： 1234567891011121314——list()——AgeOutOfBoundsException.classorgPerson.javaTest.classTest.java不存在的文档.txt——listFile()——D:\\myjava\\AgeOutOfBoundsException.classD:\\myjava\\orgD:\\myjava\\Person.javaD:\\myjava\\Test.classD:\\myjava\\Test.javaD:\\myjava\\不存在的文档.txt ​ 在以上程序中，listFile()输出的信息比list()输出的信息更详细，而且listFiles()的返回值是File类型，可以直接使用该文件。 5、创建目录 ​ File类除了提供对文件的操作方法以外，还提供了对目录的创建方法mkdir()和mkdirs()。两者不同的是，mkdir()只能创建单级目录，即只能在已存在的目录中创建目录。而mkdirs()可以创建多级目录，可以含有子目录，即可以在不存在的目录中创建文件夹。 12345678910111213141516171819202122232425import java.io.File;public class Test&#123; public static void main(String[] args) &#123; File f=new File(&quot;D:\\\\myjava\\\\mkdir&quot;); if(f.mkdir()) &#123; System.out.println(&quot;D:\\\\myjava\\\\mkdir创建成功！&quot;); &#125; else &#123; System.out.println(&quot;D:\\\\myjava\\\\mkdir创建失败！&quot;); &#125; File f1=new File(&quot;D:\\\\myjava\\\\mkdirs\\\\Directory&quot;); if(f1.mkdirs()) &#123; System.out.println(&quot;D:\\\\myjava\\\\mkdirs\\\\Directory创建成功！!&quot;); &#125; else &#123; System.out.println(&quot;D:\\\\myjava\\\\mkdirs\\\\Directory创建失败！!&quot;); &#125; &#125;&#125; 运行结果： 12D:\\myjava\\mkdir创建成功！D:\\myjava\\mkdirs\\Directory创建成功！! 小试身手 题目：给定一个目录，要求列出此目录下的所有文件和目录。 ​ 这个程序首先要可以传进路径，所以需要使用Scanner类输入路径。再者，给定的目录可能包含子目录，所以需要递归。如果是文件，直接大一其名称，若是目录，则需要递归调用遍历方法。 代码示例： 1234567891011121314151617181920212223242526272829import java.io.File;import java.util.Scanner;public class Test&#123; public static void main(String[] args) &#123; Scanner scan=new Scanner(System.in); System.out.println(&quot;请输入目录路径：&quot;); String path=scan.next(); File f=new File(path); filelist(f); &#125; public static void filelist(File f) &#123; if(f.isFile()) &#123; System.out.println(&quot;\\t&quot;+f.getName()); &#125; else if(f.isDirectory()) &#123; System.out.println(&quot;目录：&quot;+f.getPath()); File list[]=f.listFiles(); for(int i=0;i&lt;list.length;i++) &#123; filelist(list[i]); &#125; &#125; &#125;&#125; 运行结果： 12345678910111213141516目录：D:\\myjava AgeOutOfBoundsException.class目录：D:\\myjava\\mkdir目录：D:\\myjava\\mkdirs目录：D:\\myjava\\mkdirs\\Directory目录：D:\\myjava\\org目录：D:\\myjava\\org\\com目录：D:\\myjava\\org\\com\\pack目录：D:\\myjava\\org\\com\\pack\\pack PackTest.class目录：D:\\myjava\\org\\com\\pack\\stu Student.class Person.java Test.class Test.java 不存在的文档.txt ​ 除了使用&quot;\\\\“以外，还可以使用”/&quot;，因为&quot;\\\\“是”/&quot;的转义符。如：D:/myjava 参考书目： 《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"数据流的概念和划分","slug":"java/常用类库/数据流的概念和划分","date":"2021-07-28T12:48:58.000Z","updated":"2021-10-27T04:49:12.960Z","comments":true,"path":"2021/07/28/java/常用类库/数据流的概念和划分/","link":"","permalink":"https://silenthly.github.io/2021/07/28/java/%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%BA%93/%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%88%92%E5%88%86/","excerpt":"​ 流是java语言中用来处理输入输出的方式。采用流的方式，使得开发人员可以方便的对不同的数据进行处理或保存数据。文件是系统保存数据的地方，面对不同的数据，java提供了不同的流。","text":"​ 流是java语言中用来处理输入输出的方式。采用流的方式，使得开发人员可以方便的对不同的数据进行处理或保存数据。文件是系统保存数据的地方，面对不同的数据，java提供了不同的流。 数据流的概念 ​ 流的概念源于unix中的管道概念。在unix中，管道是一条不间断的字节流，用来实现程序或进程间的通信，或读写外围设备、外部文件等。而java中的流是有序的数据序列，是传递数据信息的载体，也是程序中的数据所经历的路径。流根据方向可以方向输入和输出两种，输入流是将数据原传递给程序，输出流是将数据从程序传递到目的地，如内存、文件、网络等。 ​ java程序的所有读写操作都是通过流来实现的。根据组成流的不同，可以将其分为字节流和字符流，字节流是由字节组成的，主要用在处理二进制数据，字符流是字符组成，主要是用于处理文本的数据。 ​ java中流的实现是定义在java.io包内部的类层次结果中。所以要使用流，必须导入java.io包。 ps：在java中，一个字节有8b，一个字符由两个字节组成。 数据流的划分 ​ java可以分为两种类型的流，即字节流和字符流。一般来说，用任何一种类型的流都可以完成相应的编程任务，但是在一些特殊的情况下，选择其中某一种类型的流可以获得更好的效率。 ​ 字节流类型在java的输入/输出系统中提供了InputStream和OutputStream两个抽象类，分别实现字节数据的输入/输出。抽象类InputStream是所有输入字节流的父类，其结构层次如下图1-1所示。 图1-1 ​ 同理，抽象类OutputStream是所有输出字节流的父类，OutputStream提供了抽象方法Write()方法。其结构层次如下图1-2所示。 图1-2 ​ 字符流也分为读流数据类和写流数据类，即Reader类和Writer类及其子类都是处理字符流，抽象类Reader是所有输入字符流的父类，Reader提供了read()和close()抽象方法。其结构层次如下图1-3所示。 图1-3 ​ 抽象类Writer是所有输出字符流的父类，Writer提供了必须实现的抽象方法write()。其结构层次如下图1-4所示。 图1-4 ​ 在java中除了又在java.io包中有“流”类外，还有一个内置流位于java.lang包中。这个类就是System类，它表示系统类，但实际上System类对于java输入/输出系统是有支持的。System类包含了3个预定的流变量，分别是in、out和err，它们被声明为public和static，这就意味着可以不通过System类的对象就可以直接调用。 ​ System.out是标准输出流，默认的情况下是向显示屏输出。System.in是标准输入流，在默认情况下是输入键盘的数据。System.err是标准错误流，默认的情况下是向显示屏输出。 参考链接： JAVA数据流的概述 WORD版 电子书 下载-脚本之家 (jb51.net) 参考书目： 《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com) 相关资源： 深入理解 Java中的 流 (Stream) - 石头儿 - 博客园 (cnblogs.com) Java流是什么？输入/输出流又是什么？ (biancheng.net)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"断言(assertion)","slug":"java/基本知识/断言(assertion)","date":"2021-07-28T03:41:47.000Z","updated":"2021-10-27T04:49:46.451Z","comments":true,"path":"2021/07/28/java/基本知识/断言(assertion)/","link":"","permalink":"https://silenthly.github.io/2021/07/28/java/%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/%E6%96%AD%E8%A8%80(assertion)/","excerpt":"​ 断言功能在JDk1.4首次提供，专门用来进行代码测试和纠错，以提高程序的可靠性。断言在程序开发中是一种常用的调试方式，很多编程语言都支持这一功能，如C语言、C++语言等，只是支持的形式不同而已。从理论上来说，通过断言可以证明序的正确性，但这是一项相当复杂的工作，所以在开发中应用不多。 ​ 断言在程序中只是一条语句，断言可以对布尔表达式进行检查。一旦这个表达式的值为false，就说明该程序已经处于不正确的状态，会提示错误信息。","text":"​ 断言功能在JDk1.4首次提供，专门用来进行代码测试和纠错，以提高程序的可靠性。断言在程序开发中是一种常用的调试方式，很多编程语言都支持这一功能，如C语言、C++语言等，只是支持的形式不同而已。从理论上来说，通过断言可以证明序的正确性，但这是一项相当复杂的工作，所以在开发中应用不多。 ​ 断言在程序中只是一条语句，断言可以对布尔表达式进行检查。一旦这个表达式的值为false，就说明该程序已经处于不正确的状态，会提示错误信息。 格式一： 1assert 表达式 格式一： 1assert 布尔表达式:细节描述信息; ​ 其中，如果布尔表达式的结果值为ture，则没有任何的错误提示信息。若布尔表达式的结果值为false，则会有错误提示信息。如果在定义断言时没有声明细节描述信息，那么系统将会使用默认的错误信息提示方式。 注意：断言返回的布尔值不能作为条件判断语句。 代码示例： 12345678public class Test&#123; public static void main(String[] args) &#123; int score=84; assert score&gt;85:&quot;分数必须高于85才能得优秀&quot;; //使用断言 &#125;&#125; ​ 在程序中，布尔表达式score&gt;85的结果值必定为false，就是说此处断言的结果是错误的。此时运行程序是没有任何信息输出的，因为默认情况下java断言是关闭的，需要在java运行时使用以下参数打开： 12java -ea 文件名 //打开断言功能java -da 文件名 //关闭断言功能 -ea与-da选项对那些没有类加载器的“系统类”不起作用。对于这些系统类，要使用-enablesystemassertions/-esa选项来打开断言功能。 运行结果： 12Exception in thread &quot;main&quot; java.lang.AssertionError: 分数必须高于85才能得优秀 at Test.main(Test.java:6) 若布尔表达式的结果值为ture，则验证不会出现任何错误提示信息。 【使用断言有以下几个作用】 断言可用于形成程序的文档。由于程序中使用断言，描述了程序的需求说明可以利用第三方软件工具从带有断言的程序中抽取出需求说明。 保证程序的正确性与健壮性。在程序使用断言，可以帮助开发人员精确陈程序各个组成部分的性质，从而提高程序的正确性，并能够处理各种异常情况。 支持程序的动态调试。程序中的断言在运行过程中可以动态地检测，测程度也可由程序的运行环境控制，从而为调试和测试程序提供了强有力的工具。 构成异常处理的基础。当检测某一程序断言不成立时，即布尔表达式结果值为 false。程序将引发一个异常，程序控制将转向异常处理程序。这种机制是提供灵活的异常处理机制的基础。 参考书目： 《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"自定义异常类","slug":"java/异常/自定义异常类","date":"2021-07-28T01:54:18.000Z","updated":"2021-10-27T04:49:52.898Z","comments":true,"path":"2021/07/28/java/异常/自定义异常类/","link":"","permalink":"https://silenthly.github.io/2021/07/28/java/%E5%BC%82%E5%B8%B8/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E7%B1%BB/","excerpt":"​ 虽然java的内置异常类有很多，但是这些异常类都是针对常见的异常。在某些时候，它们是不能满足程序中的个别需求的。如人的年龄为-19岁，这就需要开发人员来自定义一些异常类来处理程序中某种特定情况。 ​ 自定义的异常类至少应继承Throwable类，才可以作为异常类。但是在程序设计中，自定义的异常类很少是Error，所以一般都是让自定义类继承现有Exception类或Exception类的子类来创建自定义的异常类。自定义的异常类语法与普通类的语法没有多大差异。","text":"​ 虽然java的内置异常类有很多，但是这些异常类都是针对常见的异常。在某些时候，它们是不能满足程序中的个别需求的。如人的年龄为-19岁，这就需要开发人员来自定义一些异常类来处理程序中某种特定情况。 ​ 自定义的异常类至少应继承Throwable类，才可以作为异常类。但是在程序设计中，自定义的异常类很少是Error，所以一般都是让自定义类继承现有Exception类或Exception类的子类来创建自定义的异常类。自定义的异常类语法与普通类的语法没有多大差异。 格式： 1234[public] class 自定义的异常类名 extends Exception类或Exception类的子类&#123; //类体&#125; ​ 其中，一般将自定义的异常类名命名为XXXException，而XXX表示该自定义异常类的作用。自定义的异常类一般含有两个构造方法，一个是无参构造法，一个是接收String类型参数的有参构造方法，该字符串参数表示的是一个定制的异常消息，并将该消息传递给父类的构造方法。 代码示例： 1234567891011121314151617181920212223242526272829303132333435import java.util.Scanner;class AgeOutOfBoundsException extends Exception //自定义的异常类&#123; public AgeOutOfBoundsException()&#123;&#125; public AgeOutOfBoundsException(String message) &#123; super(message); &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; Scanner read=new Scanner(System.in); int arr[]=new int[5]; try &#123; for(int i=0;i&lt;arr.length;i++) &#123; System.out.println(&quot;请输入第&quot;+(i+1)+&quot;个数据：&quot;); arr[i]=read.nextInt(); if(arr[i]&lt;0||arr[i]&gt;100) &#123; throw new AgeOutOfBoundsException(&quot;您输入第“+(i+1)+”个数据不在0~100的范围内&quot;); &#125; &#125; &#125;catch(AgeOutOfBoundsException e) &#123; System.out.println(e); &#125;catch(Exception e) &#123; System.out.println(e); &#125; &#125;&#125; 运行结果： 12345请输入第1个数据：54请输入第2个数据：153AgeOutOfBoundsException: 您输入第“+(i+1)+”个数据不在0~100的范围内 ​ 创建自定义异常类是为了表示应用程序的一些错误类类型，为代码可能发生的一个或多个问题提供新含义。自定义异常类可以显示代码多个位置之间的错误相似性，也可区分代码运行时可能出现的相似问题的一个或多个错误，或给出应用程序中一组错误的特定含义。 参考书目： 《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"java的异常处理机制","slug":"java/异常/java的异常处理机制","date":"2021-07-27T11:34:14.000Z","updated":"2021-10-27T04:45:01.940Z","comments":true,"path":"2021/07/27/java/异常/java的异常处理机制/","link":"","permalink":"https://silenthly.github.io/2021/07/27/java/%E5%BC%82%E5%B8%B8/java%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/","excerpt":"​ 尽管java运行时环境提供了默认的异常处理程序，这对程序的调试是很有作用的。但是在一般情况下，开发人员更希望的是自己处理异常。这样做有两个好处，一是可以允许开发人员自己修正错误，二是可以防止程序自动终止允许。","text":"​ 尽管java运行时环境提供了默认的异常处理程序，这对程序的调试是很有作用的。但是在一般情况下，开发人员更希望的是自己处理异常。这样做有两个好处，一是可以允许开发人员自己修正错误，二是可以防止程序自动终止允许。 try···catch···finally捕获异常 ​ java语言将可能抛出异常的语句放在try语句块，其后使用catch语句块捕获这些语句所抛出的第一个异常并进行处理。 格式： 123456789101112131415161718//try块内使用的对象必须外置定义，在try块内定义的变量属于局部变量try&#123; //可能抛出异常的语句 catch(异常类型1 异常对象1) &#123; //对该类型的异常进行处理语句 &#125; ... catch(异常类型n 异常对象n) &#123; //对该类型的异常进行处理语句 &#125; [finally //可选择是否使用 &#123; //一定会运行的程序代码 &#125;]&#125; ​ 其中，try语句块中出现多种异常，可以使用多个catch语句块来捕获这些异常。原则上，try语句块不能独立存在，其后至少有一个catch语句块或finally语句块。finally语句块不需要必须存在，可以根据需求决定是否添加。catch语句块只需要一个形参指明它所能捕获的异常类型，而这个类必须是Throwable类的子类。如果省略了finally语句块，则在catch语句块执行结束后，程序会跳到try…catch语句块之后的代码继续执行。 finally语句不会执行的情况 1、在finally语句块之前执行了System.exit()退出执行。 2、在finally语句块执行之前，程序所在的线程死亡。 try…catch语句 使用try…catch语句捕获异常： 1234567891011121314151617public class Test&#123; public static void main(String[] args) &#123; int i[]=&#123;1,2,3&#125;; try &#123; System.out.println(&quot;i[0]=&quot;+i[0]); System.out.println(&quot;i[3]=&quot;+i[3]); &#125; catch(ArrayIndexOutOfBoundsException e) &#123; System.out.println(&quot;异常信息：&quot;+e); &#125; System.out.println(&quot;正常执行：\\ni[0]=&quot;+i[0]); &#125;&#125; 运行结果： 1234i[0]=1异常信息：java.lang.ArrayIndexOutOfBoundsException: 3正常执行：i[0]=1 ​ 在上面的程序运行结果可以发现，在程序中加入异常处理代码后，当异常发生时，整个程序没有因为异常的出现而中断执行。 try…catch…finally语句 使用try…catch…finally语句捕获异常： 123456789101112131415161718192021public class Test&#123; public static void main(String[] args) &#123; int i[]=&#123;1,2,3&#125;; try &#123; System.out.println(&quot;i[0]=&quot;+i[0]); System.out.println(&quot;i[3]=&quot;+i[3]); &#125; catch(ArrayIndexOutOfBoundsException e) &#123; System.out.println(&quot;异常信息：&quot;+e); &#125; finally &#123; System.out.println(&quot;——————无论是否有异常，都会执行finally语句块——————&quot;); &#125; System.out.println(&quot;正常执行：\\ni[0]=&quot;+i[0]); &#125;&#125; 运行结果： 12345i[0]=1异常信息：java.lang.ArrayIndexOutOfBoundsException: 3——————无论是否有异常，都会执行finally语句块——————正常执行：i[0]=1 ​ 其中，无论try语句块内发生了哪种异常，也不论try语句块和catch语句块是否可以正常执行，finally语句块都会被保证执行。若catch语句无法捕获异常，或者有其他异常产生，在将新的异常传递给java运行的环境之前，都会先执行finally语句块。因此，可以使用finally语句块清除try…catch…finally语句中的一些状态。例如，在I/O编程或数据库编程中，使用finally语句块执行close动作。 多个catch语句 ​ 在实际的程序开发中，不会只存在一个异常，可能会有多个异常同时存在的情况，这就需要多个语句块进行处理。使用多个语句块时会出现一个问题，即catch语句块的排列顺序问题。catch语句块捕获异常是按照顺序的，如果前面已经有一个异常类型被捕获了，但同时满足后面的异常类型时，就不会被捕获了。 错误的catch语句块顺序 123456789101112131415161718192021222324252627282930313233343536import java.util.Scanner; //导入输入包，可以对程序进行输入操作，后面再讲解import java.util.InputMismatchException; //用于捕获输入不匹配异常public class Test&#123; public static void main(String[] args) &#123; Scanner read=new Scanner(System.in); int arr[]=new int[5]; try &#123; System.out.println(&quot;请输入数组元素：&quot;); for(int i=0;i&lt;arr.length;i++) &#123; arr[i]=read.nextInt(); &#125; System.out.println(&quot;请输入数组元素索引：&quot;); int n=read.nextInt(); System.out.println(&quot;arr[&quot;+n+&quot;]=&quot;+arr[n]); int m=arr[3]/arr[0]; System.out.println(&quot;m=&quot;+m); &#125; catch(Exception e) &#123; System.out.println(&quot;异常信息：&quot;+e); &#125; catch(RuntimeException e) &#123; System.out.println(&quot;异常信息：&quot;+e); &#125; catch(InputMismatchException e) &#123; System.out.println(&quot;异常信息：&quot;+e); &#125; System.out.println(&quot;程序结束&quot;); &#125;&#125; 运行结果： 1234567Test.java:26: 错误: 已捕获到异常错误RuntimeException catch(RuntimeException e) ^Test.java:30: 错误: 已捕获到异常错误InputMismatchException catch(InputMismatchException e) ^2 个错误 ​ 以上程序在编译时，提示“已捕获到异常错 RuntimeException&quot;”和“已捕获到异常错误 InputMismatchException’”。因为 Exception捕获了异常类型范围最大，所以后面的 catch语句块就无法再被执行了。在java中，不能达到的代码也是一个错误。因此，第一个 catch语句块将处理所有的面向 Exception的异常，包括了 RuntimeException类型和InputMismatchException类型的异常，这意味着第二、第三个 catch语句块将永远不会被执行。因此，一般的做法是将最细化的异常类(最小子异常类)放在前面，之后再使用父异常类。即如果两个异常是类存在直接的继关系，则子类应该写在前面，父类应该写在后面，否则在编译时将会报错。还可以在开发中，无论遇到什么异常类型都可以直接使用Exception类进行处理。 抛出异常信息的其他方法 1、getMessage()，输出异常的性质。 2、printStackTrace()，输出该异常的类型。性质、栈及出现在程序中的位置。 3、getStackTrace()，返回该异常的跟踪信息。 4、toString()，输出该异常的类型和性质。 嵌套try语句块 ​ try语句可以被嵌套，在一个try语句块内可以定义另一个语句块。每次进入try语句块，异常的前后关系都会被推进一个堆栈。如果内部的try语句块不含合适的catch处理程序，堆栈将其弹出，而由下一个try语句块decatch处理程序来检查是否与之匹配。这个过程一直持续到找到匹配的catch语句块或直到所有的try语句块被检测完毕。如果还没有找到合适的异常处理程序，那么将由默认的异常处理程序自动处理这个异常。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.util.Scanner;import java.util.InputMismatchException;public class Test&#123; public static void main(String[] args) &#123; Scanner read=new Scanner(System.in); int arr[]=new int[5]; int n=0; try &#123; try //内部第一个try语句块 &#123; System.out.println(&quot;请输入数组元素：&quot;); for(int i=0;i&lt;arr.length;i++) &#123; arr[i]=read.nextInt(); &#125; System.out.println(&quot;请输入数组元素索引：&quot;); n=read.nextInt(); &#125; catch(InputMismatchException e) &#123; System.out.println(&quot;输入类型不匹配异常信息：&quot;+e); &#125; catch(ArrayIndexOutOfBoundsException e) &#123; System.out.println(&quot;数组越界异常信息：&quot;+e); &#125; try //内部第二个try语句块 &#123; System.out.println(&quot;arr[&quot;+n+&quot;]=&quot;+arr[n]); &#125; catch(ArrayIndexOutOfBoundsException e) &#123; System.out.println(&quot;数组越界异常信息：&quot;+e); &#125; int m=arr[3]/arr[0]; System.out.println(&quot;m=&quot;+m); &#125; catch(ArithmeticException e) &#123; System.out.println(&quot;算术异常信息：&quot;+e); &#125; System.out.println(&quot;程序结束&quot;); &#125;&#125; 运行结果： 1234567请输入数组元素：0 1 2 3 4请输入数组元素索引：5数组越界异常信息：java.lang.ArrayIndexOutOfBoundsException: 5算术异常信息：java.lang.ArithmeticException: / by zero程序结束 ​ 上面程序中，在try语句块中嵌套了两个try语句块。执行程序时，先从内部的try语句块向外部执行。如果在内部没有发现匹配的catch语句块，则在外层的catch语句块进行查找匹配。 异常处理对性能的影响 一般而言，在java程序中使用try… catch…finally语句，不会对程序的性能造成很大的影响。仅仅当异常发生时，JVM才需要执行额外的操作，来定位处理异常的代码块，这时会对性能产生负面影响。如果抛出常的代码块和捕获异常的代码块位于同一个方法中，这种影响就会小一些。如果JVM必须搜索方法调用栈来寻找异常处理代码块，对性能的影响就比较大了。尤其当异常处理代码块位于调用栈的底部时，JVM定位异常处理代码块就需要大量的工作。但是，程序性能的损失相对于程序的可靠性提高来说，这是值得的。 重写方法遇到异常 1、如果父类的方法没有声明抛出异常，那么子类重写方法不可以声明抛出检查性异常，但是可以抛出非检查性异常。 2、如果父类的方法声明抛出异常，包括自定义异常，那么子类覆盖方法可以不声明抛出异常。但是，如果子类重写方法要抛出异常的话，只能抛出与被重写方法相同的异常或被重写方法异常的子类异常，不能是其他的检查异常。 throws声明异常 ​ 如果一个方法中抛出的异常没有在catch语句块中找到适合的异常处理程序，java就会立即退出该方法。若想当方法中产生异常时，不立即以try…catch语句块捕获处理，那就需要指明此方法内可能会引发的异常，可以用throws关键字实现这一功能。使用throws声明的方法表示此方法被定义时，一旦产生了异常就立即将异常对象传递出去，交由调用此方法的调用处进行处理。 格式： 1234访问控制符 返回类型 方法名(参数列表) throws 异常类1...异常类n&#123; //方法体&#125; ​ 使用throws声明的方法，仅当抛出了检查性异常，该方法的调用者才必须处理或者重新抛出该异常。当方法的调用者无力处理该异常的时候，应该继续抛出。 代码示例： 1234567891011121314151617181920import java.io.IOException;import java.io.FileInputStream;public class Test&#123; public static void arrex() throws IOException &#123; FileInputStream f=new FileInputStream(&quot;不存在的文档.txt&quot;); &#125; public static void main(String[] args) &#123; try &#123; arrex(); &#125; catch(Exception e) &#123; System.out.println(&quot;异常信息：&quot;+e); &#125; &#125;&#125; 运行结果： 1异常信息：java.io.FileNotFoundException: 不存在的文档.txt (系统找不到指定的文件。) ​ 在上面的程序中，“不存在的文档”表示在同一个目录下没有该文档。当 arrex()方法产生了异常，此方法不做处理，而是交由调用 arrex()方法的mian()方法处理。FileInputStream类在后面会有详细的讲解。需要注意的是，抛出异常的方法声明的异常类型，不能比调用处能处理的异常类型的范 围大，否则在编译时将会报错。 主方法使用throws关键字 12345678910111213import java.io.IOException;import java.io.FileInputStream;public class Test&#123; public static void arrex() throws IOException &#123; FileInputStream f=new FileInputStream(&quot;不存在的文档.txt&quot;); &#125; public static void main(String[] args)throws IOException &#123; arrex(); &#125;&#125; 运行结果： 1234567Exception in thread &quot;main&quot; java.io.FileNotFoundException: 不存在的文档.txt (系统找不到指定的文件。) at java.io.FileInputStream.open0(Native Method) at java.io.FileInputStream.open(Unknown Source) at java.io.FileInputStream.&lt;init&gt;(Unknown Source) at java.io.FileInputStream.&lt;init&gt;(Unknown Source) at Test.arrex(Test.java:7) at Test.main(Test.java:11) ​ 在以上代码中，主方法main()使用了 throws关字，没有使用try… catch语句。所arrex()方法将异常抛出交给main()方时，也不做任何处理继续向上抛出，直至抛给JVM。JVM就会调用默认异常处理程序处理，即中断程序的执行并退出。 注意:在使用 throws关键字指明可能抛出异常类型为某种“非 RuntimeException”时无论其内是否产生异常，该方法都必须对异常进行处理，否则无法编译通过。 1234567891011121314151617181920import java.io.IOException;import java.io.FileInputStream;public class Test&#123; public static void arrex() //此方法不处理异常 &#123; FileInputStream f=new FileInputStream(&quot;不存在的文档.txt&quot;); &#125; public static void main(String[] args) &#123; try &#123; arrex(); &#125; catch(Exception e) &#123; System.out.println(&quot;异常信息：&quot;+e); &#125; &#125;&#125; 运行结果： 1234Test.java:7: 错误: 未报告的异常错误FileNotFoundException; 必须对其进行捕获或声明以便抛出 FileInputStream f=new FileInputStream(&quot;不存在的文档.txt&quot;); ^1 个错误 thow抛出异常 ​ 若需要在程序中自行抛出异常，可以使用throw关键字。 **throw语句可以单独使用，**用于方法体内部， throw抛出的不是异常类，而是异常类的实例。如果抛出了检查性异常，则还应该在方法头部声明方法可能抛出的异常型，该方法的调用者也必须检查处理抛出的异常。如果所有方法都层层上抛获取的异常，最终JVM会进行处理，打印异常消息和堆栈信息。如果抛出的是Error或 RuntimeException，则该方法的调用者可选择处理该异常。 格式： 1throw 异常类对象; ​ 其中，异常类对象只能是Throwable类或者其子类的对象。如果是自定义异常类也必须是throwable类的直接或间接的子类。 自行抛出非检查性异常： 12345678910111213141516171819import java.io.IOException;public class Test&#123; public static void arrex() &#123; throw new NullPointerException(&quot;自行抛出非检查性异常——空执行异常&quot;); //创建一个异常类对象并抛出 &#125; public static void main(String[] args) &#123; try &#123; arrex(); &#125; catch(Exception e) &#123; System.out.println(e); &#125; &#125;&#125; 运行结果： 1java.lang.NullPointerException: 自行抛出非检查性异常——空执行异常 自行抛出检查性异常： 12345678910111213141516171819import java.io.IOException;public class Test&#123; public static void arrex() throws Exception &#123; throw new IOException(&quot;自行抛出检查性异常——IO异常&quot;); //创建一个异常类对象并抛出 &#125; public static void main(String[] args) &#123; try &#123; arrex(); &#125; catch(Exception e) &#123; System.out.println(e); &#125; &#125;&#125; 运行结果： 1java.io.IOException: 自行抛出检查性异常——IO异常 ​ 在程序设计中，经常会使用catch和throw，可以实现多个方法协作处理一个异常。 1234567891011121314151617181920212223242526272829303132333435import java.util.Scanner;public class Test&#123; public static void arrex(int arr[]) &#123; try &#123; int m=arr[2]/arr[0]; System.out.println(arr[2]+&quot;÷&quot;+arr[0]+&quot;=&quot;+m); &#125; catch(ArithmeticException e) &#123; e.printStackTrace(); throw new ArithmeticException(&quot;除数不能为0，所以arr[0]不能为0&quot;); &#125; &#125; public static void main(String[] args) &#123; Scanner scan=new Scanner(System.in); int arr[]=new int[5]; try &#123; for(int i=0;i&lt;arr.length;i++) &#123; System.out.println(&quot;第&quot;+(i+1)+&quot;元素：&quot;); arr[i]=scan.nextInt(); &#125; arrex(arr); &#125; catch(Exception e) &#123; System.out.println(&quot;异常消息：&quot;+e); &#125; &#125;&#125; 运行结果： 1234567891011121314第1元素：0第2元素：1第3元素：2第4元素：3第5元素：4java.lang.ArithmeticException: / by zero at Test.arrex(Test.java:8) at Test.main(Test.java:28)异常消息：java.lang.ArithmeticException: 除数不能为0，所以arr[0]不能为0 ​ 在上面程序中，当arrex()方法中的catch()语句块捕获到异常时，系统会打印该异常消息。并抛出一个ArithmeticException类型的异常，交由调用arrex()方法的main()方法处理这个ArithmeticException。 参考链接： Java中在try catch块中创建对象的问题_兰源的学习记录的博客-CSDN博客 参考书目： 《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"认识异常","slug":"java/异常/认识异常","date":"2021-07-27T08:34:42.000Z","updated":"2021-10-27T04:47:43.373Z","comments":true,"path":"2021/07/27/java/异常/认识异常/","link":"","permalink":"https://silenthly.github.io/2021/07/27/java/%E5%BC%82%E5%B8%B8/%E8%AE%A4%E8%AF%86%E5%BC%82%E5%B8%B8/","excerpt":"​ 尽管人人都希望事事顺利，但在现实生活中，总是会遇到各种异常情况，俗话说：“人生不如意事十有八九”。windows操作系统还经常蓝屏呢。在程序开发过程中，也经常会遇到这种情况，在编译时没有任何报错信息，但在程序运行时，产生了错误。这种错误对java来说是一种异常。","text":"​ 尽管人人都希望事事顺利，但在现实生活中，总是会遇到各种异常情况，俗话说：“人生不如意事十有八九”。windows操作系统还经常蓝屏呢。在程序开发过程中，也经常会遇到这种情况，在编译时没有任何报错信息，但在程序运行时，产生了错误。这种错误对java来说是一种异常。 异常是什么 ​ 在java语言中，异常是指在执行期间发生的事件，是导致程序中断运行的正常指令流。例如，在算术运算中除数为0、数组越界、空指向异常等，这些事件的发生都会阻止程序的正常运行。 异常实例： 123456789101112public class Test&#123; public static void main(String[] args) &#123; int x=10; int y=0; int m=x/y; //除数为0，产生异常 System.out.println(&quot;m=&quot;+m); int n=x+y; //程序中断不执行 System.out.println(&quot;x+y=&quot;+(x+y)); //程序中断不执行 &#125;&#125; 运行结果： 12Exception in thread &quot;main&quot; java.lang.ArithmeticException: / by zero at Test.main(Test.java:7) ​ 上面的程序在编译时没有任何报错，但是在运行时就会产生异常中断执行，并立即退出运行，所以后面的语句都没有被执行。由此可见，出现异常时会改变正常的流程，导致一系列严重的后果。在程序开发中发生的错误可分为两类: 编译时错误，就是在调用 javac命令编译时产生的报错。 编译时错误，就是在调用java命令执行产生的报错。 ​ Java是一门优秀的编程语言，自然也提供了功能强大的异常处理机制。异常的本质是一个程序在执行期间发生的一个事件，该事件断了正常执行流程。在Java方法内部发生错误时，该方法会创建一个 Exception类型的象返回给JVM，该 Exception类型的对象包含异常的类型、发生异常的程序状态等异常信息，JVM会寻找一个适合的方法类处理这个异常。 ​ 创建 Exception类型的对象返回给JVM这一程称为抛出异常。处理异常的方法就是一个异常处理程序，异常处理程序就是用来捕获被抛出的异常。JVM会从异常发生的地方开始查找异常处理程序，直到找到一个适合的异常处理程序。如果JVM找不到适合的异常处理程序，JVM将终止程序的运行。异常理机制是将控制权从发生异常的方法移交给处理该异常的异常处理程序。 ​ 在程序中若没有任何进行异常处理的语句，就不是一个好程序。异常处理机制已经成为判断一门编程语言是否优秀的标准了，与C、C+等语言相比，Java的异常处理机制有如下优点： 将错误代码从常规代码中分离出来，提高了程序的可读性，简化了程序的结构。 允许对错误进行修正，可以对错误类型和错误差别进行分组，错误的处理变得规范。 调用栈向上传送错误，方便定义错误和维护。 可以使用 catch语句输出错误信息。 防止程序自动中断程序。 java异常的类结构 ​ java的异常处理思想来源于C语言，但与C语言提供的异常处理机制有所不同。java中的异常完全是按照类的层次结构进组织的，java将异常看作为一个类，并且是按层次结构区别不同的异常。java中的所有常类都是继承自 Throwable类，就是说所有的异常类都是 Throwable类的子类。异常类的层次结构如图2-1所示 图2-1 ​ 因为所有的类都是类的子类，所以 Object类位于类层次结构的顶端，Throwable类也是Object类的子类。在所有的异常类中，Throwable类是所有异常类的父类所以Throwable类位于异常类层次结构的顶端。 Throwable类有两个子类Eror类和 Exception类，它们是异常的两个分支。 Error类 ​ Errorr往往是很严重的错误，是程序无法处理的异常，可以捕获但是最好不要捕获，因为捕获了也解决不了，这个不是由程序产出的，底层出现问题就让他它挂了吧，比如内存溢出、线程死亡等。这些异常发生时， JVM一般会选择线程终止。 Exception类 ​ 在程序开发中，开发人主要关注的是 Exception类。 Exception 异常主要分为两类： 一类是 IOException（I/O 输入输出异常），其中 IOException 及其子类异常又被称作「受查异常」 另一类是 RuntimeException（运行时异常），RuntimeException 被称作「非受查异常」。 ​ **受查异常，也称检查性异常，指编译器在编译期间要求必须得到处理的那些异常，你必须在编译期处理了。**下面给出了常见的非检查性异常与检查性异常。 常见的非检查性异常 图2-2 常见的检查性异常 图2-3 更多异常类型可查看ApI文档：Exception (Java Platform SE 7 ) (oracle.com) 下面来看一个范例： 123456789101112public class Test&#123; public static void exception() &#123; int i[]=&#123;1,2,3&#125;; System.out.println(&quot;i[3]=&quot;+i[3]); &#125; public static void main(String[] args) &#123; exception(); &#125;&#125; 运行结果： 123Exception in thread &quot;main&quot; java.lang.ArrayIndexOutOfBoundsException: 3 at Test.exception(Test.java:6) at Test.main(Test.java:10) ​ 上面程序中，产生的是数组越界异常，但java运行时环境检查到数组越界时，它就会创建一个新的异常对象实例，然后引发该异常。在由合适的捕获异常处理程序的情况下，该异常应该会被捕获并立即处理。但是程序中并没有任何异常处理程序，所以该异常会被java运行时环境的默认异常处理程序捕获。只要不是被程序员捕获的异常，最终都是被默认异常处理程序处理。默认处理程序会打印出异常的类型和异常发生时所处在的堆栈，并且立即终止程序运行。 参考链接： java-异常体系 - 简书 (jianshu.com) JAVA异常体系结构详解_java_脚本之家 (jb51.net) 参考书目： 《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"内部类","slug":"java/基本知识/内部类","date":"2021-07-26T11:25:38.000Z","updated":"2021-10-27T04:44:14.698Z","comments":true,"path":"2021/07/26/java/基本知识/内部类/","link":"","permalink":"https://silenthly.github.io/2021/07/26/java/%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/%E5%86%85%E9%83%A8%E7%B1%BB/","excerpt":"​ 由前面的内容我们知道，类都是由属性和方法组成的，但在java中还有一种特殊的语法，就是一个类的内部定义一个类，并将这个类称为内部类。","text":"​ 由前面的内容我们知道，类都是由属性和方法组成的，但在java中还有一种特殊的语法，就是一个类的内部定义一个类，并将这个类称为内部类。 内部类的定义 ​ 如果在类 Outer的内部定义一个类Inter，此时称类 Outer是外部类，亦称外围类，而Inter类称为内部类，亦称内嵌类。类的定义是可以多层嵌套的，例如，A类中定义B类，而B类中还可以定义C类，C类中还可以定义D……那么将最外层的类称为顶级类，亦称顶层类，如A类。 ​ 根据内部类在外部类中所处的位置不同，可将内部类分为局部内部类和成员内部类。局部内部类是指定义在外部类的方法体内的内部类。成员内部类是指定义在外部类方法体外的内部类。 ​ 正如类有静态成员和非静态成员，成员内部类也可定义成静态内部类和实例内部类。两者的最大区别是，调用实例内部类的实例对象时，必须先创建外部类的实例对象，而静态内部类不一定需要。实例内部类内部不能定义静态成员，而静态内部类则可以定义任意形式的成员。内部类的分类如下所示 内部类 成员内部类 局部内部类 实例内部类 静态内部类 ————— ————— ​ 为什么要使用内部类呢？在一般情况下，当它的功能需要依赖其所在的外部类存在才能起作用时，我们才让它成为内部类，而不是普通类。如word文档的文字光标，只在特定的文字组件有效。 使用内部类的原因： **1、访问其所在的外部类的所有属性，包括私有属性。**因为内部类被当做外部类的成员，同一个类的成员可以相互访问。但是外部类不能访问内部类中的实现细节。 2、内部类提供了更好的包装，可以隐藏在外部类之中，不被同一个包中的其他类所见。 3、匿名内部类还可以方便地定义运行时回调和用于仅需要一次使用的类。 4、使用内部类编写事件驱动程序时很方便。 当然，内部类的出现也带来了不足之处，如增加了语法的复杂度，增加了整个项目的结构复杂性。 内部类的使用 ​ 内部类的定义语法与普通类没有多大区别，仅是位置不同，格式如下： 12345678[public] class 外部类名&#123; //类体 访问控制符 修饰符 class 内部类名 &#123; //类体 &#125;&#125; ​ 注意：顶级类只有两种访问权限（public和默认的），而内部类有4种访问控制权限：public、protected、默认的和private。内部类也不能和外部类同名。 123456789101112131415161718192021222324252627282930class Outer&#123; private String str=&quot;java学习笔记&quot;; public class Inter //声明内部类 &#123; public void add(int x,int y) &#123; System.out.println(&quot;x+y=&quot;+(x+y)); &#125; public void getStr() //通过内部类访问外部类私有属性 &#123; System.out.println(str); &#125; &#125; public void getInfo() //从外部类调用内部类的方法 &#123; new Inter().getStr(); &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; Outer out=new Outer(); out.getInfo(); Outer.Inter t=new Outer().new Inter(); //创建内部类实例 t.add(3,4); t.getStr(); &#125;&#125; 输出结果： 123java学习笔记x+y=7java学习笔记 ​ 在以上程序中，可以看到，在外部类以外的其他类访问内部类时，需要使用以下格式： 1外部类.内部类 内部类对象=new.外部类().new 内部类(); 实例内部类 ​ 实例内部类是指声明在外部类的方法体‘外的但没有 static关键字修饰的内部类。前面所写的范例均为实例内部类。在使用实例内部类需注意以下事项： ​ (1)在外部类的静态方法或外部类以外的其他类，若需要访问内部类，则必须通过外部类创建内部类的实例访问。实例如下: 1234567891011121314151617181920212223242526class Outer&#123; public class Inter //声明内部类 &#123; public void add(int x,int y) &#123; System.out.println(&quot;x+y=&quot;+(x+y)); &#125; &#125; public static void getAdd() &#123; Inter In=new Outer().new Inter(); //需要创建外部类实例 In.add(3,7); //new Inter.add(3,7); //编译出错 &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; Outer out=new Outer(); out.getAdd(); Outer.Inter t=new Outer().new Inter(); //创建内部类实例 t.add(3,4); &#125;&#125; 输出结果： 12x+y=10x+y=7 ​ (2)在实例内部类中可以访问外部类的所成员，包括私有成员。若是多层嵌套的内部类，那么该内部类可以访问所有外部类的有成员。但在外部类中，不能直接访问内部类的成员，需要通过内部类的实例去访问。 ​ (3)示例内部类不能定义static成员。 ​ (4)在多层嵌套中，Outer类包含内部类Inter1，而Inter类又包含内部类Inter2，那么需要通过Inter1的实例才能访问Inter2类，依此类推叠加。 ​ (5)如果在内部类与外部类有着同名的成员变量i，则在内部类中，i，this.i和Inter.i都表示Inter类的成员i。而Outer.this.i才表示外部类Outer的成员。 静态内部类 ​ 静态内部类是声明在外部类中，作为外部类静态成员的内部类，即使用 static关键字修饰的内部类。与实例内部类只能声明非静态成员不同，静态内部类既可声明非静态成员，也可声明静态成员。 ​ 静态内部类是外部类的静态成员，因此它遵守类的静态成员所应遵守的一些规则，如不能访问外部类的非静态成员，只能访问外部类的静态成员等。静态内部类的对象实例可以独立创建，没有指向外部类的对象实例的引用，也不与任何外部类的对象实例相关联。 ​ 总之，静态内部类类似于顶层类，只不过是被定义在另外一个类的内部而已。 静态内部类创建对象的格式： 1外部类.静态内部类 静态内部类名=new 外部类.静态内部类(); ​ 从上面的语法格式可以看出，静态内部类创建对象实例时，并不需要外部类实例。因此，静态内部类无法直接存取外部类的非静态成员。若需存取，则需要创建外部类的对象，再用该对象去调用外部类的非静态成员。 代码实例： 1234567891011121314151617181920212223242526272829303132333435class Outer&#123; private int a=4; private static int b=5; public static class Inter //声明静态内部类 &#123; private int x=5; private static int y=6; public void add() &#123; int temp=new Outer().a; //通过外部类实例对象调用外部类非静态成员 System.out.println(temp+&quot;+&quot;+x+&quot;=&quot;+(temp+x)); &#125; public static void mull() &#123; System.out.println(b+&quot;*&quot;+y+&quot;=&quot;+(b*y)); //直接调用外部类的静态成员 &#125; &#125; public void getInfo() &#123; new Inter().add(); //通过内部类实例访问静态内部类非静态方法 Inter.mull(); //直接通过静态类名访问静态内部类的静态方法 &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; Outer out=new Outer(); out.getInfo(); Outer.Inter t=new Outer.Inter(); t.add(); t.mull(); &#125;&#125; 输出结果： 12344+5=95*6=304+5=95*6=30 ​ 从上面程序可以看出，静态内部类可以直接访问外部类的静态成员，包括私有的静态成员。但是要访问外部类非静态成员时，需要通过外部类的实例对象访问。在外部类中，可以通过静态内部类的实例调用实例方法，但可以通过“静态内部类名.静态方法”修饰访问静态内部类的静态方法。 静态内部类的特点总结 1、静态内部类创建对象实例时，并不需要外部类的实例。 2、静态内部类可以定义静态与非静态成员。 3、外部类与外部类以外的其他类，可通过完整的类名访问静态内部类的静态成员，若要访问静态内部类非静态成员，则需要通过静态内部类的实例。 4、静态内部类可以直接访问所有外部类的静态成员，若要访问外部类非静态成员，则需要通过外部类的实例。 注意：所有的静态属性都没有外部，内部之分，是可以随便访问的。 对3、4点实例测试： 1234567891011121314151617181920212223242526272829class Outer&#123; private static int x=3; public static class Inter1 //声明静态内部类 &#123; public static int y=4; public static class Inter2 //声明静态内部类 &#123; public static void say() &#123; System.out.println(x+&quot;+&quot;+y+&quot;=&quot;+(x+y)); //直接调用外部类的静态成员 &#125; &#125; &#125; public static void tell() &#123; Inter1.Inter2.say(); //直接通过静态类名访问静态内部类的静态方法 &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; Outer out=new Outer(); out.tell(); Outer.Inter1.Inter2 t=new Outer.Inter1.Inter2(); t.say(); &#125;&#125; 输出结果： 1234外部类调用静态内部类的静态方法3+4=7静态内部类实例调用静态方法3+4=7 局部内部类 ​ 局部内部类是指定义在方法体内的内部类，局部内部类仅在该方法里有效。因此，局部内部类不能被外部类和外部类以外的其他类访问。所以局部内部类是不需要访问控制符和static修饰符的。 使用局部内部类需要注意以下几点： 1、局部内部类不能使用访问控制符和static关键字修饰。也不能定义static成员。 2、局部内部类仅在该方法里有效，不能被外部类和外部类以外的其他类访问。 3、局部内部类可以访问外部类的所有成员，包括私有成员。但局部内部类访问方法的参数和局部变量必须是final的。因为final定义的变量相当于常量，可以延长变量的生命周期。就是方法撤销，其内部类仍可以访问final类型的变量。 代码实例： 12345678910111213141516171819202122232425262728class Outer&#123; private int x=90; public void fun() &#123; int k=40; final int y=5; class Inter &#123; private int x=10; public void getInter() &#123; System.out.println(&quot;外部类属性x：&quot;+Outer.this.x+&quot;\\n内部类属性x：&quot;+this.x); int temp=Outer.this.x+y+x; System.out.println(Outer.this.x+&quot;+&quot;+y+&quot;+&quot;+x+&quot;=&quot;+temp); &#125; &#125; new Inter().getInter(); &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; Outer out=new Outer(); out.fun(); &#125;&#125; 输出结果： 123外部类属性x：90内部类属性x：1090+5+10=105 匿名内部类 ​ 匿名内部类是指在定义时 没有名称的内部类，必须在声明时使用new语句类声明类。匿名内部类是一种特殊的内部类，除了具有普通内部类的特点外，还有自己的一些特点。匿名内部类一般只使用一次，在GUI图像用户界面的引用编程中使用广泛。 格式： 1234new &lt;类或接口&gt;(参数列表)&#123; //类体&#125; ​ 匿名内部类没有类名，匿名内部类必须扩展一个基类或实现一个接口，但不要显式地使用 extends关键字或 implements关键。如果匿名内部类继承抽象类或实现接口时，还要实现父类及接口中所有的抽象方法。有名称的类若没有显式指定父类，系统会让其自动继承 Object类，但匿名内部类不会自动继承 Object类，所以每个匿名内部类都要明确地指出它继承的类或实现的接口。 ​ 在格式中的“参数列表”是表示在调用父类的构造方法时传入的参数。匿名内部类只在其所定义的代码块内使用一次，所以无法其定义构造方法。匿名内部类总是使用父类的构造方法来创建实例，如果匿名内部类实的是接口，那么匿名内部类的构造方法就是Object()。 匿名内部类继承抽象类实例： 12345678910111213141516171819202122232425262728abstract class Abstr //定义抽象类&#123; public abstract void getInfo();&#125;class Inter&#123; public void print() &#123; show(new Abstr() //匿名内部类 &#123; public void getInfo() //实现抽象方法 &#123; System.out.println(&quot;java学习笔记&quot;); &#125; &#125;); &#125; public void show(Abstr a) //传入抽象方法实例 &#123; a.getInfo(); //调用抽象类方法 &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; new Inter().print(); //创建Inter类的实例并调用print方法 &#125;&#125; 输出结果： 1java学习笔记 ​ 在以上程序中，使用匿名内部类时，使用new Abstr()对抽象类实例化，抽象类不是不能实例化的吗？为什么这里又可以实例化了？其实，这只是一个假象，是匿名内部类的用法，而且和普通的对象实例化的写法也不同，后面带有一对{} ，其真实的面貌是创建了抽象类的匿名子类的实例。匿名内部类是没有名字的，但 JVM需要一个能够运行它的名字，你不能告诉JVM运行某些东西而不告诉它运行什么。这个名字对于一个class来说不是一个有意义的名字。 匿名内部类实现接口实例： 12345678910111213141516171819202122232425262728interface Inter&#123; public abstract void getInfo();&#125;class InterClass&#123; public void print() &#123; show(new Inter() //匿名内部类 &#123; public void getInfo() //实现抽象方法 &#123; System.out.println(&quot;java学习笔记&quot;); &#125; &#125;); &#125; public void show(Inter i) //传入抽象方法实例 &#123; i.getInfo(); //调用抽象类方法 &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; new InterClass().print(); &#125;&#125; 输出结果： 1java学习笔记 ​ 以上程序中，直接使用new Inter()为接口实例化，但接口本身是不能实例化的，所以在new Inter()之后的花括号中写的就是实现接口中的抽象方法。（参照上面抽象方法） 注意： 1、匿名内部类没有构造方法，但是可以调用父类的构造方法。 2、匿名对象可以访问外部类的所有成员，但匿名对象定义在方法中，只能访问方法中final类型的参数和局部变量。（同局部变量） 3、匿名内部类允许非静态代码块对成员进行初始化。 代码实例： 1234567891011121314151617181920212223242526272829303132interface Inter&#123; public abstract void getInfo();&#125;class InterClass&#123; public void print() &#123; show(new Inter() //匿名内部类 &#123; int x; &#123; x=10; &#125; public void getInfo() //实现抽象方法 &#123; System.out.println(&quot;x=&quot;+x); &#125; &#125;); &#125; public void show(Inter i) //传入抽象方法实例 &#123; i.getInfo(); //调用抽象类方法 &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; new InterClass().print(); &#125;&#125; 输出结果： 1x=10 参考链接： jav静态内部类中静态成员可以访问外部类的静态成员吗？_百度知道 (baidu.com) 局部内部类访问方法的参数和局部变量必须是final的 - 拉夫德尔 - 博客园 (cnblogs.com) 关于Java：我们可以实例化抽象类吗？ | 码农家园 (codenong.com) 是否有可能使用匿名内部类和机制来实例化抽象类以访问其中的方法 - VoidCC Java中用匿名内部类实现实例化抽象类_weixin_34345560的博客-CSDN博客 参考书目： 《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"对象数组","slug":"java/基本知识/对象数组","date":"2021-07-26T07:11:34.000Z","updated":"2021-10-27T04:47:50.018Z","comments":true,"path":"2021/07/26/java/基本知识/对象数组/","link":"","permalink":"https://silenthly.github.io/2021/07/26/java/%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84/","excerpt":"​ 数组是一组相同类型数据的组合，除了基本数据类型的数组外，还包括了许多其他数组，也包括了对象数组。对象数组，即数组里的每个对象都是同一个类的对象。数组是引用数据类型，其元素的默认初始值为null，在使用数组元素时，必须分别为每一个元素进行实例化。","text":"​ 数组是一组相同类型数据的组合，除了基本数据类型的数组外，还包括了许多其他数组，也包括了对象数组。对象数组，即数组里的每个对象都是同一个类的对象。数组是引用数据类型，其元素的默认初始值为null，在使用数组元素时，必须分别为每一个元素进行实例化。 格式： 1类名 对象数组名称[]=new 类名[数组长度]; ​ 其中，定义对象数组与前面定义数组格式是一致的，对象数组的初始化也分为动态初始化和静态初始化。 代码示例： 1234567891011121314151617181920212223242526272829303132333435363738class School&#123; private String name; public School()&#123;&#125; public School(String name) &#123; setName(name); &#125; public void setName(String name) &#123; this.name=name; &#125; public String getName() &#123; return name; &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; System.out.println(&quot;动态初始化&quot;); School s1[]=new School[2]; //动态数组 s1[0]=new School(&quot;清华大学&quot;); s1[1]=new School(&quot;北京大学&quot;); for(School s:s1) &#123; System.out.print(s.getName()+&quot; &quot;); &#125; System.out.println(&quot;\\n静态初始化&quot;); School s2[]=&#123;new School(&quot;中山大学&quot;),new School(&quot;华南理工大学&quot;)&#125;; for(School s:s2) &#123; System.out.print(s.getName()+&quot; &quot;); &#125; System.out.println(); &#125;&#125; 输出结果： 1234动态初始化清华大学 北京大学静态初始化中山大学 华南理工大学","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"接口","slug":"java/基本知识/接口","date":"2021-07-26T03:47:45.000Z","updated":"2021-10-27T04:42:49.901Z","comments":true,"path":"2021/07/26/java/基本知识/接口/","link":"","permalink":"https://silenthly.github.io/2021/07/26/java/%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/%E6%8E%A5%E5%8F%A3/","excerpt":"​ 在java中，只支持单重继承，不允许一个类同时继承多个父类。为此，java提供了接口，一个类可以同时实现多个接口。","text":"​ 在java中，只支持单重继承，不允许一个类同时继承多个父类。为此，java提供了接口，一个类可以同时实现多个接口。 接口的概念 ​ 接口是面向对象语言提供的抽象和封装重要机制，是抽象概念的近一步深化。可以这样理解，接口就是一个规范，类似于硬件上面的接口，在电脑主板上的PCI插槽的规范就类似于Java接口，只要是遵循PCI接口的卡，不过是什么牌子的都可以插入到PCI插槽中。所以接口就是一个规范。接口就是某个事物对外提供的一些功能的说明。java中的接口，约定了实现类必须实现的功能，但实现类可以根据自身需求，除了实现接口约定外，还可以实现其他一些功能。 ​ 接口在语言上与类非常类似，也有属性和方法，接口之间也存在继承关系。但也有不同之处，接口的属性都是常量，接口的方法都是抽象方法（实际上，在JDK1.8以后，接口可以含有static default方法，包含方法体）。定义接口不在使用class关键字，而是使用interface关键字。格式如下： 123456[public] interface 接口名称 [extends 父类接口1,父类接口2...]&#123; [public static final] 数据类型 变量=初始值; ... [public abstract] [native] 返回类型 方法名(参数列表);&#125; 其中需要注意以下几点： 1、[public]是接口的访问修饰符，public是指任意类均可以使用这个接口。如果是默认，则只有与该借口定义在同一个包中的类才可以访问这个接口。 2、[extends 父类接口1,父类接口2...]表示接口可以有多个父接口，子接口继承父接口中所有的常量属性和方法，其中方法是抽象方法，不能含有方法主体。接口不能继承类。 3、接口中的属性必须是public static final修饰的，所以在声明时可以不写，系统会默认声明这些修饰符。声明时必须指定初始值(参考final关键字)。在调用时可以用接口名.常量的格式， 4、接口中的方法必须是public abstract，所以在声明时可以不写，系统会默认声明这些修饰符。接口的方法没有方法体，以分号结束，不能带有“{}”。 5、native主要用于方法上，native方法是指该方法的实现由非Java语言实现，比如用C或C++实现。在定义一个native方法时，并不提供实现体（类似接口），因为其实现体是由非Java语言在外面实现的。主要是因为JAVA无法对操作系统底层进行操作，但是可以通过jni(java native interface)调用其他语言来实现底层的访问。 代码示例： 123456public interface InterShape&#123; public static final float PI=3.14F; //定义全局变量 public abstract void getArea(); //定义抽象方法 public abstract void getCircum(); //定义抽象方法&#125; 也可简化如下： 123456public interface InterShape&#123; float PI=3.14F; //定义全局变量 void getArea(); //定义抽象方法 void getCircum(); //定义抽象方法&#125; ps：接口的编译方式与普通类是一致的，而且编译后会产生它的字节码文件（.class）。 实现与继承接口 ​ 前面讲过，接口中的方法都是抽象方法。所以接口定义完成之后，必须在实现接口的类中对接口中的所有方法进行具体化。子类通过implements关键字实现接口。 格式： 1234[public] 类名 [extends 父类或者抽象类] implements 接口A,接口B,...&#123; ...&#125; ​ 其中，在声明类时用implement关键字表示该类实现该接口。在类中，必须将接口中所定义的所有抽象方法实现。一个类可以实现一个或多个接口。 代码示例： 123456789101112131415161718192021222324252627282930313233343536interface InterShape&#123; public static final float PI=3.14F; public abstract void getArea(); public abstract void getCircum();&#125;class Round implements InterShape&#123; private float radius; public Round()&#123;&#125; public Round(float radius) &#123; this.radius=radius; &#125; public float getRadius() &#123; return radius; &#125; public void getArea() &#123; System.out.println(&quot;圆的面积：&quot;+(getRadius()*getRadius()*InterShape.PI)); &#125; public void getCircum() &#123; System.out.println(&quot;圆的周长：&quot;+(2*InterShape.PI*getRadius())); &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; Round r=new Round(4.0F); r.getArea(); r.getCircum(); &#125;&#125; 输出结果： 12圆的面积：50.24圆的周长：25.12 接口的多继承 ​ 前面讲过，java运行一个接口继承多个接口。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142interface InterPI&#123; public static final float PI=3.14F;&#125;interface InterArea&#123; public abstract void getArea();&#125;interface InterCircum&#123; public abstract void getCircum();&#125;class Round implements InterPI,InterArea,InterCircum&#123; private float radius; public Round()&#123;&#125; public Round(float radius) &#123; this.radius=radius; &#125; public float getRadius() &#123; return radius; &#125; public void getArea() &#123; System.out.println(&quot;圆的面积：&quot;+(getRadius()*getRadius()*InterShape.PI)); &#125; public void getCircum() &#123; System.out.println(&quot;圆的周长：&quot;+(2*InterShape.PI*getRadius())); &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; Round r=new Round(6.0F); r.getArea(); r.getCircum(); &#125;&#125; 输出结果： 12圆的面积：113.04圆的周长：37.68 注意：接口没有构造方法，也不能定义构造方法。 接口与抽象类 ​ 我们可以发现，接口与抽象类有很多类似的地方，那么接口是抽象类吗？从语法上，接口和抽象类是相似的，甚至可以说接口是一个”纯“的抽象类或者说接口是一个特殊的抽象类。以下表格列出两者的异同，便于区分接口和抽象类。 比较 接口 抽象类 相同点 方法类型 接口和抽象类都可以包含抽象方法，这些抽象方法将在实现接口或继承抽象类的类中具体实现，否则该类还是必须声明为抽象类 创建实例 由于接口和抽象类都包含抽象方法，所以不能用new关键字类创建对象，两者均可实现引用实现接口或继承抽象类的类的实例 继承关系 接口和抽象类都可以实现继承，继续之后子接口就拥有父接口中所有的常量和方法，而抽象类继承父类后也将拥有父类的所有非private的属性和方法 不同点 声明 用interface关键字定义接口 用abstract关键字定义抽象类 成员变量 在接口中，没有变量，其属性都是全局常量 抽象类的成员属性则是完全依据显式定义的不同而不同，编译器不会有任何强制限制 方法 接口中的所以方法均隐含public和abstract，即使不显式修饰，编译器会自动添加。接口中不能含有非程序的方法，其方法也不能是最终的、静态的以及非public的 编译器不会为抽象类的方法自动添加任何修饰符，完全取决于开发人员，所以其抽象方法必须手动添加abstract关键字。抽象类中可以有抽象方法，那么这个类必须声明为抽象类。其抽象方法不能为最终的、静态的及非public的 构造方法 接口没有构造方法 抽象类有构造方法 this与super关键字 interface没有内置的this和super关键字 抽象类可以内置this和super关键字 继承 接口支持多重继承，即可以同时继承多个接口，但是只能继承接口，不能继承类。接口不能实现其他接口，即在定义接口是不能出现implement关键字 抽象类只支持单重继承，即只能继承一个父类，但可以实现多个接口，不能继承接口。可以选择地重写父类的方法或实现接口的方法 接口与抽象类的选择 ​ 从表可以看出，接口与抽象类在语法上有很多区别之处，也体现了接口比抽象类更加灵活、可选择性更多的特点。那接口和抽象类，我们该如何选择呢？可根据以下两点而定： 1、优先选择接口。 2、既要定义子类的行为，又要为子类提公共的功能时选择抽象类。 参考链接： JAVA中的native是什么？ - 简书 (jianshu.com) 接口中所有方法均为抽象方法？正确吗_百度知道 (baidu.com) 参考书目： 《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"抽象类","slug":"java/基本知识/抽象类","date":"2021-07-25T12:41:37.000Z","updated":"2021-10-27T04:51:08.723Z","comments":true,"path":"2021/07/25/java/基本知识/抽象类/","link":"","permalink":"https://silenthly.github.io/2021/07/25/java/%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/%E6%8A%BD%E8%B1%A1%E7%B1%BB/","excerpt":"​ 在大多数的情况下，java的类是可以被其他类继承，也可以被直接实例化使用。但有种类是专门用来做父类的，自身也是不能实例化的，这样的类称为抽象类。 抽象类和抽象方法 ​ 抽象类只表示一种抽象的概念，是描述其子类所共有的属性和方法，它不能被实例化为一个对象，即不能用new关键字为抽象类对象分配空间，抽象类的子类可以对其进行具体的实现。 ​ 在抽象类中往往存在一种方法，其只定义了方法的声明但不包含其具体实现，这样的方法称为抽象方法。而包含抽象方法的类一律称为抽象类，一个抽象类中可以存在一个或多个抽象方法。 ​ 抽象类和抽象方法的定义方式都是在类名和方法名之前加上abstract关键字，abstract关键字不能修饰属性和构造方法。","text":"​ 在大多数的情况下，java的类是可以被其他类继承，也可以被直接实例化使用。但有种类是专门用来做父类的，自身也是不能实例化的，这样的类称为抽象类。 抽象类和抽象方法 ​ 抽象类只表示一种抽象的概念，是描述其子类所共有的属性和方法，它不能被实例化为一个对象，即不能用new关键字为抽象类对象分配空间，抽象类的子类可以对其进行具体的实现。 ​ 在抽象类中往往存在一种方法，其只定义了方法的声明但不包含其具体实现，这样的方法称为抽象方法。而包含抽象方法的类一律称为抽象类，一个抽象类中可以存在一个或多个抽象方法。 ​ 抽象类和抽象方法的定义方式都是在类名和方法名之前加上abstract关键字，abstract关键字不能修饰属性和构造方法。 格式： 123456789访问控制符 abstract class 抽象类名 //定义抽象类&#123; 属性; 访问控制符 返回类型 方法名(参数列表) &#123; //方法体 &#125; 访问控制符 abstract 返回类型 方法名(参数列表); //定义抽象方法&#125; 代码示例： 123456789101112131415161718192021222324252627282930abstract class Person&#123; public static final String country=&quot;中国&quot;; private String name; public void setName(String name) &#123; this.name=name; &#125; public String getName() &#123; return name; &#125; public abstract void tell();&#125;class Student extends Person&#123; public void tell() &#123; System.out.println(&quot;我叫&quot;+getName()+&quot;，是一名&quot;+country+&quot;人!&quot;); &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; Student stu=new Student(); stu.setName(&quot;小强&quot;); stu.tell(); &#125;&#125; 输出结果： 1我叫小强，是一名中国人! ​ 注意：子类对抽象类中的抽象方法继承时，必须实现抽象类中的所有抽象方法，否则该子类仍被定义为抽象类。若子类没有完全抽象(实现)抽象类的抽象方法，在编译时就会出错。 抽象类的构造方法 ​ 抽象类也可以定义构造方法，因为抽象类也存在各个属性，所以子类实例化前必须要对父类进行实例化。子类可通过super关键字调用抽象类的构造方法。 代码示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546abstract class Shape&#123; private float width; private float high; public Shape()&#123;&#125; public Shape(float width,float high) &#123; this.width=width; this.high=high; &#125; public float getWidth() &#123; return width; &#125; public float getHigh() &#123; return high; &#125; public abstract void area(); public abstract void Circumference();&#125;class Rectangle extends Shape&#123; public Rectangle()&#123;&#125; public Rectangle(float width,float high) &#123; super(width,high); //使用super调用父类的构造方法 &#125; public void area() &#123; System.out.println(&quot;矩形面积：&quot;+(getWidth()*getHigh())); &#125; public void Circumference() &#123; System.out.println(&quot;矩形周长：&quot;+((getWidth()+getHigh())*2)); &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; Rectangle rec=new Rectangle(3.0f,4.0f); rec.area(); rec.Circumference(); &#125;&#125; 输出结果： 12矩形面积：12.0矩形周长：14.0 参考书目： 《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"final关键字","slug":"java/基本知识/final关键字","date":"2021-07-25T02:36:53.000Z","updated":"2021-10-27T04:45:22.586Z","comments":true,"path":"2021/07/25/java/基本知识/final关键字/","link":"","permalink":"https://silenthly.github.io/2021/07/25/java/%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/final%E5%85%B3%E9%94%AE%E5%AD%97/","excerpt":"​ final关键字的中文含义是“最终”，可以 修饰常量、方法和类。final修饰的常量只能赋值一次，修饰的方法不能被重写，修饰的类不能有子类。","text":"​ final关键字的中文含义是“最终”，可以 修饰常量、方法和类。final修饰的常量只能赋值一次，修饰的方法不能被重写，修饰的类不能有子类。 final关键字修饰常量 ​ final修饰变量是，表示该变量是常量。常量可以出现在类的内部，也可以出现在方法或构造方法的内部。若final修饰的是基本数据类型的变量，那么该变量一但初始化后，将不能再修改。若final修饰的是引用数据类型的变量，一旦赋值，那么其引用是不可改变的，但可以修改引用对象的属性。 代码示例： 1234567891011121314151617181920212223242526272829303132333435public class Test&#123; final float PI=3.14f; final int array[]=&#123;1,3,5,7&#125;; final float num; final String str; &#123; num=10; //通过构造开初始化，初始化后不能再修改 &#125; public Test() &#123; str=&quot;java&quot;; //通过构造方法初始化，初始化后不能再修改 &#125; public static void main(String[] main) &#123; Test t=new Test(); System.out.println(&quot;PI=&quot;+t.PI); System.out.println(&quot;num=&quot;+t.num); System.out.println(&quot;str=&quot;+t.str); System.out.println(&quot;修改前：&quot;); for(int a:t.array) &#123; System.out.print(a+&quot; &quot;); &#125; for(int i=0;i&lt;t.array.length;i++) &#123; t.array[i]*=10; &#125; System.out.println(&quot;\\n修改后：&quot;); for(int a:t.array) &#123; System.out.print(a+&quot; &quot;); &#125; &#125;&#125; 输出结果： 1234567PI=3.14num=10.0str=java修改前：1 3 5 7修改后：10 30 50 70 ps：被final修饰的变量，若在编译时就可以确定其值，那么该变量就可以被当成常量，需要遵守常量的命名规则。若编译时还无法确定其值，需要运行时才能得到其值，那么可以不遵守常量的命名规则。 不允许被覆盖的方法——最终方法 ​ final关键字还可以修饰方法，final修饰的方法称作最终方法或终极方法，在某些情况下，出于安全考虑，父类不允许子类重写某个方法，此时可以将这个方法声明为final类型。 final修饰的方法的作用： 1、保持父类中的某个方法的操作在被继承时不会发生改变。 2、使用final修饰方法，可以在一定程度上提高该方法的执行速度，因为在调用该方法时，就不需要进行覆盖的判断了。 ​ 子类虽然不能重写父类中的最终方法，但是可以定义新的同名方法，即重载该方法。 代码示例： 1234567891011121314151617181920212223class Base&#123; public final void add(int x,int y) &#123; System.out.println(&quot;x+y=&quot;+(x+y)); &#125;&#125;class Subclassing extends Base&#123; public final void add(int x,int y,int z) &#123; System.out.println(&quot;x+y+z=&quot;+(x+y+z)); &#125;&#125;public class Test&#123; public static void main(String[] main) &#123; Subclassing sub=new Subclassing(); sub.add(10,20); sub.add(10,20,30); &#125;&#125; 输出结果： 12x+y=30x+y+z=60 使用final关键字的注意事项 1、不能使用final修饰构造方法，否则编译报错。 2、private和static修饰的方法是隐式的final方法。 不能继承的类——最终类 ​ 被final修饰的类称为最终类，最终类内的每个方法都是final方法。最终类不能被继承，也就是该类不能有子类。这虽然降低了代码的可重用性和可扩展性，但保证了系统的安全性。 最终类适用场景： 1、出于安全原因，类的实现行为不允许有任何改动。 2、不是专门为了继承而设计的类，类本身的方法调用关系复杂。 3、创建设计模型时，确定该来不会再被扩展。 static final ​ 一个既是static有时final的字段值占据一段不能改变的存储空间，它必须在定义的时候进行赋值，否则编译不通过。 代码示例： 12345678910111213import java.util.Random;public class Test&#123; static Random r = new Random(); final int k = r.nextInt(10); //生成随机数k static final int k2 = r.nextInt(10); //生成随机数k2 public static void main(String[] args) &#123; Test t1 = new Test(); System.out.println(&quot;k=&quot;+t1.k+&quot; k2=&quot;+t1.k2); Test t2 = new Test(); System.out.println(&quot;k=&quot;+t2.k+&quot; k2=&quot;+t2.k2); &#125;&#125; 输出结果： 12k=7 k2=1k=1 k2=1 ​ 我们可以发现对于不同的对象k的值是不同的，但是k2的值却是相同的，这是为什么呢? 因为static关键字所修饰的字段并不属于一个对象，而是属于这个类的。也可简单的理解为static final所修饰的字段仅占据内存的一个一份空间，一旦被初始化之后便不会被更改。 参考链接： 详解Java关键字final_java_脚本之家 (jb51.net) 参考书目： 《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"StringBuffer类","slug":"java/常用类库/StringBuffer类","date":"2021-07-25T02:22:32.000Z","updated":"2021-10-27T04:42:55.400Z","comments":true,"path":"2021/07/25/java/常用类库/StringBuffer类/","link":"","permalink":"https://silenthly.github.io/2021/07/25/java/%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%BA%93/StringBuffer%E7%B1%BB/","excerpt":"可变的String类——StringBuffer类 ​ 在java中，String类是不可变的，但是在程序中，很多情况需要字符串变量不断发生改变。若还继续用String类，那么就会存在内存消耗大和效率低的问题。所以这时我们需要用到java中的另一个标准类StringBuffer类，StringBuffer类对象是可以直接被修改的。","text":"可变的String类——StringBuffer类 ​ 在java中，String类是不可变的，但是在程序中，很多情况需要字符串变量不断发生改变。若还继续用String类，那么就会存在内存消耗大和效率低的问题。所以这时我们需要用到java中的另一个标准类StringBuffer类，StringBuffer类对象是可以直接被修改的。 创建SringBuffer类 ​ 创建StringBuffer类不能像创建String对象一样直接赋值，以下两种格式等效。 格式一： 12StringBuffer 对象名=null;对象名=new StringBuffer(&quot;字符串内容&quot;); 格式二： 1StringBuffer 对象名=new StringBuffer(&quot;字符串内容&quot;); 代码示例： 123456789101112public class Test&#123; public static void main(String[] args) &#123; StringBuffer strb1=new StringBuffer(&quot;language&quot;); System.out.println(&quot;strb1：&quot;+strb1); StringBuffer strb2=new StringBuffer(); System.out.println(&quot;strb2：&quot;+strb2); StringBuffer strb3=strb1; System.out.println(&quot;strb3：&quot;+strb3); &#125;&#125; 输出结果： 123strb1：languagestrb2：strb3：language StringBuffer的常用方法 ​ StringBuffer类的方法与String方法有很多都是相同或相似的，StringBuffer类中的方法主要偏重对于字符串修改变化。下面列举StringBuffer的常用方法。 序号 方法 类型 说明 1 StringBuffer() 构造 StringBuffer的构造方法，其初始容量为16个字符 2 StringBuffer(int capacity) 构造 StringBuffer的构造方法，可指定初始容量的字符串缓冲区 3 StringBuffer(String str) 构造 StringBuffer的构造方法，并将其初始化为指定的字符串内容 4 StringBuffer append(String str) 普通 此方法可以向StringBuffer追加内容，可以重载该方法 5 int capacity() 普通 返回当前容量 6 char charAt(int index) 普通 从字符串中提取指定位置的字符 7 StringBuffer delete(int start,int end) 普通 删除指定位置的字符串 8 StringBuffer deleteCharAt(int index) 普通 删除指定位置的字符 9 int indexOf(String str) 普通 从头开始搜索指定子字符串的位置，若指定的字符&lt;串存在则返回字符串的位置，否则返回-1 10 StringBuffer insert(int offset,String str) 普通 在指定位置插入字符串 11 int lastIndexOf(String str) 普通 返回第一个指定子字符串在此字符串中的索引位置 12 int length() 普通 返回此字符串的长度 13 StringBuffer replace(int strat,int end,String str) 普通 用新的字符串替换在此字符串中指定的子字符串 14 StringBuffer reverse() 普通 将字符串反转 15 void setCharAt(int index,char ch) 普通 将指定索引位置的字符设置为指定字符 16 void setLength(int newLength) 普通 设置字符序列长度 17 String substring(int start) 普通 截取从开始点到结尾的字符串 18 String substring(int strat,int end) 普通 截取从开始点到结束点的字符串 19 String toString() 普通 返回此序列中数据的字符串表示形式 连接字符串 ​ 在String类中可以使用“+”号链接两个子字符串，但是在StringBuffer中只能使用append()方法进行不同字符串的连接。 12345678910public class Test&#123; public static void main(String[] args) &#123; StringBuffer strb=new StringBuffer(&quot;java&quot;); strb.append(&quot;面向对象&quot;); strb.append(&quot;的编程语言&quot;); System.out.println(strb); &#125;&#125; 输出结果： 1java面向对象的编程语言 StringBuffer对象的容量 ​ 在上面中提到 StringBuffer 的默认初始容量的字符串缓冲区大小为 16 字符，但是不同的 StringBuffer 对象拥有不同的容量。StringBuffer 类提供了 capacity() 方法获取对象的 容量。 12345678910111213141516public class Test&#123; public static void main(String[] args) &#123; StringBuffer strb1=new StringBuffer(&quot;programme&quot;); StringBuffer strb2=new StringBuffer(); StringBuffer strb3=new StringBuffer(3); strb3.append(&quot;java&quot;); StringBuffer strb4=new StringBuffer(5); strb4.append(&quot;java is a programming language&quot;); System.out.println(&quot;strb1的容量为：&quot;+strb1.capacity()+&quot;\\tstrb1的长度为：&quot;+strb1.length()); System.out.println(&quot;strb2的容量为：&quot;+strb2.capacity()+&quot;\\tstrb2的长度为：&quot;+strb2.length()); System.out.println(&quot;strb3的容量为：&quot;+strb3.capacity()+&quot;\\tstrb3的长度为：&quot;+strb3.length()); System.out.println(&quot;strb4的容量为：&quot;+strb4.capacity()+&quot;\\tstrb4的长度为：&quot;+strb4.length()); &#125;&#125; 运行结果： 1234strb1的容量为：25 strb1的长度为：9strb2的容量为：16 strb2的长度为：0strb3的容量为：8 strb3的长度为：4strb4的容量为：30 strb4的长度为：30 注意，capacity()方法返回的容量与length()方法返回的字符串长度，不仅在数值上不同，含义上也不同。capacity()测量的是一个杯子容量，而length()测量的是实际水在杯子里的体积。 对容量的理解 ​ 在创建 StringBuffer 对象时，没有指定容量的大小，系统就会默认为16字符的容量。像上面程序中的 strb2，其容量就是16字符。若指定了容量大小，指定多少那就是多少。如 strb3 指定的容量为3字符，那它的容量就是3字符大小。 ​ 若是像 strb1 一样，直接使用字符串创建 StringBuffer 变量，那容量大小为16+字符串长度。如 strb1 的容量为16+9=25。如果 StringBuffer 变量中修改后的字符串内容大于其容量，那么它的容量增长规律为（容量+1）×2。在 strb3 的容量指定为3字符大小，但是字符串 Java 的长度为4大于容量大小3，所以其容量增长为（3+1）×2=8。 ​ 如果按照容量增长规律：（容量+1）×2 增长后还是不够，那么它的容量就等于字符串的长度。如 strb4 其指定的容量大小为5，但是字符串长度为30，大于（5+1）×2=12， 所以其容量大小就变为30等于字符串长度。 删除指定位置的字符串 ​ String类是不可变的，但StringBuffer类的字符串是可以被修改的，可以使用delete()方法删除指定位置的字符串，也可以使用deleteCharAt()方法删除指定位置的字符，这里的位置指索引位置。 123456789public class Test&#123; public static void main(String[] args) &#123; StringBuffer strb=new StringBuffer(&quot;java是面向对象的编程语言&quot;); System.out.println(&quot;删除“&quot;+strb+&quot;”索引位置为0的字符：&quot;+strb.deleteCharAt(0)); System.out.println(&quot;删除“&quot;+strb+&quot;”索引位置为5到10的字符串：&quot;+strb.delete(5,10)); &#125;&#125; 输出结果： 12删除“java是面向对象的编程语言”索引位置为0的字符：ava是面向对象的编程语言删除“ava是面向对象的编程语言”索引位置为5到10的字符串：ava是面程语言 将指定的字符串插入字符串序列 ​ 前面使用append()方法只能在字符串的后面添加内容，使用insert()方法可以将内容插入到字符串的任意位置。 12345678910111213public class Test&#123; public static void main(String[] args) &#123; StringBuffer strb=new StringBuffer(&quot;programming&quot;); strb.insert(0,&quot;java is &quot;); System.out.println(strb); strb.insert(7,&quot; a &quot;); System.out.println(strb); strb.insert(strb.length(),&quot; language&quot;); System.out.println(strb); &#125;&#125; 输出结果： 123java is programmingjava is a programmingjava is a programming language 将字符串顺序反转 ​ 使用reverse()方法 123456789public class Test&#123; public static void main(String[] args) &#123; StringBuffer strb=new StringBuffer(&quot;遥望四边云接水，雪峰千点数鸥轻&quot;); strb.reverse(); System.out.println(strb); &#125;&#125; 输出结果： 1轻鸥数点千峰雪，水接云边四望遥 //回文诗，《题金山寺回文本》——苏轼 将指定位置的字符替换并指定字符串的长度 ​ 使用setCharAt()方法将指定位置字符串替换掉。在程序设计中很多时候是不允许输入的字符串过长，如果超过指定的字符串长度将其截取。 123456789101112public class Test&#123; public static void main(String[] args) &#123; StringBuffer strb=new StringBuffer(&quot;春天是美丽的季节&quot;); System.out.println(strb); strb.setCharAt(0,&#x27;秋&#x27;); System.out.println(&quot;截取前的长度：&quot;+strb.length()); strb.setLength(6); System.out.println(&quot;截取长度为6后：&quot;+strb); &#125;&#125; 输出结果： 123春天是美丽的季节截取前的长度：8截取长度为6后：秋天是美丽的 比较StringBuffer字符串是否相等 ​ StringBuffer类是没有重写Object类的equals()方法，所以StringBuffer类不能使用该方法进行StringBuffer类型字符串的比较。但可以使用toString()方法将StringBuffer的内容转换为String字符串，再使用equals()方法比较。 123456789101112131415161718public class Test&#123; public static void main(String[] args) &#123; StringBuffer strb1=new StringBuffer(&quot;java&quot;); StringBuffer strb2=new StringBuffer(&quot;java&quot;); System.out.print(&quot;转换前：&quot;); if(strb1.equals(strb2)) System.out.println(&quot;相等&quot;); else System.out.println(&quot;不相等&quot;); System.out.print(&quot;转换后：&quot;); if(strb1.toString().equals(strb2.toString())) System.out.println(&quot;相等&quot;); else System.out.println(&quot;不相等&quot;); &#125;&#125; 输出结果： 12转换前：不相等转换后：相等 参考书目： 《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"字符串(String)","slug":"java/常用类库/字符串(String)","date":"2021-07-24T15:44:51.000Z","updated":"2021-10-27T04:40:15.853Z","comments":true,"path":"2021/07/24/java/常用类库/字符串(String)/","link":"","permalink":"https://silenthly.github.io/2021/07/24/java/%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%BA%93/%E5%AD%97%E7%AC%A6%E4%B8%B2(String)/","excerpt":"java中的字符串 ​ 在java中，String这个单词的首字母是大写的，在java中是一个比较特殊的类，String类是为创建和处理字符串而设计的。","text":"java中的字符串 ​ 在java中，String这个单词的首字母是大写的，在java中是一个比较特殊的类，String类是为创建和处理字符串而设计的。 ​ **注意：字符串常量是String类的匿名对象(即没有名字，这个对象的地址在栈中不存在)。**因为在任何语言的底层上面都不可能会提供有直接的字符串类型，现在的字符串只是高级语言提供给用户方便开发的支持而已。而他本身存的也不是字符串。所以在java中本身也没有提供字符串常量的概念，所有使用“”定义的内容本质上来讲都是String类的一个匿名对象。 ​ 下面介绍String的初始化格式。 格式一：使用直接赋值方式 1String 字符串名=&quot;字符串内容&quot;; 格式二：使用String类的构造方法 1String 字符串名=new String(&quot;字符串内容&quot;); ​ 以上两种格式生成的字符串效果是相同的，但是存储机制却存在很大的区别。 ​ java为String类提供了一种称为缓冲池机制的功能。当使用格式一的方式，java编译器总是先到缓冲池去寻找是否存在相同内容的字符串。如果存在就可以直接使用，若不存在则在缓冲池内创建一个新的字符串。 ​ 若是使用格式二，用new关键字调用构造方法的方式，则每次调用都会生成一个新的String对象。 字符串的比较 ​ 字符串的比较有两种方式： 使用&quot;==&quot;关系运算符 ​ 使用&quot;==&quot;关系运算符，可以用于判断基本数据类型的变量值是否相等，或者判断引用数据类型变量的引用地址是否相同。 代码实例： 12345678910111213141516171819202122public class Test&#123; public static void main(String[] args) &#123; String str1=&quot;java学习笔记&quot;; String str2=&quot;java学习笔记&quot;; String str3=new String(&quot;java学习笔记&quot;); String str4=str3; if(str1==str2) //比较字符串1和2 System.out.println(&quot;str1==str2:ture&quot;); else System.out.println(&quot;str1==str2:false&quot;); if(str3==str4) //比较字符串3和4 System.out.println(&quot;str3==str4:ture&quot;); else System.out.println(&quot;str3==str4:false&quot;); if(str1==str3) //比较字符串1和3 System.out.println(&quot;str1==str3:ture&quot;); else System.out.println(&quot;str1==str3:false&quot;); &#125;&#125; 输出结果： 123str1==str2:turestr3==str4:turestr1==str3:false ​ 为什么会出现这样的结果呢？下面通过图1来说明： 图1 ​ 从图1中可以知道，String类型的内容是保存在堆内存的，栈内存仅保存指向堆内存的地址。前面说过 String使用直接赋值生成对象，会用到缓冲池机制。在执行 String str1=&quot;java学习笔记“时，在缓冲池内并没有&quot;java学习笔记“字符串，所以生成一个&quot;java学习笔记“字符串。执行到 String str2=&quot;java学习笔记“时，缓冲池中已存在&quot;java学习笔记“字符串，所以不需要在生成一个新的&quot;java学习笔记“字符串而是直接使用该字符串。使用new关键字调用构造方法生成字符串时,不会用到缓冲池机制。每调用一次就会生成新的字符串对象。 ​ 由于缓冲池机制，st1和s2使用相同的字符串对象，所以它们的内存地址是相等的，所以使用“==”关系运算符比较s1和st2结果值为ture。同理，因为strl和str3指向不同的内存地址值，所以st1=st3的结果值为 false。从程序中可以发现，st3和str4指向同一个内存地址值，所以st3=str4的结果值为tue。 使用对象的equals()方法 ​ 使用对象的equals()方法，用于判断引用对象的引用地址所指向的存储内容是否相等。 格式： 1对象1.equals(对象2); 代码示例： 12345678910111213141516171819202122public class Test&#123; public static void main(String[] args) &#123; String str1=&quot;java学习笔记&quot;; String str2=&quot;java学习笔记&quot;; String str3=new String(&quot;java学习笔记&quot;); String str4=str3; if(str1.equals(str2)) //比较字符串1和2 System.out.println(&quot;str1.equals(str2):ture&quot;); else System.out.println(&quot;str1.equals(str2):false&quot;); if(str3.equals(str4)) //比较字符串3和4 System.out.println(&quot;str3.equals(str4):ture&quot;); else System.out.println(&quot;str3.equals(str4):false&quot;); if(str1.equals(str3)) //比较字符串1和3 System.out.println(&quot;str1.equals(str3):ture&quot;); else System.out.println(&quot;str1.equals(str3):false&quot;); &#125;&#125; 输出结果： 123str1.equals(str2):turestr3.equals(str4):turestr1.equals(str3):ture ​ equals()方法是Object类中定义的一个方法，所有的类都是继承自Object类。因此该方法可以在其他引用类型中使用。在这里String已经重写了Object类的equals()方法。 equals方法的特性 1、自反性：对于任何非空引用值 x，x.equals(x) 都应返回 true。 2、对称性：对于任何非空引用值 x 和 y，当且仅当 y.equals(x) 返回 true 时，x.equals(y) 才应返回 true。 3、传递性：对于任何非空引用值 x、y 和 z，如果 x.equals(y) 返回 true，并且 y.equals(z) 返回 true，那么 x.equals(z) 应返回 true。 4、一致性：对于任何非空引用值 x 和 y，多次调用 x.equals(y) 始终返回 true 或始终返回 false，前提是对象上 equals 比较中所用的信息没有被修改。 5、使用equals()方法时，字符串的比较常量放前面好，例如 str.equals(“a”)，如果 str 为 null 时，会抛出异常，降低JVM的性能；若为&quot;a&quot;.equals(str)，输入的 str 为 null 时，则返回false。 String不可变的特性 ​ String类是不可变类，一旦String对象创建后，对象中包含的字符串就不能再进行任何的修改。若要更改String变量引用的字符串，那么只有放弃对原先字符串的引用，改为引用新的字符串。 先看以下代码： 12345678910public class Test&#123; public static void main(String[] args) &#123; String str=&quot;java&quot;; System.out.println(&quot;改变前：&quot;+str); str+=&quot;language&quot;; System.out.println(&quot;改变后：&quot;+str); &#125;&#125; 输出结果： 12改变前：java改变后：javalanguage ​ 在以上程序中，这里并不是改变了str里的值，而是str变量引用方式了改变，原来堆内存中保存的”java“字符串还是没有改变。 **注意：执行str+=&quot;language&quot;时，除了java环境产生”java“和”javalanguage“字符串常量以外，还存在一个&quot;language&quot;字符串常量，因为String类是不可变的，所以会产生很多临时变量，会增加内存的消耗，**使用StringBuffer或StringBuilder可以很好解决这个问题。 ​ ps：除了可以使用”+“号连接字符串，还可以使用String类中的concat()方法，如：str2=str1.concat(&quot;Hello&quot;)。 String类的常用方法 ​ 除了前面使用的equals()方法以外，String类还有许许多多的方法，下面列出比较常用的方法。 序号 方法 类型 说明 1 String(byte[] bytes) 构造 将指定的byte数组转换为字符串 2 String(byte[] bytes,int offset,int length) 构造 将指定范围的byte数组转换为字符串 3 String(char[] value) 构造 将指定的char数组转换为字符串 4 String(char[] value,int offset,int count) 构造 将指定范围的char数组转换为字符串 5 String(StringBuffer buffer) 构造 将StringBuffer类对象转换为字符串 6 char charAt(int index) 普通 从字符串中提取指定位置的字符 7 String concat(String str) 普通 将指定字符串连到此字符串结尾 8 boolean contentEuqals(StringBuffer sb) 普通 比较String与StringBuffer是否有相同的字符序列，若有则返回ture，否则返回false 9 boolean endsWith(String suffix) 普通 字符串是否以指定的后缀结束 10 boolean equals(Object anObject) 普通 比较两个字符串的内容是否相等 11 boolean equalsIgnoreCase(String anotherString) 普通 不区别大小写的比较两个字符串的内容是否相等 12 byte[] getByte() 普通 将一个字符串变为byte数组 13 int indexOf(String str) 普通 从头开始搜索指定子字符串的位置，若指定的字符&lt;串存在则返回字符串的位置，否则返回-1 14 int length() 普通 返回此字符串的长度 15 boolean matches(String regex) 普通 检测此字符串是否匹配指定的正则表达式 16 String replace(char oldChar,char new Char) 普通 用newChar字符替换字符串中出现的所有oldChar字符 17 String replaceAll(String regex,String replacement) 普通 字符串替换 18 String[] split(String regex) 普通 按照指定的字符拆分字符串 19 boolean startsWith(String prefix) 普通 判断字符串是否以指定的前缀开始 20 String substring(int start) 普通 截取从开始点到结尾的字符串 21 String substring(int strat,int end) 普通 截取从开始点到结束点的字符串 22 char[] toCharArray() 普通 将字符串转换为字符数组 23 String toLowerCase() 普通 将字符串中的所有字符转为小写字母 24 String toUpperCase() 普通 将字符串中的所有字符转为大写字母 25 Sting trim() 普通 清除两端的空格 26 static String valueOf(int i) 静态 将int型转换为字符串的表达式 表格中出现的regex单词是正则式，标黑则是在文章中使用过。更多方法参考JAVA API帮助文档。 部分方法示例： 从字符串中提取指定位置的字符 ​ 使用charAt()方法 123456789public class Test&#123; public static void main(String[] args) &#123; String str=&quot;Hello World&quot;; char ch=str.charAt(6); System.out.println(str+&quot;第6索引位置的字符是&quot;+ch); &#125;&#125; 输出结果： 1Hello World第6索引位置的字符是W //第一个索引位置为0，即字符H 判断是否以指定字符串开头或结尾 ​ 分别使用startsWith()方法和endsWith()方法 123456789public class Test&#123; public static void main(String[] args) &#123; String str=&quot;Hello World,here is java&quot;; System.out.println(str+&quot;是否以Hello开头&quot;+str.startsWith(&quot;Hello&quot;)); System.out.println(str+&quot;是否以class结尾&quot;+str.endsWith(&quot;class&quot;)); &#125;&#125; 输出结果： 12Hello World,here is java是否以Hello开头trueHello World,here is java是否以class结尾false 比较字符串，不区分字符串中的大小写 ​ 使用equalsIgnoreCase()方法，注意与equals()方法的区别 12345678910public class Test&#123; public static void main(String[] args) &#123; String strLower=&quot;stringtest.java&quot;; String strUpper=&quot;STRINGTEST.JAVA&quot;; System.out.println(strLower+&quot;与&quot;+strUpper+&quot;区别大小比较：&quot;+strLower.equals(strUpper)); System.out.println(strLower+&quot;与&quot;+strUpper+&quot;不区别大小比较：&quot;+strLower.equalsIgnoreCase(strUpper)); &#125;&#125; 输出结果： 12stringtest.java与STRINGTEST.JAVA区别大小比较：falsestringtest.java与STRINGTEST.JAVA不区别大小比较：true 将字符串变为字符数组，再将字符数组装换回字符串 ​ 分别使用toCharArray()方法和valueOf()方法 1234567891011121314public class Test&#123; public static void main(String[] args) &#123; String str=&quot;java是面向对象的编程语言&quot;; char ch[]=str.toCharArray(); for(char chx:ch) &#123; System.out.print(chx+&quot; &quot;); &#125; String strChar=String.valueOf(ch); System.out.println(&quot;\\n&quot;+strChar); &#125;&#125; 输出结果： 12j a v a 是 面 向 对 象 的 编 程 语 言java是面向对象的编程语言 ​ 也可以使用String(byte[] value)把字符数组装换为字符串。使用构造方法的好处是可以把全部字符装换为字符，也可以部分转换。 12345678910public class Test&#123; public static void main(String[] args) &#123; String str=&quot;stringtest.java&quot;; byte strbyte[]=str.getBytes(); //将字符串转换为byte数组 System.out.println(new String(strbyte)); System.out.println(new String(strbyte,0,6)); &#125;&#125; 输出结果： 12stringtest.javastring 寻找指定的子字符串是否存在 ​ 使用indexOf()方法 123456789public class Test&#123; public static void main(String[] args) &#123; String str=&quot;programming&quot;; System.out.println(&quot;pro是否存在&quot;+str+&quot;之中:&quot;+str.indexOf(&quot;pro&quot;)); System.out.println(&quot;e是否存在&quot;+str+&quot;之中:&quot;+str.indexOf(&quot;e&quot;)); &#125;&#125; 输出结果： 12pro是否存在programming之中:0e是否存在programming之中:-1 获取字符串的长度 ​ 使用length()方法 12345678910public class Test&#123; public static void main(String[] args) &#123; String str1=&quot;java&quot;; String str2=&quot;java是面向对象的编程语言&quot;; System.out.println(str1+&quot;的长度为:&quot;+str1.length()); System.out.println(str2+&quot;的长度为:&quot;+str2.length()); &#125;&#125; 输出结果： 12java的长度为:4java是面向对象的编程语言的长度为:14 将指定的字符串换成其他的字符或字符串 ​ 使用replace()方法可以将字符串内指定的字符替换为其他字符，而replaceAll()方法可以将字符串内指定的字符串替换为其他字符串。 12345678910public class Test&#123; public static void main(String[] args) &#123; String str1=&quot;java&quot;; String str2=&quot;java is a programming language&quot;; System.out.println(&quot;将&quot;+str1+&quot;内的a换为e：&quot;+str1.replace(&#x27;a&#x27;,&#x27;e&#x27;)); System.out.println(&quot;将&quot;+str2+&quot;内的java换为C++：&quot;+str2.replaceAll(&quot;java&quot;,&quot;C++&quot;)); &#125;&#125; 输出结果： 12将java内的a换为e：jeve将java is a programming language内的java换为C++：C++ is a programming language 根据指定的字符串将字符串拆散 ​ 使用split()方法可以根据指定的字符串将字符串拆散，拆分的字符串以字符串数组的形式返回。 12345678910public class Test&#123; public static void main(String[] args) &#123; String str=&quot;java is a programming language&quot;; String strArray[]=str.split(&quot; &quot;); for(int i=0;i&lt;strArray.length;i++) System.out.print(strArray[i]+&quot;、&quot;); &#125;&#125; 输出结果： 1java、is、a、programming、language、 截取字符串 ​ 使用substring()方法，可以截取从开始点到结尾的字符串，也可以截取从开始点到结束点的字符串。 123456789public class Test&#123; public static void main(String[] args) &#123; String str=&quot;java是面向对象的编程语言&quot;; System.out.println(&quot;截取&quot;+str+&quot;从10开始的字符串：&quot;+str.substring(10)); System.out.println(&quot;截取&quot;+str+&quot;从5到9的字符串：&quot;+str.substring(5,9)); &#125;&#125; 输出结果： 12截取java是面向对象的编程语言从10开始的字符串：编程语言截取java是面向对象的编程语言从5到9的字符串：面向对象 将字符串大小写转换 ​ 使用toLowerCase()方法和toUpperCase()方法 12345678910public class Test&#123; public static void main(String[] args) &#123; String str1=&quot;programming&quot;; String str2=&quot;LANGUAGE&quot;; System.out.println(str1+&quot;转换为大写：&quot;+str1.toUpperCase()); System.out.println(str2+&quot;转换为小写：&quot;+str2.toLowerCase()); &#125;&#125; 输出结果： 12programming转换为大写：PROGRAMMINGLANGUAGE转换为小写：language 取出字符串头尾的空格 ​ 使用trim()方法 12345678public class Test&#123; public static void main(String[] args) &#123; String str=&quot; java &quot;; System.out.println(str+&quot;去除空格：&quot;+str.trim()); &#125;&#125; 输出结果： 1java 去除空格：java 参考链接： equals方法详解_m0_37027631的博客-CSDN博客 String类匿名对象_编程语言基础知识-CSDN博客 参考书目： 《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"封装类","slug":"java/基本知识/封装类","date":"2021-07-23T16:32:16.000Z","updated":"2021-10-27T04:50:26.860Z","comments":true,"path":"2021/07/24/java/基本知识/封装类/","link":"","permalink":"https://silenthly.github.io/2021/07/24/java/%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/%E5%B0%81%E8%A3%85%E7%B1%BB/","excerpt":"封装类的简介 ​ 基本数据类型不支持面向对象的编程机制，也不具备“对象”特性，所以没有属性和方法可以被调用。在java编程时，操作的内容基本都是对象，所以希望将基本数据类型当做对象来使用，这就需要的是封装类，也称包装类。封装类的作用是将基本数据类型转变为类的形式。下面列出了类封装与基本数据类型的关系：","text":"封装类的简介 ​ 基本数据类型不支持面向对象的编程机制，也不具备“对象”特性，所以没有属性和方法可以被调用。在java编程时，操作的内容基本都是对象，所以希望将基本数据类型当做对象来使用，这就需要的是封装类，也称包装类。封装类的作用是将基本数据类型转变为类的形式。下面列出了类封装与基本数据类型的关系： 序号 基本数据类型 封装类 构造方法 1 boolean Boolean Boolean(boolean value)或Boolean(String s) 2 byte Byte Byte(byte value)或Byte(String s) 3 char Character (char value) 4 short Short Short(short value)或Short(String s) 5 int Integer Integer(int value)或Integer(String s) 6 long Long Long(long value)或Long(String s) 7 float Float Float(float value)、Float(double value)或Float(String s) 8 double Double Double(double value)或Double(String s) 1、除了char类型与int类型的封装类名称与基本数据类型名称差别较大外，其余封装类皆是把基本类型名称首字母大写即可。 2、除了Character类型与Float类型，其余封装类均有两个构造方法，一个是基本数据类型，一个是String。 3、Character类型只提供一个参数为char类型的构造方法。 4、Float类型有三个构造方法，一个是String类型，一个是float类型，一个是double类型。 下面介绍构造方法的用法。 如Float类构造方法： 1、Float(double value)：构造一个新分配的Float对象，它表示double类型转换为float类型的参数; 2、Float(float value)：构造一个新分配的Float对象，它表示基本的float参数; 3、Float(String s)：构造一个新分配的Float对象，它表示String参数所指示的float值; 封装类的继承关系： Character和Boolean类属于Object类的子类 Byte、Short、Integer、Long、Float和Double均属于Number类的子类。 封装类的作用 ​ 封装类属于引用数据类型，具有属性和方法，使用这些方法可以实现很多基本数据类型所没有的能： 将基本数据类型封装后，可当做对象进行使用。 为基本数据类型提供各种转换功能，如将数值转换为字符串，将字符串转换为数值等。 该部分可先稍作了解，下面开始介绍该如何使用。 装箱与拆箱 装箱 ​ 装箱是指把基本数据类型变为对应的封装的过程，如将int型封装为Integer对象类型，其他基本数据类型也是可以封装成相对应的封装类。 格式： 1封装类 对象名=new 封装类(要封装的参数); //这里的参数不是任意的，具体可参照上面的表格 拆箱 ​ 拆箱是指将封装类转变为对应的基本数据类型的过程。如将Integer封装为int型，其他封装类型也是可以封装成相对应的基本数据类型。 格式： 1基本数据类型 数据名=封装类对象名.基本数据类型Value(); //注意这里是空参数，理论上可将封装类拆成其他数据类型，不过考虑到精度问题，最好还是不要不要不要拆成其他类型(重要事情说三遍) 手动装箱与拆箱实例： 12345678910111213public class Test&#123; public static void main(String[] args) &#123; //手动装箱 int x=100; Integer y=new Integer(x); //将基本数据类型x封装为Integer对象类型 System.out.println(&quot;封装类Integer类型y=&quot;+y); //手动拆箱 Float f=new Float(3.14F); //将基本数据类型3.14封装为Float对象类型 float h=f.floatValue(); //将对象类型转换为基本数据类型 System.out.println(&quot;基本数据float类型h=&quot;+h); &#125;&#125; 输出结果： 12封装类Integer类型y=100基本数据float类型h=3.14 JDK1.5以后提供的自动装箱与拆箱操作实例： 12345678910111213public class Test&#123; public static void main(String[] args) &#123; //自动装箱 int x=100; Integer y=x; //将基本数据类型x封装为Integer对象类型 System.out.println(&quot;封装类Integer类型y=&quot;+y); //自动拆箱 Float f=new Float(3.14F); //将基本数据类型3.14封装为Float对象类型 float h=f； //将对象类型转换为基本数据类型 System.out.println(&quot;基本数据float类型h=&quot;+h); &#125;&#125; ​ 由程序可见，自动装箱与拆箱比较方便，但有风险，建议在程序开发中使用手动装箱与拆箱。 利用封装类进行数据转换 ​ 封装类不但有封装基本数据类型的作用，而且还可以进行数据转换。 将数值转换为字符串 ​ 所有的封装类都提供了toString()方法 格式： 1String 字符串名=对象名.toString(); ​ 其中，该方法无参数，非静态的，返回值类型为字符串。此方法可以将基本数据类型的值转换为字符串，但需要创建封装类封装该值，再调用所创建对象的toString()。 代码实例： 1234567891011121314public class Test&#123; public static void main(String[] args) &#123; int x=100; Integer xp=new Integer(x); Long l=new Long(123L); Double dou=new Double(3.1415926D); String str1=xp.toString(); String str2=l.toString(); String str3=dou.toString(); System.out.println(&quot;各个数值的字符串表示：x=&quot;+xp+&quot;，l=&quot;+l+&quot;，dou=&quot;+dou); &#125;&#125; 输出结果： 1各个数值的字符串表示：x=100，l=123，dou=3.1415926 ​ 除了使用封装类提供的toString()方法以外，还可以使用String类的构造方法和valueOf()方法或者直接调用封装类的静态toString()方法，详情可查看JDK API帮助文档。 将字符串转换为数值 ​ 除了Character类，其他封装类都提供了将字符串装换为数值的方法：parseXxx()，此方法是静态方法，可以将字符串转换为对应的基本数据类的值。下标列出了各个封装类的parseXxx()方法。 格式： 1基本数据变量=封装类型.parse封装类型(); 静态方法 Boolean Byte Character Short Integer Long Float Double parseXxx(String str) √ √ √ √ √ √ √ parseXxx(String str,int i) √ √ √ √ 代码实例： 1234567891011public class Test&#123; public static void main(String[] args) &#123; String strInt=&quot;12&quot;; String strDouble=&quot;0.01&quot;; int x=Integer.parseInt(strInt); Double d=Double.parseDouble(strDouble); System.out.println(&quot;x*d=&quot;+(x*d)); &#125;&#125; 输出结果： 1x*d=0.12 注意：字符串的字符必须全部是字符，否则在转换时会抛出数组格式异常。 参考链接： java float 详解_Java Float类，Float类构造方法详解_我桃桃渡河而来的博客-CSDN博客 java-自动拆装箱和手动拆装箱_super star的博客-CSDN博客 参考书目： 《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"instanceof关键字","slug":"java/基本知识/instanceof关键字","date":"2021-07-23T10:35:24.000Z","updated":"2021-10-27T04:49:36.144Z","comments":true,"path":"2021/07/23/java/基本知识/instanceof关键字/","link":"","permalink":"https://silenthly.github.io/2021/07/23/java/%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/instanceof%E5%85%B3%E9%94%AE%E5%AD%97/","excerpt":"​ instanceof关键字属于java的二元运算符，其作用是判断某个对象是否属于某个类或接口类型。 格式： 1对象名 instanceof 类名 ​ 其中，instanceof关键字运算结果返回的是boolean值。如果对象名是instanceof关键字后面的类或接口的对象，则结果的值为ture，否则为false。","text":"​ instanceof关键字属于java的二元运算符，其作用是判断某个对象是否属于某个类或接口类型。 格式： 1对象名 instanceof 类名 ​ 其中，instanceof关键字运算结果返回的是boolean值。如果对象名是instanceof关键字后面的类或接口的对象，则结果的值为ture，否则为false。 代码实例： 1234567891011121314151617181920212223242526272829class Person&#123; public void tell() &#123; System.out.println(&quot;父类的tell()方法&quot;); &#125;&#125;class Student extends Person&#123; public void tell() &#123; System.out.println(&quot;子类的tell()方法&quot;); &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; Person per=new Student(); //子类Student向上转型为父类Person System.out.println(&quot;per属于Person类类型：&quot;+(per instanceof Person)); System.out.println(&quot;per属于Student类类型：&quot;+(per instanceof Student)); Student stu=(Student)per; //向下转型 System.out.println(&quot;stu属于Person类类型：&quot;+(stu instanceof Person)); System.out.println(&quot;stu属于Student类类型：&quot;+(stu instanceof Student)); Person person=new Person(); //创建父类对象 System.out.println(&quot;person属于Person类类型：&quot;+(person instanceof Person)); System.out.println(&quot;person属于Student类类型：&quot;+(person instanceof Student)); &#125;&#125; 输出结果： 123456per属于Person类类型：trueper属于Student类类型：truestu属于Person类类型：truestu属于Student类类型：trueperson属于Person类类型：trueperson属于Student类类型：false ​ 从程序中可以发现，通过子类实例化的对象既是子类实例，也是父类的实例，所以可以进行向上转型和向下转型。如果是通过父类实例化对象，那么该对象只是父类的实例，而不是子类的实例了，所以不能直接进行对象转换。 ​ 注意：现有继承关系，再有instanceof的使用。即右边的对象与左边的类名必须是继承树的同一分支或存在继承关系，否则编译器会报错。 参考链接：Java基础：instanceof用法详解以及注意事项_松宝睡不醒的博客-CSDN博客_instanceof 参考书目：《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"转型","slug":"java/基本知识/转型","date":"2021-07-23T07:07:49.000Z","updated":"2021-10-27T04:42:41.427Z","comments":true,"path":"2021/07/23/java/基本知识/转型/","link":"","permalink":"https://silenthly.github.io/2021/07/23/java/%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/%E8%BD%AC%E5%9E%8B/","excerpt":"了解多态 ​ 多态是面向对象计数中最灵活的机制，他不但可以增加程序的可维护性，还可以提高代码的可读性。多态性是依赖继承性的，甚至可以说是多态性是继承性的扩展，多态性分为对象方法的多态和对象类型的多态。 对象方法的多态：即方法的重载与重写。 对象类型的多态：对象类型的多态可分为向上转型和向下转型。向上转型是程序自动完成的，而向下转型必须明确指出要转型的子类类型，这是强制的。","text":"了解多态 ​ 多态是面向对象计数中最灵活的机制，他不但可以增加程序的可维护性，还可以提高代码的可读性。多态性是依赖继承性的，甚至可以说是多态性是继承性的扩展，多态性分为对象方法的多态和对象类型的多态。 对象方法的多态：即方法的重载与重写。 对象类型的多态：对象类型的多态可分为向上转型和向下转型。向上转型是程序自动完成的，而向下转型必须明确指出要转型的子类类型，这是强制的。 向上转型 ​ 向上转型是指把子类对象转换为父类对象，注意，向上转型后的对象的引用，所指向的属性是父类的属性，如果子类重写了父类的方法，那么转型后的对象调用的该方法是被重写后的方法，这个叫动态绑定。同时，向上转型后父类引用不能调用子类自己的方法。(方法依然存在，但不能访问了) ​ 如果非要调用子类的属性呢？如果不向下转型就需要给需要的属性写getter方法。 格式一： 1父类 对象名=new 子类(); //创建子类实例并赋给父类使用 格式二： 123父类 对象名=new 父类();子类 对象名=new 子类();父类对象=子类对象; //将子类实例转换成父类实例，并替换掉原来的父类实例。(参照强制转换) 代码示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243class Person&#123; public String name=&quot;小红&quot;; public void setName(String name) &#123; this.name=name; &#125; public String getName() &#123; return name; &#125;&#125;class Student extends Person&#123; public String name=&quot;小明&quot;; public void setName(String name) &#123; this.name=name; &#125; public String getName() &#123; return name; &#125;&#125;public class Test+ &#123; public static void main(String[] args) &#123; Person per=new Person(); //创建一个躯壳 Student stu=new Student(); //实验体 System.out.println(per.name); //输出父类name属性 System.out.println(stu.name); //输出子类name属性 per.setName(&quot;红孩子&quot;); stu.setName(&quot;蓝孩子&quot;); per=stu; //使用了格式二，相当于把“变异”后的对象stu命名为per System.out.println(per.name); System.out.println(stu.name); System.out.println(per.getName()); System.out.println(stu.getName()); &#125; //以上代码，对象per是对象stu转换后的形态，对象stu仍为原型。&#125; 输出结果： 123456小红 //父类per的name属性小明 //子类stu的name属性小红 //&quot;stu&quot;的name属性蓝孩子 //stu的name属性蓝孩子 //调用&quot;stu&quot;重写后的getName()方法蓝孩子 //调用stu的getName()方法 ​ 为什么会有这样的结果？因为子类在继承父类时，重写了name属性，在子类创建对象stu时，stu对象里包含两个name属性，一个是父类的name属性，在重写后成为了隐藏变量，一个是重写后的属性。在stu向上转型后称为per后，调用的name属性是隐藏属性，所以第三个输出“小红”（不理解可以看前面的文章：继承）。 ​ 倒数第二个输出“蓝孩子”，是因为getName()方法在子类中被重写了，转换为父类后，依然使用重写后的方法，其调用的是重写后的属性。 向下转型 格式： 1子类 对象名=(子类)父类实例 ​ 不同于向上转型，不能将父类对象直接向下转换为子类对象，否则会发生类型不兼容的错误。所以，在进行对象的向下转型前，必须先发生对象的向上转型。 代码实例： 123456789101112131415161718192021222324252627282930313233class Person&#123; public void tell() &#123; System.out.println(&quot;父类的tell()方法&quot;); &#125; public void say() &#123; System.out.println(&quot;父类的say()方法&quot;); &#125;&#125;class Student extends Person&#123; public void tell() &#123; System.out.println(&quot;子类的tell()方法&quot;); &#125; public void print() &#123; System.out.println(&quot;子类的print()方法&quot;); &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; Person per=new Student(); Student stu=(Student)per; stu.tell(); stu.say(); stu.print(); &#125;&#125; ​ 既然向下转型之前还要向上转型，为什么还要创造向下转型呢？其实向下转型大有妙用，这里推荐阅读此链接：Java向下转型的意义_yinhuanxu-CSDN博客_向下转型 ​ 为避免向下转型时出错，可以通过instanceof关键字判断父类对象是否能转换为子类对象。 参考链接： java 向上转型和向下转型 - 小白coder - 博客园 (cnblogs.com) 关于Java中隐藏与重写在向上转型时机制_HungTeen的博客-CSDN博客 java对象向上转型时会丢失其原有的属性,向下转型时会不会丢失其原有的属性?_百度知道 (baidu.com) 参考书目： 《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"this与super关键字","slug":"java/基本知识/this与super关键字","date":"2021-07-22T12:56:33.000Z","updated":"2021-10-27T04:48:51.778Z","comments":true,"path":"2021/07/22/java/基本知识/this与super关键字/","link":"","permalink":"https://silenthly.github.io/2021/07/22/java/%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/this%E4%B8%8Esuper%E5%85%B3%E9%94%AE%E5%AD%97/","excerpt":"this关键字 ​ this关键字在前面已经多次使用，但java中this关键字是比较难理解的，因为this关键字灵活多变。下面介绍this关键字在java中的主要作用： 使用this调用本类属性 ​ 在一个类的方法或者构造方法内部，当成员变量被局部变量隐藏时，想使用成员变量的话，可以使用this.成员变量名这样的格式来引用成员变量名。","text":"this关键字 ​ this关键字在前面已经多次使用，但java中this关键字是比较难理解的，因为this关键字灵活多变。下面介绍this关键字在java中的主要作用： 使用this调用本类属性 ​ 在一个类的方法或者构造方法内部，当成员变量被局部变量隐藏时，想使用成员变量的话，可以使用this.成员变量名这样的格式来引用成员变量名。 代码示例： 12345678910111213141516171819202122232425262728293031class Person&#123; private String name; private int age; public Person()&#123;&#125; public Person(String name,int age) //这里创建了局部同名变量name与age，隐藏了成员变量 &#123; this.name=name; this.age=age; &#125; public String getName() &#123; return name; &#125; public int getAge() &#123; return age; &#125; public void say() &#123; System.out.println(&quot;我叫&quot;+getName()+&quot;今年&quot;+getAge()+&quot;岁了&quot;); &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; Person p=new Person(&quot;小明&quot;,18); p.say(); &#125;&#125; ​ 若构造方法参数名与成员变量名不同时，可以不使用this关键字： 1234567891011class Person&#123; private String name; private int age; public Person()&#123;&#125; public Person(String n,int a) //这里创建了局部同名变量name与age，隐藏了成员变量 &#123; name=n; age=a; &#125;&#125; ​ 虽然这样可以完成为类中的成员变量赋值的功能，但是从构造方法传入的参数名，很难指定n和a分别代表什么。所以为了增强代码的可读性，一般将参数的名称和成员变量的名称保持一致。 使用this调用构造方法 ​ 在java类中，可以定义构造方法，而构造方法的名称必须与类名一致，所以构造方法只有一个名称。在程序设计中，常常以不同的方式来实例化对象，这就需要构造方法重载来形成多个构造方法。 ​ 构造方法的重载的目的是以不同的方式实例化对象。构造方法重载时，可以在构造方法中使用this()调用其他构造方法。 格式： 1this(参数列表); ​ 其中，参数列表是可选的，可根据传入的参数调用不同的构造方法。 代码示例： 1234567891011121314151617181920212223242526272829303132class Person&#123; private String name; private int age; private String sex; public Person() &#123; this.age=18; &#125; public Person(String name) &#123; this(); this.name=name; &#125; public Person(String name,String sex) &#123; this(name); this.sex=&quot;蓝&quot;; &#125; public void tell() &#123; System.out.println(&quot;我的名字叫&quot;+name+&quot;，今年&quot;+age+&quot;岁，是一个&quot;+sex+&quot;孩子&quot;); &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; Person per=new Person(&quot;小明&quot;,&quot;男&quot;); per.tell(); &#125;&#125; 输出结果： 1我的名字叫小明，今年18岁，是一个蓝孩子 注意：使用this调用其他构造方法时，必须放在构造方法的第一行。下面是错误示例： 12345public Person(String name) &#123; this.name=name; this(); &#125; this表示当前对象 ​ this关键字除了可以调用本类的属性和构造方法之外，还可以表示当前对象。 代码示例： 123456789101112131415161718192021222324252627282930class Person&#123; public String tell() &#123; System.out.println(&quot;当前调用tell()的对象为：&quot;+this); return null; &#125; public Person returnobject() &#123; System.out.println(&quot;当前调用returnobject()的对象为：&quot;+this); return this; &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; Person p1=new Person(); System.out.println(&quot;当前对象为：&quot;+p1); //直接打印出当前对象的地址 p1.tell(); System.out.println(); p1.returnobject().tell(); //先调用returnobject()，得到当前的实例，再调用tell() System.out.println(&quot;****************************************************&quot;); Person p2=new Person(); System.out.println(&quot;当前对象为：&quot;+p2); //直接打印出当前对象的地址 p2.tell(); System.out.println(); p2.returnobject().tell(); //先调用returnobject()，得到当前的实例，再调用tell() &#125;&#125; 输出结果： ​ this返回调用当前方法的对象可以用于比较对象是否相等，后续再详解。由于this是对当前实例的引用，因此只能在实例方法中使用，而不能在静态方法中使用this关键字。 super关键字 ​ 在java中，this关键字可以调用当前类中的属性、方法和构造方法，使用super关键字可以在子类中引用父类的属性。主要使用形式如下： 调用父类的属性和方法 ​ 在继承中，子类继承了父类的非private的属性和方法，一般是可以直接通过子类对象调用的。但是，如果子类中隐藏了父类的属性及重写了父类的方法，那么需要在子类中调用父类被覆盖的属性或方法时则不能直接调用了，这时需要使用super关键字。 代码示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Person&#123; public float PI=3.14F; protected String name; protected int age; protected void setName(String name) &#123; this.name=name; &#125; protected void setAge(int age) &#123; this.age=age; &#125; protected String getName() &#123; return name; &#125; protected int getAge() &#123; return age; &#125; public void tell() &#123; System.out.println(&quot;我叫&quot;+getName()+&quot;今年&quot;+getAge()+&quot;岁了。我知道圆周率为&quot;+PI); &#125;&#125;class Student extends Person&#123; public float PI=3.1415926F; private String school; public void setSchool(String school) &#123; this.school=school; &#125; public String getSchool() &#123; return school; &#125; public void tell() &#123; super.tell(); System.out.println(&quot;我叫&quot;+getName()+&quot;今年&quot;+getAge()+&quot;岁了。就读于&quot;+getSchool()+&quot;,我知道圆周率为&quot;+PI+&quot;比&quot;+super.PI+&quot;精确多了&quot;); &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; Student stu=new Student(); stu.setName(&quot;小红&quot;); stu.setAge(18); stu.setSchool(&quot;清华大学&quot;); stu.tell(); &#125;&#125; 输出结果： 12我叫小红今年18岁了。我知道圆周率为3.14我叫小红今年18岁了。就读于清华大学,我知道圆周率为3.1415925比3.14精确多了 调用父类中指定的构造方法 ​ 虽然子类不能继承父类中的私有成员，但是在父类中的这些私有成员依然是子类对象的一部分。因为在实例化对象的时候，只初始化在当前类中声明的属性明显是不足够的，还要初始化其父类中所有声明的属性。所以虽然我们不能在子类中直接访问并使用父类private修饰的内容，但可以通过调用父类本身的方法来获取和利用private修饰的内容。 ​ 所以，当子类没有重写父类私有成员，而又需要修改父类的私有成员时，可以通过super调用父类的构造方法实现(当然也可以通过setter方法实现)。 代码示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Person&#123; private String name; private int age; public Person()&#123;&#125; public Person(String name,int age) &#123; this.name=name; this.age=age; &#125; public String getName() &#123; return name; &#125; public int getAge() &#123; return age; &#125;&#125;class Student extends Person&#123; private String school; public Student(String name,int age,String school) &#123; super(name,age); //调用父类的构造方法 this.school=school; &#125; public void setSchool(String school) &#123; this.school=school; &#125; public String getSchool() &#123; return school; &#125; public void tell() &#123; System.out.println(&quot;我叫&quot;+getName()+&quot;今年&quot;+getAge()+&quot;岁了。就读于&quot;+getSchool()); &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; Student stu=new Student(&quot;小红&quot;,18,&quot;清华大学&quot;); stu.tell(); &#125;&#125; 输出结果： 1我叫小红今年18岁了。就读于清华大学 同样，super()也要放在首行。 this与super的比较 比较 this super 访问属性 用于访问示例变量，以区别局部变量。如果子类中没有该属性，则尝试从父类中寻找 访问父类中属性，但需要权限允许 使用方法 隐含调用本类方法。如果本类没有，则尝试从父类中寻找 访问父类中的方法，但需要权限允许 用于构造方法 调用本类的其他构造方法，必须放在构造方法的第一行可执行代码 调用父类中特定的构造方法，必须放在构造方法的第一行可执行代码 其他用途 表示当前对象，可以将自己作为参数传递 不能作为方法的参数传递 参考链接：[【Java】子类能获取父类中private权限的属性和方法_Together-CSDN博客_java子类获取父类属性](https://blog.csdn.net/qq_43771096/article/details/104563362) 参考书目：《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"继承","slug":"java/基本知识/继承","date":"2021-07-21T09:49:12.000Z","updated":"2021-10-27T04:50:58.296Z","comments":true,"path":"2021/07/21/java/基本知识/继承/","link":"","permalink":"https://silenthly.github.io/2021/07/21/java/%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/%E7%BB%A7%E6%89%BF/","excerpt":"继承的基本概念 ​ 继承类似于生物的纲目科分类，目为纲下的细小分类，目含有(继承)纲所有的特征，但目不仅局限于纲的特征，还包含纲所没有的其他细小的特征，以此为基础，添加更小的特征来划分科。继承也是如此，继承是两个类之间的一种关系，当一个类B继承了一个已存在的类A后，类B就拥有了类A所有的非private的属性和方法，但同时，类B中还可以根据需要添加新的属性和方法。其中，类A称为父类或基类，也可以称为超类，通过类A扩展而来的类B，称为子类或派生类。 ​ 需要注意的是，继承不是子类简单的复制和粘贴父类的属性和方法，子类并不局限于父类提供的属性和方法，还可以定义自身的属性和方法，还可以重写重父类继承来的方法。在java中一个子类只能拥有一个父类，但一个父类可以拥有多个子类。子类拥有父类所有的非private的属性和方法。","text":"继承的基本概念 ​ 继承类似于生物的纲目科分类，目为纲下的细小分类，目含有(继承)纲所有的特征，但目不仅局限于纲的特征，还包含纲所没有的其他细小的特征，以此为基础，添加更小的特征来划分科。继承也是如此，继承是两个类之间的一种关系，当一个类B继承了一个已存在的类A后，类B就拥有了类A所有的非private的属性和方法，但同时，类B中还可以根据需要添加新的属性和方法。其中，类A称为父类或基类，也可以称为超类，通过类A扩展而来的类B，称为子类或派生类。 ​ 需要注意的是，继承不是子类简单的复制和粘贴父类的属性和方法，子类并不局限于父类提供的属性和方法，还可以定义自身的属性和方法，还可以重写重父类继承来的方法。在java中一个子类只能拥有一个父类，但一个父类可以拥有多个子类。子类拥有父类所有的非private的属性和方法。 java的继承有一下几个特点： java只支持单重继承，即一个子类只能拥有一个父类，但提供了多层继承。 继承关系可以传递。若类C继承类B，类B继承类A，则类C不仅有从类B继承下类的属性和方法，也有从类A继承下来的属性和方法，还可以自己定义新的属性和方法。继承来的属性和方法尽管是隐式的，但仍是类C的属性和方法。也就是多层继承。 继承提供了软件复用功能。软件重(chong)用最常见的形式是重用程序源代码，若类B继承类A，那么建立子类(类B)时只需要再描述与基类(类A)不同的少量特征(数据成员和成员方法)即可。这样可以减少代码和数据的冗余度，大大增加程序的重用性。 继承通过一致性来减少模块将的借口和界面，大大增加了程序的易维护性。 提示：子类不能继承父类的构造方法，但可以通过super关键字调用。 子类继承父类的格式： 123456访问控制符 修饰符 class 类名 extends 父类名&#123; //属性定义 //构造方法定义 //方法声明&#125; ​ 子类虽然可以定义自身的属性和方法。如果子类中的定义或方法与父类相同，那么父类的这一属性或方法被隐藏或重写。通过子类或子类对象不再能直接调用父类的这一属性或方法，但父类或父类的对象依旧可以调用这一属性或方法。 ​ 在类声明时，如果没有使用extends关键字继承父类，则自动继承object类。 代码演示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class person&#123; private String name; private int age; public void setName(String name) &#123; this.name=name; &#125; public void setAge(int age) &#123; this.age=age; &#125; public String getName() &#123; return name; &#125; public int getAge() &#123; return age; &#125; public void respire() &#123; System.out.println(&quot;会呼吸&quot;); &#125;&#125;class student extends person&#123; private String school; public void setSchool(String school) &#123; this.school=school; &#125; public String getSchool() &#123; return school; &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; student stu=new student(); stu.setName(&quot;小明&quot;); //调用从父类继承来的方法 stu.setAge(18); stu.setSchool(&quot;麻省理工大学&quot;); stu.respire(); System.out.println(&quot;我叫&quot;+stu.getName()+&quot;今年&quot;+stu.getAge()+&quot;岁，就读于&quot;+stu.getSchool()+&quot;!&quot;); &#125;&#125; 结果： 12会呼吸我叫小明今年18岁，就读于麻省理工大学! ​ 以上程序中，student类继承了person类很多属性和方法，并增加了school属性及setSchool()和getSchool()方法。但子类并不能继承父类的private属性和方法 ，需要通过使用父类的setter方法和getter方法获得父类的private属性。 重写父类中的方法 ​ 在前面已经学过方法的重载，方法的重载是在同一个类中设置一个或多个方法名相同而参数列表不同的方法。方法的重写与重载不同，重写是在继承过程中实现的，只存在于继承中。 重写 ​ 重写是子类对父类的允许访问的方法的实现过程进行重新编写，返回值和形参都不能改变。即外壳不变，方法体重写。 代码示例： 123456789101112131415161718192021222324class Person&#123; public void tell() &#123; System.out.println(&quot;父类中的tell()方法&quot;); &#125;&#125;class Student extends Person&#123; public void tell() //此处必须与父类一致，包括参数列表 &#123; System.out.println(&quot;子类中的tell()方法，重写成功&quot;); //方法体不同 &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; Student stu=new Student(); //创建Student类的对象 Person per=new Person(); //创建Person类的对象 stu.tell(); //子类已经重写父类的方法，访问子类的方法 per.tell(); //调用父类自身的方法 &#125;&#125; 结果： 12子类中的tell()方法，重写成功父类中的tell()方法 ​ 在程序中，当父类方法被重写后，子类子类对象调用的将是被重写后的方法，但父类对象还是可以调用自身的方法(即被重写前的方法)。 重写的规则 1、子类方法的方法名、返回类型和参数列表必须与父类方法的方法名、返回类型和参数列表一致。 2、子类方法不能缩小父类方法的访问权限。例如： 1234567891011121314class Person&#123; public void tell() &#123; System.out.println(&quot;父类中的tell()方法&quot;); &#125;&#125;class Student extends Person&#123; void tell() //访问权限缩小 &#123; System.out.println(&quot;子类中的tell()方法，重写成功&quot;); &#125;&#125; ​ 这样的代码是不能通过编译的，提示编译错误。 ​ 在类的继承中，若将父类的private方法变成了子类的public算是方法的重写吗？先看下代码： 12345678910111213141516171819202122232425class Person&#123; private void tell() &#123; System.out.println(&quot;父类中的tell()方法&quot;); &#125; public void print() &#123; tell(); &#125;&#125;class Student extends Person&#123; public void tell() //访问权限改变 &#123; System.out.println(&quot;子类中的tell()方法，重写成功&quot;); &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; new Student().print(); //使用Student类的匿名对象，并调用继承来的print()方法 &#125;&#125; 结果： 1父类中的tell()方法 ​ 从结果发现，调用tell()方法还是父类Person的tell()方法，说明子类中的tell()方法并没有重写父类的tell()方法，而是在子类中重新定义了一个tell()方法，因为子类不能继承父类的private属性或方法。 3、子类不能重写父类的静态方法为非静态方法，也不能重写父类的非静态方法为静态方法。 注意：重写是为了实现多态，而多态是实例方法的动态绑定，与静态无关。当然，在子类中定义一个和父类同名的静态方法，编译器不会报错，其实这仅仅是在子类中定义了一个趋同的静态方法，与重写无关。 4、父类中的私有方法不能被子类重写。 5、子类不能抛出比父类方法更多的异常。 6、父类中的抽象方法可以被子类通过两种途径重写：一是实现父类的抽象方法；二是子类重新声明父类的抽象方法。 7、父类的非抽象方法可以被子类重写为抽象方法。 隐藏变量 ​ **在一个类中，子类中的成员变量如果和父类中的成员变量同名，那么即使他们类型不一样，只要名字一样，父类中的成员变量都会被隐藏。**当子类执行自身定义的方法时，操作被重写的变量时，所使用的是子类定义的变量。当子类执行从父类继承来的方法，调用该同名变量时，所使用的是父类的成员变量。 代码示例： 123456789101112131415161718192021222324252627282930313233class Person&#123; float popu=13.7F; static double accpopu=1370536875; public void population() &#123; System.out.println(&quot;全国人口为&quot;+accpopu+&quot;人，大约为&quot;+popu+&quot;亿&quot;); &#125; public void tell() &#123; System.out.println(&quot;全国人口为&quot;+accpopu+&quot;人，大约为&quot;+popu+&quot;亿&quot;); &#125;&#125;class Student extends Person&#123; float popu=1.08F; //隐藏父类的popu变量 static double accpopu=108640700; //隐藏父类的accpopu变量 public void population() //重写父类的实例方法population() &#123; System.out.println(&quot;全国学生人数为&quot;+accpopu+&quot;人，大约为&quot;+popu+&quot;亿&quot;); &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; Student stu=new Student(); //创建子类 stu.population(); stu.tell(); Person per=new Person(); //创建父类 per.population(); &#125;&#125; 结果： 123全国学生人数为1.086407E8人，大约为1.08亿全国人口为1.370536875E9人，大约为13.7亿全国人口为1.370536875E9人，大约为13.7亿 ​ 从程序结果可以看到，调用子类的population()方法时，所使用的是子类自身定义的同名变量，而调用从父类继承而来的tell()方法时，所使用的是父类的成员变量。 方法重载与重写的异同 比较 重载 重写 相同点 方法名 都要求方法名 方法类型 都可以用于抽象方法和非抽象方法之间 不同点 参数列表 参数列表必须不一致 参数列表必须一致 返回类型 返回值不做限制 返回值必须一致 范围 重载同一个类中的方法 在继承中，子类重写父类的方法 次数 方法的重载可以被重载多次，也可以用多个重载方法 父类的方法只能被重写一次，重写一般是两个方法之间 权限 对权限没有要求 被重写的方法不能拥有更严格的权限 调用 根据传递的参数来决定调用哪个方法 根据调用方法的对象来决定调用哪个方法 当构造方法遇到继承 ​ 在继承中，子类对象在实例化之前必须先调用父类中的构造方法，再调用子类自身的构造方法，所以在实例化子类对象时需要先将父类的属性初始化。 代码示例： 123456789101112131415161718192021class Person&#123; public Person() &#123; System.out.println(&quot;父类Person的构造方法&quot;); &#125;&#125;class Student extends Person&#123; public Student() &#123; System.out.println(&quot;子类Student的构造方法&quot;); &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; Student stu=new Student(); &#125;&#125; 结果： 12父类Person的构造方法子类Student的构造方法 参考链接： Java 重写(Override)与重载(Overload) - Java 教程 - 菜鸟学堂-脚本之家 (jb51.net) Java中方法的重写与成员变量的隐藏_java_脚本之家 (jb51.net) 子类可以重写父类的静态方法吗_wang归零的博客-CSDN博客 参考书目： 《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"java中的包(package)","slug":"java/基本知识/java中的包(package)","date":"2021-07-20T08:43:31.000Z","updated":"2021-10-27T04:49:58.168Z","comments":true,"path":"2021/07/20/java/基本知识/java中的包(package)/","link":"","permalink":"https://silenthly.github.io/2021/07/20/java/%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/java%E4%B8%AD%E7%9A%84%E5%8C%85(package)/","excerpt":"​ 为何要引用包的概念？试想一下，如果需要开发一个大项目，开发人员不是一个人而是一群人。程序员们需要编写很多类，有时候几个不同作用的类使用了相同的名字。为了避免类文件命名的冲突，java引进了包机制，提供多层的类命名空间，一解决类的重名冲突，不同包可以存在相同名的源码文件。使用包还可以根据每个类功能的不同而分门别类的存放，以便查找和使用。","text":"​ 为何要引用包的概念？试想一下，如果需要开发一个大项目，开发人员不是一个人而是一群人。程序员们需要编写很多类，有时候几个不同作用的类使用了相同的名字。为了避免类文件命名的冲突，java引进了包机制，提供多层的类命名空间，一解决类的重名冲突，不同包可以存在相同名的源码文件。使用包还可以根据每个类功能的不同而分门别类的存放，以便查找和使用。 使用package定义包 定义包就是将声明的类放入包中，为包指定包名。格式如下： 1package 包名1.包名2.包名3.··· ​ 其中，包名可以设置多层且没有个数限制，包名之间使用“.”分隔。包名需要符合java命名规范，包名所有字母为小写，不包含特殊字符。 使用包的好处有以下几点： 1、把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。 2、如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。 3、包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。 代码示例： 12345678package org.com.pack;public class PackTest&#123; public static void main(String[] args) &#123; System.out.println(&quot;定义包&quot;); &#125;&#125; 其中 1package org.com.pack; //表示源码PackTest.java保存的路径为org/com/pack/PackTest.java 1、编译这个程序需要执行以下命令： 1javac -d . PackTest.java 以上编译命令有两个参数，各参数之间用空格隔开。 -d：表示生成目录，在编译源码时，设置编译生成的class文件保存路径(即源码中package所指定的路径)，路径与定义的包名和层次相关。 .：表示在当前目录生成 2、执行程序需要到PackTest.class文件夹所在的路径，执行命令如下： 1java org.com.pack.PackTest 结果如图： 图1 图2 ​ 如果程序法比较小，类文件也不多，则根本不需要使用包。但是随着创建的java程序越来越多，拥有的类也变得很多的时候，这就需要使用包将所有的类文件分门别类的存放。 使用包的注意事项; 1、package语句必须是程序中可执行的第一行代码。 2、package语句只能有一句 3、在前面的包名为后面包名父目录 4、没有package语句，则默认无包名 使用import导入包 ​ 当定义包后，同一个包中的类是默认导入的，但如果一个类访问来自另一个包中的类，那么前者必须通过import语句把后者导入才能使用。import语句导入包的语法格式如下： 格式一： 1import 包名1.包名2.···.类名; 该格式只会导入包中的一个具体的类，不会导入其他类。 格式二： 1import 包名1.包名2.···.*; 这里的&quot;*&quot;是通配符，该命令可以导入一个包中的所有的类，但并不会导入这个包中子包的类，若需要子包的类还必须单独导入。 代码示例： 定义org.com.pack.stu.Student类 1234567891011121314151617181920212223242526272829303132package org.com.pack.stu;public class Student&#123; private String name; //name属性 private int age; //age属性 public Student ()&#123;&#125; //无参构造方法 public Student(String name,int age) //有参构造方法,初始化name和age属性 &#123; setName (name); setAge(age); &#125; public void setName(String name) //设置name属性 &#123; this.name=name; &#125; public void setAge(int age) //设置age属性 &#123; this.age=age; &#125; public String getName() //取得name属性 &#123; return name; &#125; public int getAge() //取得age属性 &#123; return age; &#125; public void show() //定义show()方法,打印name和age属性 &#123; System.out.println(&quot;我的名字叫&quot;+getName()+&quot;今年&quot;+ getAge()); &#125;&#125; 定义一个类引用org.com.pack.stu.Student类 12345678910package org.com.pack.pack;import org.com.pack.stu.Student;public class PackTest&#123; public static void main(String[] args) &#123; Student stu=new Student(&quot;小明&quot;,18); stu.show(); &#125;&#125; javac可以一次编译多个class文件，只需要在javac命令后面添加需要编译的文件名即可，如： 1javac -d . Student.java PackTest.java 结果：我的名字叫小明今年18 注意：一个包中的类只有声明为public，才能被其他包的类引用，若包中具有默认的访问权限的类，只能在同一包中使用。不同包中的类根据其声明的访问控制符的不同，具有不同的访问权限。下面来看不同包中类成员的访问权限。 public访问权限的类成员 包中的 public类中的 public员可以被其他包中的类访问； public类中的 protected成员可以被本包中的类或其他包中子类访问。 默认访问权限的类成员 无论类的访问修饰符是什么，类中的默认访问权限的类成员，都不能被其他包中的类访问。 其他访问权限可查看访问权限表。 静态导入 ​ import语句不仅可以导入指定包中的某个类或全部类，JDK5.0以后还增加了静态导入的功能。静态导入用于导入指定类的某个静态属性或静态方法。静态导入的语法格式如下 格式一：导入类中全部静态成员 1import static 包名1.···.类名.*; 格式二：导入类中的某个静态属性或静态方法 1import static 包名1.···.类名.静态成员名; 为什么要使用静态导入能？在java开发中，我们会经常用到一些静态常量用于状态判断等操作。为了能够在多个地方复用这些常量，通常每个模块都会加一个常量类，举个简单的列子： 12345678910111213141516import com.sky.OrderMouleConsstants; /** * Created by gantianxing on 2017/4/21. */ public class Test &#123; public void main() &#123; int orderState = orderService.getOrderState(id); if(OrderMouleConsstants.SUCCESS == orderState)&#123; //订单成功状态逻辑 &#125; if(OrderMouleConsstants.FAIL == orderState)&#123; //订单失败状态逻辑 &#125; &#125; &#125; 为了表达常量类的特定使用模块，我们经常会把模块名称加载类名里，导致常量类的名字很长。在写代码的时候，经常来回copy，用户起来很不方便。 其实在jdk1.5开始就已经引入了“静态导入机制”，可以解决这个问题。 注意事项： 1.只能导入静态的 2.如果有多个同名静态方法，那么它不知道该导谁，必须要加前缀 3.如果使用单静态导入声明导入静态成员，并且在同一个类中存在具有相同名称的静态成员，则使用该类中的静态成员。 静态导入似乎可以帮助您使用静态成员的简单名称来简化程序的编写和读取。有时静态导入可能会在程序中引入细微的错误，这可能很难调试。建议您根本不使用静态导入，或仅在极少数情况下使用静态导入。 参考链接： 静态导入 - 知乎 (zhihu.com) java静态导入_javaZhong的博客-CSDN博客_静态导入 java中静态导入机制用法实例详解_java_脚本之家 (jb51.net) 参考书目： 《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"值传递与引用传递","slug":"java/基本知识/值传递与引用传递","date":"2021-07-18T18:43:23.000Z","updated":"2021-10-27T04:42:11.739Z","comments":true,"path":"2021/07/19/java/基本知识/值传递与引用传递/","link":"","permalink":"https://silenthly.github.io/2021/07/19/java/%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/%E5%80%BC%E4%BC%A0%E9%80%92%E4%B8%8E%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/","excerpt":"​ 由已学的知识，我们可以知道类中的成员方法实质相当与c语言的函数，既然是函数，不可避免牵涉到参数传递，但java与c传递参数的形式是不一样的，最明显的区别是java没有指针，那么java如何实现指针功能呢？","text":"​ 由已学的知识，我们可以知道类中的成员方法实质相当与c语言的函数，既然是函数，不可避免牵涉到参数传递，但java与c传递参数的形式是不一样的，最明显的区别是java没有指针，那么java如何实现指针功能呢？ java参数传递的实质 ​ java编程语言只有值传递，什么是值传递？值传递是指在调用函数时将实际参数赋值一份传递到函数中，这样在函数中对参数进行修改，将不会影响实际参数。根据实参的值的类型，主要将参数的传递形式分为两种： 值传递 ​ 值传递的参数是基本数据类型，如int型、float型和char型等。就是传递参数到方法时，方法获得的只是该参数值的一个副本，所以方法不会改变参数变量的值，只是使用该参数变量的值。 代码示例如下： 1234567891011121314public class Test&#123; public static void main(String[] args) &#123; int b=20; change(b); //把b作为实参传递进change()方法中 System.out.println(&quot;b=&quot;+b); &#125; public static void change(int a) //接收形参 &#123; a=100; //改变形参的值 System.out.println(&quot;a=&quot;+a); &#125;&#125; 结果： 12a=100b=20 其中形参a是实参b是副本，形参a的值已经改变，实参b的值无影响。 引用传递 ​ 引用传递实质也是值传递，不同的是，实参传递过来的是一个地址，而非基本类型，即便在生成副本后，副本中的值仍然是那个地址，而地址指向的值是唯一的。所以在方法中改变了形参指向的地址的内容，实参的值也会跟着变化，类似于c/c++中的指针。 ​ 那么，什么样的参数是一个地址呢？我们首先来看一下代码： 12345678910111213141516171819202122class Student&#123; int number; public Student(int num) //带参数的构造方法 &#123; this.number=num; &#125;&#125;public class Test&#123; public static void change(Student s) &#123; s.number=20; //改变number的属性 &#125; public static void main(String[] args) &#123; Student stu=new Student(10); //实例化Student对象 System.out.println(&quot;引用传递前：&quot;+stu.number); change(stu); System.out.println(&quot;引用传递后：&quot;+stu.number); &#125;&#125; 结果： 12引用传递前：10引用传递后：20 ​ 从程序的运行结果可以发现，change()方法接收的是Student对象stu，所以该参数传递的是引用数据类型。那么，程序是如何实现该过程的呢？下面用文字简述一下程序流程。 ​ 在程序执行到Student stu=new Student(10)时，分别在栈内存和堆内存开辟空间供对象stu使用，其中栈内存存储的是stu对象在堆内存的地址。程序继续向下执行到change(stu)时，将对象stu的地址副本作为参数向change()方法传递，形参s与实参stu指向同一个地址，即同一个对象，change()方法通过形参s对stu对象的属性number进行操作并改变了number的值，这一改变保留在对象中。当change()方法执行结束后，形参s的引用被断开，但stu还是指向已被改变的对象。 ​ 注意：如果在函数中改变了副本的地址，如new一个，那么副本就指向了一个新的地址，此时传入的参数还是指向原来的地址，所以不会改变参数的值。 String类的传递 先看代码： 1234567891011121314public class Test&#123; public static void change(String s) &#123; s=&quot;小明&quot;; &#125; public static void main(String[] args) &#123; String s=&quot;小强&quot;; System.out.println(&quot;引用传递前：&quot;+s); change(s); System.out.println(&quot;引用传递后：&quot;+s); &#125;&#125; 结果： 12引用传递前：小强引用传递后：小强 ​ 引用调用前后String类的对象并没有改变，这是为何？在调用change()方法时String对象的地址的确传入了方法中，但是变量a的值并没有发生改变，这是因为String不可变的特性。 ​ 总而言之，所有函数调用本质都是值的传递，值传递传入的是基本数据类型值的副本；引用传递传入这个引用地址的副本，这个引用地址实际是一个值。 参考链接：Java值传递和引用传递详解_java_脚本之家 (jb51.net) 参考书目：《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"封装性与访问控制符","slug":"java/基本知识/封装性与访问控制符","date":"2021-07-18T14:14:23.000Z","updated":"2021-10-27T04:47:29.304Z","comments":true,"path":"2021/07/18/java/基本知识/封装性与访问控制符/","link":"","permalink":"https://silenthly.github.io/2021/07/18/java/%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/%E5%B0%81%E8%A3%85%E6%80%A7%E4%B8%8E%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E7%AC%A6/","excerpt":"包的概念： ​ java中的包类似于操作系统中的文件加，将具有类似功能的类或者相同的类放在相同的包里面，便于组织和管理包的作用。 ​ 1、开发过程中避免类名重复问题 ​ 2、对代码整理归类，将功能相近的类放到一个包中管理 ​ 3、限定访问权限","text":"包的概念： ​ java中的包类似于操作系统中的文件加，将具有类似功能的类或者相同的类放在相同的包里面，便于组织和管理包的作用。 ​ 1、开发过程中避免类名重复问题 ​ 2、对代码整理归类，将功能相近的类放到一个包中管理 ​ 3、限定访问权限 调用摸个包中的类的三种方式 ​ 1、使用一个类的全名：即包名+类名 ​ 注意：在包中，所有类的真正名字即是包名+类名的组合，所以在运行的时候要将包层给写上， 不能直接写类名。 ​ 2、使用import语句导入一个包中的所有的类。 ​ 3、使用import语句导入一个包中的特定的类。 java中访问控制符的具体用法 为什么需要控制对成员的访问？ ​ 1.为了使用户不要碰触那些他们不该碰触的部分，这些部分对于类内部的操作是必要的，但是它并不属于客户端程序员所需接口的一部分。 ​ 2.让类库设计者可以更改类的内部工作方式，而不必担心这样会对客户端程序员产生重大的影响。 访问控制符 1、类访问控制符 public default（默认类型，不需写出来） 2、对象访问控制符 public：没有限制，任意包中的任意类都可以访问 protect：被修饰的只能被同一个包中的所有类访问，或者不同包中的子类访问 default：只能被同一个包中的所有类访问 private：只能被同一个类中的方法访问 访问权限 访问权限 private default protect public 同一类中 √ √ √ √ 同一个包中 —— √ √ √ 子类 —— —— √ √ 全局范围 —— —— —— √ 其中，“√”表示可以访问，“——”表示不可访问。 注意：在一个类内部，访问控制符是透明的，失效的 代码演示： (1)在一个类的内部，所有的成员彼此之间都可以进行相互访问，访问控制符是透明的，失效的，共有的可以调用私有的，私有的可以调用共有的。 123456789101112131415161718192021222324252627282930package com.vg.demo01;public class Test&#123; public void test1() &#123; System.out.println(&quot;可访问public内容&quot;); test4(); &#125; protected void test2() &#123; System.out.println(&quot;可访问protected内容&quot;); &#125; void test3() &#123; System.out.println(&quot;可访问default内容&quot;); &#125; private void test4() &#123; System.out.println(&quot;可访问private内容&quot;); &#125; public static void main(String[] args) &#123; Test t=new Test(); t.test1(); t.test2(); t.test3(); t.test4(); &#125;&#125; 结果： 12345可访问public内容可访问private内容可访问protected内容可访问default内容可访问private内容 (2)在同包不同类之间，只有其私有成员不可以通过类对象名的方式进行访问，共有成员和保护型的成员都可以通过这种方式进行访问. 简言之:在同一个包的内部,只有其私有成员不能够进行访问 123456789101112package com.vg.demo01;//private是不能在同包的子类中起作用的。public class TestSon extends Test&#123; public static void main(String[] args ) &#123; TestSon s = new TestSon(); s.test1(); s.test2(); s.test3(); &#125;&#125; 结果： 1234可访问public内容可访问private内容可访问protected内容可访问default内容 (3)在不同包存在继承关系的两个类之间，只有共有类的共有成员和共有类的保护型成员才可以被另外一个包中的子类进行访问，但是在一个子类的外部，只有共有类的共有成员才可以被直接的访问. 12345678910111213package com.vg.demo02; import com.vg.demo01.*;//在不同的包中，类的子类只有public、protected这俩个可以产生效果public class TestrOtherSon extends Test&#123; public static void main(String[] args) &#123; TestOtherSon th = new TestOtherSon(); th.test1(); th.test2(); &#125;&#125; 结果： 123可访问public内容可访问private内容可访问protected内容 (4)在不同包无任何关系的两个类之间，只有共有类的共有成员才可以被另外一个包中的类进行访问. 1234567891011package com.vg.demo02; import com.vg.demo01.Test;public class TestOtherNotSon&#123; public static void main(String[] args) &#123; Test t = new Test(); t.test1(); &#125;&#125; 结果： 12可访问public内容可访问private内容 参考链接：Java访问控制符原理及具体用法解析_java_脚本之家 (jb51.net)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"方法的重载和递归","slug":"java/基本知识/方法的重载和递归","date":"2021-07-17T01:52:39.000Z","updated":"2021-10-27T04:44:55.302Z","comments":true,"path":"2021/07/17/java/基本知识/方法的重载和递归/","link":"","permalink":"https://silenthly.github.io/2021/07/17/java/%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD%E5%92%8C%E9%80%92%E5%BD%92/","excerpt":"方法的重载 ​ 方法重载是java语言中常见的语法，是指允许在同一个类中具有多个方法名和相同而参数列表不同的方法。方法重载可以让程序对不同的消息做出不同的响应，重载可以加强程序的可读性和可维护性。","text":"方法的重载 ​ 方法重载是java语言中常见的语法，是指允许在同一个类中具有多个方法名和相同而参数列表不同的方法。方法重载可以让程序对不同的消息做出不同的响应，重载可以加强程序的可读性和可维护性。 方法重载的规则 1、方法名必须相同。 2、参数列表必须不同，只与参数类型、参数个数有关，与方法的类型(返回值无关。 3、返回值类型可以相同也可以不同。 代码示例： 1234567891011121314151617181920212223242526272829303132public class Test&#123; public static void main(String[] args) &#123; person t = new person(); person stu = new person(99); //重载构造方法 t.say(); stu.say(40); //重载成员方法 &#125; &#125;class person&#123; public person() &#123; System.out.println(&quot;不带参数的构造方法被调用了&quot;); &#125; public person(int i) &#123; System.out.println(&quot;带参数&quot;+i+&quot;的构造方法被调用了&quot;); &#125; public void say() &#123; System.out.println(&quot;不带参数的成员方法被调用了&quot;); &#125; public void say(int i) &#123; System.out.println(&quot;带参数&quot;+i+&quot;的成员方法被调用了&quot;); &#125; &#125; 结果： 1234不带参数的构造方法被调用了带参数99的构造方法被调用了不带参数的成员方法被调用了带参数40的成员方法被调用了 注意：在用一个类中，不允许存在两个相同的方法，方法重载不是相同的方法，因为参数不同。 方法的递归调用 ​ 在c语言里，我们就多次接触并使用递归调用了，这里将不再详细描述递归调用，通过以下代码观察递归调用在java中是如何进行的： 1234567891011121314151617181920/*使用递归计算1+2+...+n的和*/public class Test&#123; public static void main(String[] args) &#123; int n = 4; int retValue = sum(n); System.out.println(retValue); &#125; public static int sum(int n) &#123; if(n == 1) &#123; return 1; &#125; return n + sum(n-1); &#125;&#125; 可变参数 ​ 我们知道，一个软件在运行时，接收到的参数不可能一成不变的，而是实时更新。而我们在编写程序时，也应考虑参数变化的情况。到JDK1.4为止，一直无法在Java程序里定义实参个数可变的方法——因为Java要求实参（Arguments）和形参（Parameters）的数量和类型都必须逐一匹配，而形参的数目是在定义方法时就已经固定下来了。尽管可以通过重载机制，为同一个方法提供带有不同数量的形参的版本，但是这仍然不能达到让实参数量任意变化的目的。 ​ 然而，有些方法的语义要求它们必须能接受个数可变的实参——例如著名的main方法(参考前面数组的深入使用)，就需要能接受所有的命令行参数为实参，而命令行参数的数目，事先根本无法确定下来。 ​ 对于这个问题，传统上一般是采用“利用一个数组来包裹要传递的实参”的做法来应付。 用数组包裹实参 ​ “用数组包裹实参”的做法可以分成三步：首先，为这个方法定义一个数组型的参数；然后在调用时，生成一个包含了所有要传递的实参的数组；最后，把这个数组作为一个实参传递过去。 ​ 这种做法可以有效的达到“让方法可以接受个数可变的参数”的目的，只是调用时的形式不够简单。 可变参数声明及规则 1234访问控制符 修饰符 返回值类型 方法名称(类型...参数名称)&#123; //例如public static void add(int...array) // 方法体&#125; 注意，上述声明中，“…”并不是省略号，而是定义参数类型的方式。 可变参数的使用规则如下： 1、一个方法中只能有一个可变参数 2、如果这个方法还有其他的形参，要把可变参数放到最后 可变参数的编译过程 ​ 虽然我们在方法上写的是“int…array”，但在编译时，编译器会偷偷把可变参数转化为一个数组形式： 12public static void add(int[] array)&#123;&#125; ​ 并且在编译出的class文件里标志一个记号，表明这是个可变参数的方法。真是由于存在着这样的转化，所以不能再为这个类定义一个和转化后的方法签名一致的方法。 错误代码演示： 1234public static void add(int...array)&#123;&#125;public static void add(int[] array)&#123;&#125; 调用实参个数可变的方法 ​ 只要把要传递的实参逐一写到相应的位置上，就可以调用一个实参个数可变的方法。不需要其它的步骤。如： 1add(1,4,22,8); 在背地里，编译器会把这种调用过程转化为用“数组包裹实参”的形式： 1add(new int[]&#123;1,4,22,8&#125;); 当然，也可以不传递参数，这样传递过去的就是一个空数组，而不是null，这样的好处是可以采取统一的形式来处理，省去检测处理步骤。 处理个数可变的实参 ​ 处理个数可变的实参的办法，和处理数组实参的办法基本相同。所有的实参，都被保存到一个和形参同名的数组里。根据实际的需要，把这个数组里的元素读出之后，要蒸要煮，就可以随意了。 代码示例： 123456789private static int add(int...array)&#123; int sum = 0; for (int i = 0; i &lt; array.length; i++) &#123; sum += array[i]; &#125; return sum;&#125; 转发个数可变的实参 ​ 有时候，在接收了一组个数可变的实参之后，还要把它们传递给另一个实参个数可变的方法。因为编码时无法知道接收来的这一组实参的数目，所以“把它们逐一写到该出现的位置上去”的做法并不可行。 ​ 其实，在JDk1.5的编译器眼中，实参个数可变的方法是最后带了一个数组形参的方法的特例。因此，可以先把一组要传递的实参放到一个数组里，然后然后把这个数组作为最后一个实参，传递给一个实参个数可变的方法，不会造成任何错误。借助这一特性，就可以顺利的完成转发了。 可变参数与数组参数的区别 ​ 尽管在背地里，编译器会把能匹配不确定个实参的形参，转化为数组形参；而且也可以用数组包裹实参，再传递给实参个数可变的方法；但是，这并不表示“能匹配不确定个实参的形参”和“数组形参”完全没有差异。 ​ 一个明显的差异是，如果按照调用实参个数可变的方法的形式，来调用一个最后一个形参是数组形参的方法，只会导致一个“can not be applied to”的编译错误。 错误代码演示： 12345678private static void print(int[] i)&#123; System.out.println(&quot;A&quot;);&#125;public static void main(String[] args)&#123; print(1, 2, 3);//编译出错&#125; ​ 由于这一原因，不能在调用只支持用数组包裹实参的方法的时候（例如在不是专门为JDK1.5设计第三方类库中遗留的那些），直接采用这种简明的调用方式。 ​ 如果不能修改原来的类，为要调用的方法增加参数个数可变的版本，而又想采用这种简明的调用方式，那么可以借助“引入外加函数”和“引入本地扩展”的重构手法来近似的达到目的。 更多内容请参考：Java中可变长度参数代码详解_java_脚本之家 (jb51.net) 参考连接： java方法重载示例_java_脚本之家 (jb51.net) Java方法递归调用实例解析_java_脚本之家 (jb51.net) Java中可变长度参数代码详解_java_脚本之家 (jb51.net) 浅谈Java中的可变参数_java_脚本之家 (jb51.net) Java数组传递及可变参数_爪哇菌的博客-CSDN博客_java可变参数传入数组 参考书目：《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"java中的数组","slug":"java/基本知识/java中的数组","date":"2021-07-16T05:34:49.000Z","updated":"2021-10-27T04:43:21.145Z","comments":true,"path":"2021/07/16/java/基本知识/java中的数组/","link":"","permalink":"https://silenthly.github.io/2021/07/16/java/%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/java%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84/","excerpt":"一维数组 ​ 在c语言基础上发展而来的java也同样具有数组特性，但在java中发生了不小的变化，需要重新认识数组，适应数组的变化。首先介绍的是一维数组。","text":"一维数组 ​ 在c语言基础上发展而来的java也同样具有数组特性，但在java中发生了不小的变化，需要重新认识数组，适应数组的变化。首先介绍的是一维数组。 数组的声明 格式一： 12数组类型 数组名[]=null;数组名 =new 数组类型[数组长度]; 格式二： 1数组类型 数组名[]=new 数组类型[数组长度]; ​ 其中，null关键字表示空，即没有指向任何内存空间，数组声明以后在内存中不占用空间，没有地址，默认值是null。在JDK1.5后，可以把“数组类型 数组名[]=null;”写成“数组类型 数组名[];”，或者写成“数组类型[] 数组名;”，可以根据自身习惯选择。 注意：数组是引用类型，数组名存储在栈内存，数组的元素就存储在堆内存。 数组的初始化 ​ 数组的初始化分为两种： 1、静态初始化 2、动态初始化 静态初始化 ​ 数组的静态初始化就是数组在定义的同时就为数组元素分配空间和赋值。 格式一： 1数组类型 数组名[]=&#123;元素值1，元素值2...元素值n&#125;; 格式二： 1数组类型 数组名[]=new 数组类型[]&#123;元素值1，元素值2...元素值n&#125;; 动态初始化 ​ 数组的动态初始化时只需指定数组长度，系统自动为数组元素赋初始值(默认值)，后续可根据需要为数组赋值。 格式： 1数组类型 数组名[]=new 数组类型[数组长度]; 注意：不可将金泰初始化和动态初始化同时使用，即不要在数组初始化时，指定了数组长度的同时为每一个数组元素赋值，如String stu[]=new String[3]{“我”,“叫”,“小明”};，编译会报错。 获取数组的长度 ​ 使用for输出数组所有的元素时，需要知道数组的元素个数。在java语言里，数组提供了length属性，通过这个属性可以得到数组的长度。 代码示例： 123456789public class Test&#123; public static void main(String[] args) &#123; String s[]=new String[]&#123;&quot;数组&quot;,&quot;长度&quot;,&quot;不用算&quot;&#125;; int len=s.length; System.out.println(&quot;数组有&quot;+len+&quot;个元素&quot;); &#125;&#125; 结果： 1数组有3个元素 foreach语句 ​ 从JDk1.5开始，java提供foreach语法，可以方便地遍历输出数组和集合。与for不同的是，使用foreach遍历数组和集合时，不需要知道数组的长度。 格式： 1234for(数据类型 变量名:数组名)&#123; //循环体&#125; ​ 其中，数据类型与数组的数据类型相同，变量名是形参名，foreach循环将数组或集合元素一次性地赋给该变量。 代码示例： 1234567891011public class Test&#123; public static void main(String[] args) &#123; String[] books = &#123;&quot;java&quot;,&quot;c&quot;,&quot;c++&quot;,&quot;c#&quot;,&quot;asp&quot;&#125;; for(String book : books) &#123; System.out.print(book+&quot; &quot;); &#125; &#125;&#125; 结果： 1java c c++ c# asp 注意：使用foreach语句循环时，不能通过循环变量来改变数组或集合元素的值。 代码示例： 123456789101112131415public class Test&#123; public static void main(String[] args) &#123; String[] books = &#123;&quot;java&quot;,&quot;c&quot;,&quot;c++&quot;,&quot;c#&quot;,&quot;asp&quot;&#125;; for(String book : books) &#123; book=&quot;PHP&quot;; &#125; for(int i=0;i&lt;books.length;i++) &#123; System.out.print(books[i]+&quot;、&quot;); &#125; &#125;&#125; 结果： 1java、c、c++、c#、asp、 多维数组 二维数组 ​ java没有传统意义上的多维数组，但java可以实现相应多维数组功能。二维数组是特殊的一维数组，它的每一个元素都是一维数组。 二维数组的声明 格式一： 1数据类型 数组名[][]; 格式二： 1数据类型[][] 数组名; 格式三： 1数据类型[] 数组名[]; 三种格式等价，不建议使用格式三，可读性不高。 二维数组初始化 ​ 同一维数组，也有两种形式。 二维数组的静态初始化 格式一： 1数组类型 数组名[][]=&#123;&#123;第0行元素&#125;，&#123;第1行元素&#125;...&#123;第n行元素&#125;&#125;; 格式二： 1数组类型 数组名[][]=new 数据类型&#123;&#123;第0行元素&#125;，&#123;第1行元素&#125;...&#123;第n行元素&#125;&#125;; 二维数组的动态初始化 声明二维数组行数与列数的格式： 格式一： 1数组类型 数组名[][]=new 数组类型[行数][列数]; 格式二： 12数组类型 数组名[][]=new 数组类型[行数][];数组名[n]=new 数据类型[列数]; //分别定义每一行的列数 为数组赋值格式： 格式一： 1数组名[row][col]=元素; 格式二： 1数组名[row]=new 数据类型[]&#123;元素...&#125;; 常见写法如上两种，更多格式可自行探索。 二维数组的遍历输出 这里使用foreach语句嵌套输出 1234567for(数据类型[] 变量名1:数组名)&#123; for(数据类型 变量名2:变量名1) &#123; System.out.println(); &#125;&#125; 注意：输出多维数组时，中括号必须放在数据类型后，否则输出的是对象地址或其他东西。 多维数组 ​ 想要增加维数，只需要在数组声明时所加一对中括号即可。如三维数组可以声明为：String s[][][]，依次类推更高维度。其循环遍历输出可参考二维数组的遍历输出。 数组的深入使用 命令行参数 ​ 在编写程序时，我们可以发现主方法“public static void main(String[] args)”中有一个String[] args参数，该参数是一个字符串数组。在java命令行后面带上参数，java虚拟机就直接把它存放到了main()方法中的参数String数组里。该字符串数组是用来保存运行main()函数时输入的参数，是main()方法接受用户输入的参数列表，称为命令行参数。 格式： 1java 类名 参数1 参数2...参数n ​ 各参数之间用空格隔开，可以有多个空格，但多余空格将被忽略；参数下标从0开始，args[0]白哦是第一个参数；各个参数通过args数组传递给main()方法。 代码示例： 12345678public class Test&#123; public static void main(String[] args) &#123; for(int i=0;i&lt;args.length;i++) System.out.print(&quot;第&quot;+(i+1)+&quot;个参数：&quot;+args[i]+&quot;\\t&quot;); &#125;&#125; 结果： 数组操作类：Arrays类 ​ Arrays类数组操作类，它定义在java.util包中，用来操作数组（如数组元素排序，搜索和填充等）的各种方法。Arrays类的常用方法如下表所示。 序号 方法 类型 描述 1 static int binaryScerch(int[] a,int key) 静态 使用二分搜索法，查询key元素是否在a数组中，若不存在则返回负数，调用此方前要求数组已升序，此方法可以被多次重载 2 static int[] copyOfRange(int[] original,int newLength) 静态 复制指定的数组，original表示源数组，newLength表示要复制的长度，默认从第一个元素开始赋值，此方法可被多次重载 3 static int[] copyOfRange(int[] original,int form,int to) 静态 复制指定数组到新的数组里，指定复制的范围，此方法可以被多次重载 4 static boolean equals(int[] a,int[] a2) 静态 比价两个数组是否相等，若相等则返回true，否则返回false。此方法可以被多次重载 5 static void fill(int[] a,int val) 静态 将指定int型数组的每个元素替换为val，此方法可以被多次重载 6 static void sort(int[] a) 静态 对指定的数组按升序进行排序，此方法可以被多次重载 7 static String toString(int[] a) 静态 返回指定数组内容的字符串表示形式，此方法可以被多次重载 ​ 下面以整形数组为例，演示Arrays类的常用方法。 代码示例：(在数组中查找指定元素) 1234567891011121314151617181920212223242526import java.util.Arrays;import java.util.Scanner;public class Test&#123; public static void main(String[] args) &#123; Scanner scan=new Scanner(System.in); System.out.println(&quot;请输入需要查找的数：&quot;); int search=scan.nextInt(); int arr[]=&#123;11,42,13,4,15,6,8,10,17,24&#125;; Arrays.sort(arr); for(int i=0;i&lt;arr.length;i++) &#123; System.out.print(arr[i]+&quot; &quot;); &#125; System.out.println(); int seaInt=Arrays.binarySearch(arr,search); if(seaInt&gt;=0) &#123; System.out.println(search+&quot;是数组arr的第&quot;+(seaInt+1)+&quot;位元素&quot;); &#125;else &#123; System.out.println(search+&quot;不是数组arrInt的元素&quot;); &#125; &#125;&#125; 运行结果： 1234请输入需要查找的数：174 6 8 10 11 13 15 17 24 4217是数组arr的第8位元素 注意：在使用 Arrarys 类中的 binarySearch()方法前，需要使用 Arrays.sort()方法对数组进行升序排序，否则返回的数值是不确定的。 复制数组 12345678910111213141516171819202122import java.util.Arrays;public class Test&#123; public static void main(String[] args) &#123; int arr[]=&#123;11,42,13,4,15,6,8,10,17,24&#125;; System.out.println(&quot;复制arr数组中的前4位元素&quot;); int copyArr[]=Arrays.copyOf(arr,4); for(int i=0;i&lt;copyArr.length;i++) &#123; System.out.print(copyArr[i]+&quot; &quot;); &#125; System.out.println(); System.out.println(&quot;复制arr数组中的第4位到第8元素&quot;); int copyRang[]=Arrays.copyOfRange(arr,4,8); for(int i=0;i&lt;copyRang.length;i++) &#123; System.out.print(copyRang[i]+&quot; &quot;); &#125; System.out.println(); &#125;&#125; 运行结果： 1234复制arr数组中的前4位元素11 42 13 4复制arr数组中的第4位到第8元素15 6 8 10 提示：数组的赋值除了使用 Arrays 类中的 copyOf()方法和 copyOfRange()方法以外，还可以使用 System 类的 arraycopy()方法和 Object 类的 clone()方法。 比较数组是否相等 123456789101112131415161718192021222324252627282930import java.util.Arrays;public class Test&#123; public static void main(String[] args) &#123; int arr[]=&#123;11,42,13,4,15,6,8,10,17,24&#125;; int arr1[]=&#123;11,42,13,4,15,6,8,10,17,24&#125;; int arr2[]=&#123;11,42,13,4,15,6,8,10,17,4&#125;; System.out.println(&quot;arr数组&quot;); for(int i=0;i&lt;arr.length;i++) &#123; System.out.print(arr[i]+&quot; &quot;); &#125; System.out.println(); System.out.println(&quot;arr1数组&quot;); for(int i=0;i&lt;arr1.length;i++) &#123; System.out.print(arr1[i]+&quot; &quot;); &#125; System.out.println(); System.out.println(&quot;arr2数组&quot;); for(int i=0;i&lt;arr2.length;i++) &#123; System.out.print(arr2[i]+&quot; &quot;); &#125; System.out.println(); System.out.println(&quot;比较arr和arr1是否相等：&quot;+Arrays.equals(arr,arr1)); System.out.println(&quot;比较arr和arr2是否相等：&quot;+Arrays.equals(arr,arr1)); &#125;&#125; 运行结果： 123456711 42 13 4 15 6 8 10 17 24arr1数组11 42 13 4 15 6 8 10 17 24arr2数组11 42 13 4 15 6 8 10 17 4比较arr和arr1是否相等：true比较arr和arr2是否相等：true 参考链接：foreach语句二维数组嵌套问题-黑马程序员技术交流社区 (itheima.com) 参考书目：《Java编程手记——从实践中学习Java（配光盘）》(欧二强 等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"代码块","slug":"java/基本知识/代码块","date":"2021-07-15T14:14:23.000Z","updated":"2021-10-27T04:50:18.664Z","comments":true,"path":"2021/07/15/java/基本知识/代码块/","link":"","permalink":"https://silenthly.github.io/2021/07/15/java/%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/%E4%BB%A3%E7%A0%81%E5%9D%97/","excerpt":"​ 在java中有四种代码块，分别是普通代码块、构造代码块、静态代码块和同步代码块。代码块就是指用“{}”括起来的代码，下面看一下前三种代码块，同步代码块在多线程讲解。","text":"​ 在java中有四种代码块，分别是普通代码块、构造代码块、静态代码块和同步代码块。代码块就是指用“{}”括起来的代码，下面看一下前三种代码块，同步代码块在多线程讲解。 普通代码块 就是指类中方法的方法体。 123public void xxx()&#123; //code &#125; 构造代码块 下面直接用“{}”括起来的代码片段，构造块在创建对象是会被调用，每次创建对象时都会被调用，并且优先于类构造函数(包括有参和无参的)执行。构造块中定义的变量是局部变量。 12345678910111213141516171819public class Test&#123; &#123;//构造代码块 System.out.println(&quot;代码块一，执行构造代码块&quot;); &#125; public Test() //空白构造函数 &#123; System.out.println(&quot;代码块二，执行无参构造函数&quot;); &#125; &#123;//构造代码块 System.out.println(&quot;代码块三，执行构造代码块&quot;); &#125; public static void main(String[] args) &#123; new Test(); &#125;&#125; 结果： 123代码块一，执行构造代码块代码块三，执行构造代码块代码块二，执行无参构造函数 静态代码块 下面用static&quot;{}&quot;括起来的代码片段，只会在第一次加载此类时，仅执行一次，并且静态块优先于构造块执行。 123456789101112131415161718192021222324public class Test&#123; &#123;//构造代码块 System.out.println(&quot;代码块一，执行构造代码块&quot;); &#125; public Test() //空白构造函数 &#123; System.out.println(&quot;代码块二，执行无参构造函数&quot;); &#125; static &#123; System.out.println(&quot;静态代码块&quot;); &#125; &#123;//构造代码块 System.out.println(&quot;代码块三，执行构造代码块&quot;); &#125; public static void main(String[] args) &#123; new Test(); &#125;&#125; 结果： 1234静态代码块代码块一，执行构造代码块代码块三，执行构造代码块代码块二，执行无参构造函数 总结： 优先运行是：静态代码块 &gt; 主方法 &gt; 构造代码块 &gt; 构造方法 &gt; 普通方法中的代码块","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"static修饰符","slug":"java/基本知识/static与main","date":"2021-07-14T15:35:53.000Z","updated":"2021-10-27T04:50:02.998Z","comments":true,"path":"2021/07/14/java/基本知识/static与main/","link":"","permalink":"https://silenthly.github.io/2021/07/14/java/%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/static%E4%B8%8Emain/","excerpt":"​ static表示“静态”“全局”的意思，可以用来修饰成员变量和成员方法，也可以生成静态代码块，但在JAVA里没有全局变量的概念。 ​ 被static修饰的成员变量和成员方法，独立于该类的任何对象。也就是说，它不依赖特定的是咧，被类的所有实例共享。 ​ 用public修饰的static成员变量和成员方法本质是全局变量和全局方法，当声明它的类时，不会生成一个static副本，而是类的所有实例共用听一个static变量。","text":"​ static表示“静态”“全局”的意思，可以用来修饰成员变量和成员方法，也可以生成静态代码块，但在JAVA里没有全局变量的概念。 ​ 被static修饰的成员变量和成员方法，独立于该类的任何对象。也就是说，它不依赖特定的是咧，被类的所有实例共享。 ​ 用public修饰的static成员变量和成员方法本质是全局变量和全局方法，当声明它的类时，不会生成一个static副本，而是类的所有实例共用听一个static变量。 static变量 ​ 按照是否静态对类成员变量进行分类可分成两种： 1）被static修饰的变量，叫静态变量或类变量 2）没被static修饰的变量，叫实例变量 区别： 1）JVM只为静态分配一次内存，在加载类的过程中完成静态变量的内存分配，可用类名直接访问。 2）对于实例变量，每创建一个实例，就会为实例变量分配一次内存，实例变量可以在内存中有多个拷贝，互不影响。 123456789101112131415161718192021222324252627public class StaticDemo01&#123; public static int ticket=10; //定义静态变量ticket public void sell() //定义sell方法 &#123; ticket--; System.out.println(&quot;剩余：&quot; + ticket); &#125; public static void left() //定义left方法 &#123; int i=ticket-2; System.out.println(&quot;还剩余：&quot; + i); &#125; public static void main(String[] args) &#123; int x=ticket--; //直接访问ticket System.out.println(&quot;x=&quot;+x+&quot;,ticket=&quot;+ticket); int y=StaticDemo01.ticket--; //通过类名访问ticket System.out.println(&quot;y=&quot;+y+&quot;,ticket=&quot;+ticket); StaticDemo01 p1=new StaticDemo01(); int k=p1.ticket--; //通过实例访问 System.out.println(&quot;k=&quot;+k+&quot;,ticket=&quot;+ticket); StaticDemo01 p2=new StaticDemo01(); p2.sell(); //通过非静态方法访问ticket left(); //通过静态方法访问ticket &#125;&#125; 结果： 12345x=10,ticket=9y=9,ticket=8k=8,ticket=7剩余：6还剩余：4 一般在需要实现以下两个功能时使用静态变量： 1）在对象之间共享值时 2）方便访问变量时 静态方法 ​ 静态方法也可以直接通过类名调用，任何的实例也都可以调用，因此静态方法中不能用this和super关键字，不能直接访问所属类的实例变量和实例方法，只能访问所属类的静态成员变量和成员方法。 static代码块 ​ static代码块也叫静态代码块，是在类中独属于类成员的static语句块，可以有多个，位置可以随便放，它不在任何的方法体内，JVM加载类是会执行这些静态的代码块，如果static代码块有多个，JVM将按照它们在类中出现的先后顺序，依次执行它们，每个代码块只会被执行一次。 12345678910111213141516171819202122232425262728293031public class Test5&#123; private static int a; private int b; static &#123; a=3; System.out.println(a); Test5 t=new Test5(); t.f(); t.b=1000; System.out.println(t.b); &#125; static &#123; Test5.a=4; System.out.println(a); &#125; public static void main(String[] args) &#123; // TODO 自动生成方法存根 &#125; static &#123; Test5.a=5; System.out.println(a); &#125; public void f() &#123; System.out.println(&quot;hhahhahah&quot;); &#125;&#125; 结果： 123453hhahhahah100045 程序入口main()方法 ​ 程序在运行的时候，第一个执行的方法就是main()方法。通常情况下， 如果要运行一个类的方法，必须首先实例化出来这个类的一个对象，然后通过&quot;对象名.方法名()&quot;的方式来运行方法，但是因为main是程序的入口，这时候还没有实例化对象，因此将main方法声明为static的，这样这个方法就可以直接通过“类名.方法名() ”的方式来调用。简单来说，在main函数中调用函数只能调用静态的。如果要调用非静态的，那么必须要先实例化对象，然后通过对象来调用非静态方法。 12345678/** * Java中的main()方法详解 */ public class HelloWorld &#123; public static void main(String args[]) &#123; System.out.println(&quot;Hello World!&quot;); &#125; &#125; 对于类 ​ HelloWorld 类中有main()方法，说明这是个java应用程序，通过JVM直接启动运行的程序。 既然是类，java允许类不加public关键字约束，当然类的定义只能限制为public或者无限制关键字（默认的）。 对于main方法 ​ 这个main()方法的声明为：public static void main(String args[]) 。必须这么定义，这是Java的规范。 ​ 为什么要这么定义，和JVM的运行有关系。 ​ 当一个类中有main()方法，执行命令“java 类名”则会启动虚拟机执行该类中的main方法。 ​ 由于JVM在运行这个Java应用程序的时候，首先会调用main方法，调用时不实例化这个类的对象，而是通过类名直接调用因此需要是限制为public static。 对于java中的main方法，jvm有限制，不能有返回值，因此返回值类型为void。 ​ main方法中还有一个输入参数，类型为String[]，这个也是java的规范，main()方法中必须有一个入参，类细必须String[]，至于字符串数组的名字，这个是可以自己设定的，根据习惯，这个字符串数组的名字一般和sun java规范范例中mian参数名保持一致，取名为args。 因此，main()方法定义必须是：“public static void main(String 字符串数组参数名[]) ”。 原文链接：详细讲解Java中的main()方法_java_脚本之家 (jb51.net)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"变量的作用域","slug":"java/基本知识/变量与对象的作用域","date":"2021-07-13T12:54:54.000Z","updated":"2021-10-27T04:50:09.659Z","comments":true,"path":"2021/07/13/java/基本知识/变量与对象的作用域/","link":"","permalink":"https://silenthly.github.io/2021/07/13/java/%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/%E5%8F%98%E9%87%8F%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/","excerpt":"作用域 ​ java用一对大括号作为语句块的范围，称为作用域，在作用域里定义的变量，只有在作用域的范围内能使用。","text":"作用域 ​ java用一对大括号作为语句块的范围，称为作用域，在作用域里定义的变量，只有在作用域的范围内能使用。 我们来看这两段代码： 12345678public class Test1&#123; public static void main(String[] args) &#123; String name=&quot;angle&quot;; String name=&quot;demon&quot;; &#125;&#125; 123456789101112public class Test2&#123; public static void main(String[] args) &#123; &#123; String name=&quot;angle&quot;; System.out.println(name); &#125; String name=&quot;我可能是个假人&quot;; System.out.println(name); &#125;&#125; 编译运行发现，Test1编译错误，Test2出现以下结果： 12angle我可能是个假人 如果交换Test2的变量位置， 123456789101112public class Test3&#123; public static void main(String[] args) &#123; String name=&quot;我可能是个假人&quot;; System.out.println(name); &#123; String name=&quot;angle&quot;; System.out.println(name); &#125; &#125;&#125; 编译错误。 原因是，离开作用域，变量所分配的内存空间将被JVM回收，所以语法不会有错误，而第二种写法name并没有离开{}作用域，所以会语法错误。第一种写法错误在于同一个作用域存在同名变量，第三种写法错误在于第一个name并没有离开其作用域而没被回收，下面却又申请了一个名为name的同名变量，出现错误。 上述的变量都是局部变量，那么如果是在有全局变量的情况下又是怎样一种结果呢？ 123456789101112131415161718192021222324public class Test&#123; String name=&quot;angle&quot;; String num=&quot;10086&quot;; public static void main(String[] args) &#123; &#123; String name=&quot;我可能真的是一个假人&quot;; System.out.println(name); &#125; String name=&quot;我不是假人，是真的&quot;; System.out.println(name); for(int i=0;i&lt;1;i++) &#123; System.out.println(i); &#125; int i=3; System.out.println(i); String num=&quot;该程序有100个错误&quot;; System.out.println(num); &#125;&#125; 结果： 12345我可能真的是一个假人我不是假人，是真的03该程序有100个错误 观察总结如下： 1、是否能同名 1）同一个作用域范围下的全局变量和局部变量是可以同名的 2）同一个作用域范围下的局部变量不可以同名 2、使用哪个变量 1）若没有明确使用哪个变量，默认使用局部变量 2）如果局部变量超出了它本身的作用域范围则会失效，被JVM垃圾回收，那么则可以重复命名此变量，并使用最新定义的这个局部变量。 对象的作用域 java对象不具备与主类型一样的存在时间。用new关键字创建一个Java对象的时候，它会超出作用域的范围之外。 若使用以下代码： 123&#123; String s=new String(&quot;Hello world&quot;);&#125;/* 作用域的终点 */ 那么句柄s，也就是引用会在作用域的终点处消失。然而，s指向的String对象依然占据着内存空间。在上面这段代码里，我们没有办法继续使用这个对象，因为指向它的唯一一个句柄已经超出了作用域的边界。 这样造成的结果是：对于用new创建的对象，只要我们愿意，它们就会一直保留下去。这个编程问题在C和C++里特别突出，我们必须将对象手动清除。但 在Java中，情况却发生了改观。 Java 有一个特别的“垃圾收集器”，它会查找用 new 创建的所有对象，并辨别其中哪些不再被引用。随后，它会自动释放由那些闲置对象占据的内存，以便能由新对象使用。这意味着我们根本不必操心内存的回收问题。只需简单地创建对象，一旦不再需要它们，它们就会自动离去。 下面列举局部变量与成员变量的区别： 1）定义的位置不一样 局部变量：定义在方法内部 成员变量：在方法内部，直接写在类当中 2）作用范围不一样 局部变量：只作用在方法中 成员变量：整个类全都可以通用 3）默认值不一样 局部变量：没有默认值，必须手动赋值 成员变量：如果没有赋值，会有默认值，规则和数组一样 4）内存中的位置不一样 局部变量：位于栈内存 成员变量：位于堆内存 5）生命周期不一样 局部变量：随着方法的进栈而诞生，随着方法的出栈而消失 成员变量：随着对象的创建而诞生，随着对象被垃圾回收而消失 所以在成员变量与局部变量同名的情况下，优先使用局部变量，减短生命周期，减少系统开销。 参考链接： Java变量和对象的作用域_java_脚本之家 (jb51.net) https://blog.csdn.net/Delicious_Life/article/details/104657719","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"类与对象","slug":"java/基本知识/类与对象","date":"2021-07-11T06:52:45.000Z","updated":"2021-10-27T04:50:50.641Z","comments":true,"path":"2021/07/11/java/基本知识/类与对象/","link":"","permalink":"https://silenthly.github.io/2021/07/11/java/%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/","excerpt":"类的定义格式 12345678910[修饰词] class 类名 [extends父类名] [implements接口名]&#123; //类体包括成员变量和成员方法，如： String name; //成员变量 int age; //成员变量 public void say() //成员方法，类似c的函数 &#123; System.out.println(&quot;小明今年3岁了！&quot;); &#125;&#125;","text":"类的定义格式 12345678910[修饰词] class 类名 [extends父类名] [implements接口名]&#123; //类体包括成员变量和成员方法，如： String name; //成员变量 int age; //成员变量 public void say() //成员方法，类似c的函数 &#123; System.out.println(&quot;小明今年3岁了！&quot;); &#125;&#125; 对象的创建 两种格式： 1234567//格式一：类名 对象名称=new 类名();person p=new person();//格式二：类名 对象名称=null;// 对象名称=new 类名();person p=null;p=new person(); 两种格式其实是一致的，格式一是格式二的合并，格式二最能反映创建对象的实质：对象的创建真正的存储空间并不在栈内存中，而是在堆内存中。原因是：new函数是在堆内存中开辟空间，而方法开辟的空间在栈内存中，所以对象的创建就是在堆内存中开辟对象的存储空间，然后在栈内存创建一个变量p，用于存储对象在堆内存中的地址，这样就可以通过变量p来访问对象的内容。 注意：在方法中申请的空间都是在栈内存中的。 关于类的定义 在java中声明一个类的方式有两种 即:public class 类名称 和 class 类名称。 (1)使用public class 声明一个类时，类名称必须和文件名一致，否则程序将无法编译。 (2)使用class声明一个类时，类名称可以和文件名不一致，但是在执行时一定要执行生成后的.class文件。 (3)在一个java文件中可以有多个class类的定义，但是只能有一个public class定义。 (4)在定义类名称时，类的名称首字母必须要大写。这是命名规则。 类的定义类似c语言的结构体变量，类的成员变量相当于结构体的成员，类的成员方法相当与c的函数，注意成员方法必须写在类里。 123456789101112131415161718192021222324252627class Person&#123; //定义类 private String name; //用private隐藏对象属性,将不可通过访问修改对象 private int age; public void setName(String name)&#123; this.name=name; &#125; public void setAge(int age)&#123; this.age=age; &#125; public String getName()&#123; return name; &#125; public int getAge()&#123; return age; &#125; public void say() &#123;System.out.println(&quot;我叫&quot;+getName()+&quot;今年&quot;+getAge()+&quot;岁了&quot;);&#125;&#125;public class classname&#123; public static void main(String[] args)&#123; Person p1=null; //声明对象p1，在栈内存开辟空间。p1变量本身存储的只是一个地址值，没有存储任何实际数据，但它指向了Preson对象。所以访问p1对象的属性和方法时，实际上是访问p1所引用对象的属性和方法。 p1=new Person(); //实例化p1，在堆内存保存对象p1属性的内容 Person p2=new Person(); Person p3=p2; //p2和p3实际引用同一个对象，修改p3对象的属性，p2对象的属性也会更改 p1.say(); //调用say() &#125;&#125; JAVA所有的除定义或声明语句之外的任何语句都必须在方法内部(而方法又必须在某个类内部,不存在游离于类外部的方法或成员） 成员隐藏与属性封装（为修改对象属性加个门槛） 把数据私有化，代码中使用了private关键字对属性定义进行了修饰。这样，直接通过一个对象的属性访问时无法对属性进行获取或者修改的，而是通过方法的调用来实现。通过这种方式，对象所拥有的数据表现为一种私有状态。 this关键字的用法 ​ this关键字比较复杂，这里将简单介绍this在简略应用，更多内容可看后续更新。 在一个类的方法或者构造方法内部，当成员变量被局部变量隐藏时，想使用成员变量的话，可以使用this.成员变量名这样的格式来引用成员变量名。 1234567891011121314151617181920212223242526272829303132class Person&#123; private String name; private int age; public Person()&#123;&#125; public Person(String name,int age) &#123; this.name=name; this.age=age; &#125; public String getName() &#123; return name; &#125; public int getAge() &#123; return age; &#125; public void say() &#123; System.out.println(&quot;我叫&quot;+getName()+&quot;今年&quot;+getAge()+&quot;岁了&quot;); &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; Person p=new Person(&quot;小明&quot;,18); p.say(); &#125;&#125;/*输出结果：我叫小明今年18岁了*/ 匿名对象 ​ 匿名对象是指没有名字的对象。实际上，对于对象实例化操作来讲，对象真正有用的部分是在堆内存中，而栈内存中只是保存了一个对象的引用名称（严格来讲是对象在堆内存的地址），所谓匿名对象是指，只开辟了堆内存空间，而没有栈内存指向的对象。 1234567891011public class Name&#123; public void say() &#123; System.out.println(&quot;匿名对象只是开辟了堆内存空间，没有栈内存指向的对象！&quot;); &#125; public static void main(String[] args) &#123; new Name().say(); &#125;&#125; 1 匿名对象没有被其他对象所引用，即没有栈内存指向。 2 因为匿名对象没有栈内存指向，所以只能使用一次，之后就变成无法寻找的垃圾对象，会被垃圾回收器回收。 构造函数 ​ 如果在类中我们不声明构造函数，JVM会帮我们默认生成一个空参数的构造函数；**如果在类中我们声明了带参数列表的构造函数，JVM就不会帮我们默认生成一个空参数的构造函数，**我们想要使用空参数的构造函数就必须自己去显式的声明一个空参的构造函数。 1、构造函数与普通函数的区别 1） 格式不同： 构造函数不存在返回类型，函数名与所在类的类名一致； 普通函数有返回类型，函数名可以根据需求进行命名。 2）调用时期不同 构造函数在类的对象创建时就运行； 普通函数在对象调用时才会执行。 3）执行次数不同 一个对象创建后，其构造函数只执行一次，就是创建时执行； 一个对象创建后，其普通函数可以执行多次，取决于对象的调用次数。 4）构造函数没有返回值 2、构造方法可以重载，也就是说，可以在一个类中创建多个同名但参数不同的构造方法 例如： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Person&#123; private String name; private int age; public Person(String name) &#123; this.name=name; &#125; public Person(String name,int age) &#123; this.name=name; this.age=age; &#125; public void setName(String name) &#123; this.name=name; &#125; public void setAge(int age) &#123; this.age=age; &#125; public String getName() &#123; return name; &#125; public int getAge() &#123; return age; &#125; public void say() &#123; System.out.println(&quot;今年&quot; + getName() + getAge() +&quot;岁了！&quot;); &#125;&#125;public class name&#123; public static void main(String[] args) &#123; Person p1=null; p1=new Person(&quot;小明&quot;,19); p1.say(); Person p2=new Person(&quot;小红&quot;); p2.setAge(19); p2.say(); &#125;&#125; 参考链接： Java中的匿名对象定义与用法实例分析_java_脚本之家 (jb51.net) https://blog.csdn.net/weixin_28684757/article/details/114228746 Java之路：this关键字的用法_星云999的博客-CSDN博客_this关键字的用法 Java面向对象之成员隐藏与属性封装操作示例_java_脚本之家 (jb51.net) Java编程中的构造函数详细介绍_java_脚本之家 (jb51.net)","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"win10配置java环境变量","slug":"java/基本知识/win10配置java环境变量","date":"2021-07-10T11:58:34.000Z","updated":"2021-10-27T04:51:19.908Z","comments":true,"path":"2021/07/10/java/基本知识/win10配置java环境变量/","link":"","permalink":"https://silenthly.github.io/2021/07/10/java/%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/win10%E9%85%8D%E7%BD%AEjava%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/","excerpt":"1、打开环境变量配置 此电脑——右键——属性——高级系统设置——环境变量","text":"1、打开环境变量配置 此电脑——右键——属性——高级系统设置——环境变量 图1 2、点击环境变量，进行配置 （1）首先新建JAVA_HOME变量，变量名为：JAVA_HOME，变量值为：java的安装路径，此处我的安装路径为：D:\\Software\\JAVAJDK，图示如下 图2 图3 （2）编辑path变量，双击path开头的系统变量，进入编辑界面，然后点新建，输入 %JAVA_HOME%\\bin。 图4 图5 （3）创建classpath变量，点击新建，变量名为：classpath，变量值为：.;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\tools.jar，必须输入准确，否则后面将会出现创建了class文件，却提示找不到或无法加载主类。 图7 图8 3、创建完毕后，然后点击所有对话框的确认，保存设置，然后打开cmd命令行窗口，分别输入java和javac，若出现图示文字，则配置成功。 图9 图10 jdk-8u231-windows-x64安装包下载（有效时长为30天，若文件过期可联系博主） 链接：https://pan.baidu.com/s/1byUioC5kh0uZ-vPtQ3Pp9Q 提取码：0xgq 4、配置完后，写一个简单的java程序来测试环境变量是否配置正确 （1）新建一个文本，把以下内容复制过去 代码如下： 1234567public class hello&#123; public static void main(String[] agrs) &#123; System.out.println(&quot;你好，JAva&quot;); &#125;&#125; （2）选择文件另存为，文件名为：hello.java，文件类型为：所有文件 图11 然后把文件保存在一个文件夹里，这里我保存在D:\\myjava （3）使用cmd命令行窗口，在cmd中打开java文件保存的文件夹，依次输入javac hello.java和java hello，若环境变量和代码无误，输出如下： 图11 命令解释： ”d:“ 打开D盘 “cd 文件夹名” 打开文件夹 若出现以下信息，则说明classpath环境变量没有配置好，严格按照2、（3）步骤执行 图12 5、经过以上步骤，你会发现还有一个问题，就是执行以上代码时，无法输出中文，出现如图所示情况： 图13 这个问题很简单，属于文件编码问题。由于JDK是国际版的，在编译的时候，如果没有用-encoding参数指定JAVA源程序的编码格式，则javac.exe首先获得操作系统默认采用的编码格式，也即在编译java程序时，若不指定源程序文件的编码格式，JDK首先获得操作系统的file.encoding参数(它保存的就是操作系统默认的编码格式，如WIN2k，它的值为GBK)，然后JDK就把我们的java源程序从file.encoding编码格式转化为JAVA内部默认的UNICODE格式放入内存中。 在UTF-8里，英文字符仍然跟ASCII编码一样，因此原先的函数库可以继续使用。而中文的编码范围是在0080-07FF之间，因此是2个字节表示（但这两个字节和GB编码的两个字节是不同的），用专门的Unicode处理类可以对UTF编码进行处理。 解决方法： 1.用记事本将代码保存为ANSI格式在编译。 图14 2.在编译输出中文或者有关于中文的java文件时在cmd中输入: javac -encoding UTF-8 “java文件名”.java 图15 参考链接： win10安装JDK1.8及配置java环境变量详解_小怪兽的博客-CSDN博客_win10安装jdk1.8 Win 10 配置Java环境变量_荆棘云海的博客-CSDN博客_win10配置java环境变量 Win10下 Java环境变量配置_木头分享-CSDN博客_java环境变量配置 自学Java第二天 解决java不能输出中文问题_java自学的路程与困惑-CSDN博客 cmd命令行下运行Java程序，无法识别中文_yong_zi的博客-CSDN博客_java在cmd运行不能输入中文 2021/7/10","categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"}],"tags":[{"name":"杂项","slug":"杂项","permalink":"https://silenthly.github.io/tags/%E6%9D%82%E9%A1%B9/"}]},{"title":"插入排序","slug":"c/插入排序","date":"2021-06-25T16:12:34.000Z","updated":"2021-10-27T05:05:17.126Z","comments":true,"path":"2021/06/26/c/插入排序/","link":"","permalink":"https://silenthly.github.io/2021/06/26/c/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/","excerpt":"定义及记录表的创建与输出","text":"定义及记录表的创建与输出 123456789101112131415161718192021222324252627282930313233343536#include&lt;stdio.h&gt;#define MAX 20typedef int ElemType;typedef struct&#123; ElemType r[MAX+1]; int length;&#125;sortlist;void crelist(sortlist *L) //创建排序记录表&#123; int i=0; ElemType x; printf(&quot;请输入数据：\\n&quot;); scanf(&quot;%d&quot;,&amp;x); while(x!=-1) //输入-1停止输入 &#123; if(i&gt;MAX) &#123; i--; break; &#125; L-&gt;r[++i]=x; scanf(&quot;%d&quot;,&amp;x); &#125; L-&gt;length=i;&#125;void list(sortlist *L) //输出排序记录表&#123; int i; for(i=1;i&lt;L-&gt;length;i++) printf(&quot;%4d&quot;,i); printf(&quot;\\n&quot;); for(i=1;i&lt;L-&gt;length;i++) printf(&quot;%4d&quot;,L-&gt;r[i]); printf(&quot;\\n&quot;);&#125; 1、直接插入法 ​ 直接插入排序是一种最简单的排序方法，它的基操作是将一个记录插入到已排好序的有序表中，从而获得一个新的、记录数加1的有序表。 ​ 在实现算法的过程，先将待排序记录r[i]存入到r[0]单元，作为监视哨，随后用r[i]的关键字与前i-1个记录的关键字进行比较，找到合适位置后，将该位置到i-1的记录全体后移，把r[i]存入空的位置。 代码如下： 123456789101112void InsertSort(sortlist *L)&#123; int i,j; for(i=2;i&lt;=L-&gt;length;i++) //排序趟数 if(L-&gt;r[i]&lt;L-&gt;r[i-1]) //待插入记录的关键字比已排序的最大记录的关键字小 &#123; L-&gt;r[0]=L-&gt;r[i]; //将待插入记录放进监视哨 for(j=L-&gt;i-1;L-&gt;r[j]&gt;L-&gt;r[0];j--) //比待插入记录关键字大的记录后移 L-&gt;r[j+1]=L-&gt;r[j]; L-&gt;r[j+1]=L-&gt;r[0]; //将待插入记录r[i]插入到j+1位置 &#125;&#125; 时间复杂度为O(n2)，空间复杂度为O(1) 2、折半插入法 ​ 直接插入排序在查找待插入位置时适用的是顺序查找，而折半查找的性能比顺序查找的性能好很多，所以可以使用折半查找法查找待插入位置。 代码如下： 123456789101112131415161718192021void BinsertSort(sortlist *L)&#123; int i,j,low,hight,mid; for(i=2;i&lt;L-&gt;length;i++) //排序趟数 &#123; L-&gt;r[0]=L-&gt;r[i]; low=1; hight=i-1; while(low&lt;=hight) //折半查找寻找合适的位置 &#123; mid=(low+hight)/2; if(L-&gt;r[0]&lt;L-&gt;r[mid]) hight=mid-1; else low=mid+1; &#125; for(j=i-1;j&gt;=hight+1;j--) //比待插入记录关键字大的记录后移 L-&gt;r[j+1]=L-&gt;r[j]; L-&gt;r[j+1]=L-&gt;r[0]; //将待插入记录r[i]插入到j+1位置 &#125;&#125; 时间复杂度为O(n2)，空间复杂度为O(1) 3、2路插入排序 ​ 2路插入排序是对折半插入排序算法的一种改进，减少了排序过程中记录的移动次数。但当L-&gt;r[1]的关键字为最大或最小时，完全失去优越性。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849void TwoInsertSort(sortlist *L)&#123; int i,j,low,hight,final,frist,mid; ElemType *p; p=(ElmeType *)malloc(sizeof(ElmeType)*(L-&gt;lenght+1)); //临时数组d记录排序后的序列 first=L-&gt;leght+1; final=1; d[1]=L-&gt;r[1]; for(i=2;i&lt;L-&gt;length;i++) //排序趟数 if(L-&gt;r[i]&lt;d[1]) ////以第一个记录做比较，划分两路 &#123; low=1; hight=final; //在数组d左路进行折半查找插入位置 while(low&gt;=hight) &#123; mid=(low+hight)/2; if(L-&gt;r[i]&gt;d[mid]) low=mid+1; else hight=mid-1; &#125; for(j=final;j&gt;=low;j--) //插入位置及其后的记录右移 d[j+1]=d[j]; d[low]=L-&gt;r[i]; //插入到指定位置 final++; //左路末尾指针移动 &#125; else &#123; low=first; hight=L-&gt;lenght; //在数组d右路进行折半查找插入位置 while(low&lt;=hight) &#123; mid=(low+hight)/2; if(L-&gt;r[i]&gt;d[mid]) low=mid+1; else hight=mid-1; &#125; for(j=first;j&lt;=hight;j++) //插入位置及其后的记录左移 d[j-1]=d[j]; d[hight]=L-&gt;r[j]; //插入到指定位置 first--; //左路末尾指针移动 &#125; i=1; //将数组中的两路按顺序存回L for(j=1;j&lt;final;j++) L-&gt;r[i++]=d[j]; for(j=first;j&lt;L-&gt;length;j++) L-&gt;r[i++]=d[j];&#125; 时间复杂度为O(n2)，空间复杂度为O(n) 4、表插入排序 5、希尔排序（缩小增量排序） ​ 希尔排序利用直接插入排序优点对待排序序列先作“宏观“调整，再作”微观“调整。 ​ 将序列按下标的一定增量分成若干个子序列，对每个子序列分别进行直接插入排序。然后再将增量缩小，划分子序列，分别进行插入排序，重复进行此过程以实现排序。 代码如下： 12345678910111213void ShellInsort(sortlist *L,int *d,int t) //d为存放t个增量的数组&#123; int i,j,k; for(k=0;k&lt;t;k++) //增量数 for(i=d[k]+1;i&lt;=L-&gt;length;i++) //对下标增量d[k]后的每一个元素进行比较 if(L-&gt;r[i]&lt;L-&gt;r[i-d[k]]) &#123; L-&gt;r[0]=L-&gt;r[i]; //放入监视哨 for(j=i-d[k];j&gt;0&amp;&amp;L-&gt;r[0]&lt;L-&gt;r[j];j-=d[k]) //后移 L-&gt;r[j+d[k]]=L-&gt;r[j]; L-&gt;r[j+d[k]]=L-&gt;r[0]; //把元素插入到适合的位置 &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://silenthly.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://silenthly.github.io/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"动态规划——四步走","slug":"c/动态规划","date":"2021-06-25T16:11:12.000Z","updated":"2021-10-27T05:05:33.620Z","comments":true,"path":"2021/06/26/c/动态规划/","link":"","permalink":"https://silenthly.github.io/2021/06/26/c/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","excerpt":"一、确定状态 确定状态需要两个意识 （1）最后一步 （2）子问题 例题：","text":"一、确定状态 确定状态需要两个意识 （1）最后一步 （2）子问题 例题： 最后一步 虽然我们不知道最优策略是什么，但是最优策略肯定是k枚硬币a1，a2…ak面值加起来是27 所以一定有一枚最后的硬币：ak 除掉这枚硬币，前面硬币的面值加起来是：27-ak 子问题 除去最后一枚硬币，剩下的问题是：最少用多少枚硬币可以并成27-ak，这个问题是原问题的一个子问题，规模更小，由此可以依次得出其他子问题。 为了简化定义，设状态f(x)=最少用多少枚硬币拼出x 最后那枚硬币ak可能是2,5,或者7 若ak=2，则f(27)=f(27-2)+1 //f(27-2)所需的硬币数+最后一枚硬币 若ak=5，则f(27)=f(27-5)+1 //f(27-5)所需的硬币数+最后一枚硬币 若ak=7，则f(27)=f(27-7)+1 //f(27-7)所需的硬币数+最后一枚硬币 所以：f(27)=min{f(27-2)+1,f(27-5)+1,f(27-7)+1} 如图，使用递归算法从上到下，虽然很简洁，但在递归过程中产生了一些重复的步骤，例如图中红色部分，那么该如何避免重复计算导致的效率低下？ 答：将计算结果保存下来，并改变计算顺序。 二、 转移方程 设状态f(x)=最少用多少枚硬币拼出x 对于任意x，有 f(x)=min{f(x-2)+1,f(x-5)+1,f(x-7)+1} 三、初始条件和边界情况 两个问题(边界情况) x-2，x-5或者x-7小于0怎么办？什么时候停下来？ 如果不能拼出X0，就定义f(X0)=正无穷，例如f(-1)=正无穷 初始条件：f(0)=0 四、计算顺序 一般从小到大开始计算，例如： 先计算初始条件：f(0)=0 然后计算f(1)，f(2)…f(27) 由此，当我们计算到f(x)时，f(x-2)，f(x-5)，f(x-7)都已经得到结果了（从下到上，区别与递归的从上到下） 由已知，x小于0的部分不能拼出，故其值为正无穷，由状态转移方程**f(x)=min{f(x-2)+1,f(x-5)+1,f(x-7)+1}**得f(1)的值为正无穷。 ​ 图4-1 ​ 图4-2 ​ 图4-3 依次类推，最后得出f(27)的值为5 每一步尝试三种硬币，一共27步，与递归算法相比，没有重复计算，所以算法时间复杂度(即需要进行的步数)O(n)=27*3； 常见题型","categories":[{"name":"acm","slug":"acm","permalink":"https://silenthly.github.io/categories/acm/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://silenthly.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"背包问题","slug":"c/背包问题","date":"2021-06-25T15:20:34.000Z","updated":"2021-10-27T05:05:05.056Z","comments":true,"path":"2021/06/25/c/背包问题/","link":"","permalink":"https://silenthly.github.io/2021/06/25/c/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","excerpt":"​ 贪心规则：每次放入的物品必须满足单位重量价值最高，即vi/wi最大。 example:","text":"​ 贪心规则：每次放入的物品必须满足单位重量价值最高，即vi/wi最大。 example: first:计算单位重量价值： ​ second:放物品，按照单位重量价值来说6&gt;5&gt;4,因此放入顺序为w1，w2，w3。，其中w1，w2完全放入，w3放入三分之二。 一、背包问题 ​ 问题描述：有一个背包容量为M，一堆物品其重量表示为W={w1.w2…wn}，物体相应的价值V={v1,v2…vn}，现在要求将物品中的一部分或全部，放入背包。 ​ 要求：放入物品的总价值最高；同时满足装入物品总重量不超过M。 归纳： 一、如果装不下当前物品，那么前n个物品的最佳组合和前n-1个物品的最佳组合是一样的。 二、如果装得下当前物品。 ​ 假设1：装当前物品，在给当前物品预留了相应空间的情况下，前n-1个物品的最佳组合加上当前物品的价值就是总价值，即V(i,j)=V(i-1,j)； ​ 假设2：还有足够的容量可以装该商品，但装了也不一定达到当前最优价值，所以在装与不装之间选择最优的一个，即V(i,j)=max{V(i-1,j),V(i-1,j-Wi)+Vi)} ​ 其中V(i-1,j)表示不装，V(i-1,j-Wi)+Vi)表示装了第i个商品，背包容量减少Wi，但价值增加了Vi。 故递推关系式： （1）j&lt;Wi V(i,j)=V(i-1,j) （2）j&gt;=Wi V(i,j)=max{V(i-1,j),V(i-1,j-Wi)+Vi)} 代码如下： 123456789101112131415void FineMax()&#123; int i,j; for(i=1;i&lt;number;i++) for(j=1;j&lt;capacity;j++) &#123; if(j&lt;w[i]) v[i][j]=v[i-1][j]; else if(v[i-1][j]&gt;v[i-1][j-w[i]]+v[i]) v[i][j]=v[i-1][j]; else v[i][j]=v[i-1][j-w[i]]+v[i]; &#125;&#125; 二、背包问题回溯 ​ 问题进阶：在使得背包内总价值最大的情况下，背包内装了哪些物品？ 对递推公式观察发现，第i层的最优解是由第i-1层决定的，所以，可以通过比较v[i][j]的值与v[i-1][j]的值来判断是否放进了序号为i的物品。 代码如下： 12345678910111213void FineWhat(int i,int j)&#123; if(v[i][j]==v[i-1][j]) &#123; item[i]=0; //没有装进第i个物品 FineWhat(i-1,j); &#125; if(j-w[i]&gt;=0&amp;&amp;v[i][j]==v[i-1][j-w[i-1]]+v[i]) &#123; item[i]=1; FineWhat(i-1.j-w[i]); &#125;&#125; 三、空间优化 ​ 可以前面可以看出，每一次v[i][j]值的改变，只与v[i-1][j]有关，即与前一次循环保存下来的值有关，在此用一个一维数组B[j]保存前一次循环保存下来的值，通过保存下来的值求得该次循环的最优解，然后把原来的值覆盖掉，对整个数组操作完后，B[j]中保存的值，即为该次循环的最优解。 由**（1）ji V(i,j)=V(i-1,j)** ​ （2）j&gt;=Wi V(i,j)=max{V(i-1,j),V(i-1,j-Wi)+Vi)} 可得一维数组的状态转移方程为j&gt;=w[i]时，B[j]=max{B[j],B[i-w[i]]+v[i]}。 ​ 需要注意的是，在状态转移方程中，每一次推导v[i][j]都是通过v[i-1][j-w[i]]来推导的，即会用到j之前的值{1到j-1}，所以一维数组的扫描顺序应该是从末到首(capacity到0)，否则前一次循环保留下来的值将会被修改，从而造成错误。 12345678910void FineMax()&#123; int i,j; for(i=1;i&lt;=number;i++) for(j=capacity;j&gt;=0;j--) &#123; if(j&gt;=w[i]&amp;&amp;B[j]&lt;B[j-w[i]]+v[i]) B[j]=B[j-w[i]]+v[i]; &#125;&#125; ​ 注意：优化后的一维数组，只能保存当前循环的最优解，前面已有的解被覆盖，故优化后无法通过回溯寻找最优解的组成。","categories":[{"name":"acm","slug":"acm","permalink":"https://silenthly.github.io/categories/acm/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://silenthly.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"贪心算法","slug":"贪心算法","permalink":"https://silenthly.github.io/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"}]},{"title":"动态规划初探","slug":"c/动态规划初探","date":"2021-06-25T15:15:52.000Z","updated":"2021-10-27T05:05:45.998Z","comments":true,"path":"2021/06/25/c/动态规划初探/","link":"","permalink":"https://silenthly.github.io/2021/06/25/c/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%88%9D%E6%8E%A2/","excerpt":"一、坐标型动态规划 坐标型动态规划：给定一个序列或网格，需要找到序列或网格中某条路径，坐标与数组下标一一对应 例一：不同路径II(unique path II)","text":"一、坐标型动态规划 坐标型动态规划：给定一个序列或网格，需要找到序列或网格中某条路径，坐标与数组下标一一对应 例一：不同路径II(unique path II) 题目分析： 与不同路径I非常类似，只是网格中存在障碍 1、确定状态 最后一步 最后一步一定是从左边(i,j-1)或上边(i-1,j)过来 子问题 状态f[i][j]表示从左上角有多少中方式走到格子(i,j) 2、状态转移方程 f[i][j]=f[i][j-1]+f[i-1][j] 3、初始条件和边界情况 如果左上角(0,0)格或者右下角(m-1,n-1)格有障碍，直接输出0 如果(i,j)格有障碍，ff[i][j]=0，表示机器人不能到达此格（0种方式） 初始条件：f[0][0]=1 4、计算顺序 从小到大 代码如下： 1234567891011121314151617181920212223242526272829int count(int **A) //数组A决定某一格是否存在障碍&#123; int m=A.length,n=A[0].length; //m为列数，n为行数 int **f; int i,j; if(m==0||n==0) return 0; f=(int **)malloc(sizeof(int *)*m); //初始化路径数组 for(i=0;i&lt;m;i++) f[i]=(int *)malloc(sizeof(int)*n); for(i=0;i&lt;m;i++) for(j=0;j&lt;n;j++) &#123; if(A[0][0]==1) //左上格为有障碍，则没有路径到达右下角 f[i][j]=0; else if(i==0&amp;&amp;j==0) //左上角 f[i][j]=1; else //对于其余行与列 &#123; f[i][j]=0; //首先初始化为0 if(i-1&gt;=0) f[i][j]+=f[i-1][j]; //加左边到达的路径 if(j-1&gt;=0) f[i][j]+=f[i][j-1]; //加上面到达的路径 &#125; &#125; return f[m-1][n-1];&#125; 时间复杂度O(N)，空间复杂度O(N) 二、序列型动态规划（序列+状态） 序列型动态规划：f[i]下标表示前i个元素的 最小/方式数/可能性 例二：漆房子(paint house) 1、确定状态 最优策略是花费最小的策略 最后一步 最优策略中房子N-1一定染成了红、蓝、绿中的一种，但相邻两栋房子不能漆成一种颜色，所以如果第N-1房子是红色，N-2房子只能是蓝色或绿色，依次类推。 由于不知道N-2的房子是什么颜色，就不能确定N-1房子是什么颜色，故不能套用上面的方法。 分别记录油漆前N-1栋房子并且房子N-2是红色、蓝色、绿色的最小花费 子问题 求油漆前N栋房子并且房子N-1是红色、蓝色、绿色的最小花费 分别记录油漆前N-1栋房子并且房子N-2是红色、蓝色、绿色的最小花费 状态：设油漆前i栋房子并且房子i-1是红色、蓝色、绿色的最小花费分别为f[i][0]，f[i][1]，f[i][2]，例如房子0,1,2为前三栋房子 2、状态转移方程 设油漆前i栋房子并且房子i-1是红色、蓝色、绿色的最小花费分别为f[i][0]，f[i][1]，f[i][2] 状态转移方程为：**f[i][0]=min{f[i-1][1]+cost[i-1][0]，f[i-1][2]+cost[i-1][0]} ** 3、初始条件和边界情况 初始条件：f[0][0]=f[0][1]=f[0][2]=0 //前0栋房子油漆任何房子，无需花费 无边界情况 4、计算顺序 从小到大 代码如下： 12345678910111213141516171819202122232425262728int mincost(int *costs)&#123; int n=costs.length; int **f; int i,j,k,res; if(n==0) return 0; f=(int **)malloc(sizeof(int *)*n+1); //必须为n+1，即为前n栋房子油漆的最小花费 for(i=0;i&lt;m;i++) f[i]=(int *)malloc(sizeof(int)*3); //用于存储某房子漆三种颜色的最小花费 f[0][0]=f[0][1]=f[0][2]=0 //前0栋房子油漆任何房子，无需花费 for(i=0;i&lt;n;i++) for(j=0;j&lt;3;j++) //j是第i-2栋房子的颜色，也可用来代表第i栋房子的颜色 &#123; f[i][j]=MAX: //初始化为最大 for(k=0;k&lt;3;k++) //j是第i-1栋房子的颜色 if(j==k) continue; else if(f[i-1][k]+costs[i-1][j]&lt;f[i][j]) //计算当前房子漆某种颜色的花费，花费=第i-1栋房子除当前颜色的最小花费+当前颜色花费 f[i][j]=f[i-1][k]+costs[i-1][j]; &#125; res=f[n][0]; if(f[n][1]&lt;res) res=f[n][1]; if(f[n][2]&lt;res) res=f[n][2]; //从三种颜色的花费找出最小 return res;&#125; 时间复杂度O(N)，空间复杂度O(N) 三、划分性动态规划 划分型动态规划：给定长度为N的序列或字符串，可以划分成若干段处理 例三：加密字符串(Decode Ways) 1、确定状态 解密数字串划分成若干段数字，每段数字对应一个字母 最后一步 字符串的末尾字符可划分为一个一组或者两个一组，结果为两个划分方式的总和，如图 子问题 设数字串长度为N，求前N个字符的解密方式数，需要知道前N-1和N-2个字符的解密方式数 设字符串前i个数字解密成字母串有f[i]种方式 2、状态转移方程 3、初始条件和边界情况 初始条件：f[0]=1，即空串有一种方式解密 边界情况：如果i=1，只看最后一个数字 4、计算顺序 从小到大 代码如下： 1234567891011121314151617181920212223int numdecode(string ss)&#123; int n=strlen(ss),t; int *f; if(n==0) return 0; f=(int *)malloc(sizeof(int)*(n+1)); //f[n]表示的是前n个字母串的解密方式数 f[0]=1; for(i=0;i&lt;n+1;i++) &#123; f[i]=0; t=ss[i-1]-&#x27;0&#x27;; if(i&gt;=1&amp;&amp;i&lt;=9) f[i]+=f[i-1]; if(i&gt;=2) &#123; t=(s[i-2]-&#x27;0&#x27;)*10+s[i-1]-&#x27;0&#x27;; if(t&gt;=10&amp;&amp;t&lt;=26) f[i]+=f[i-2]; &#125; &#125; return f[n];&#125; 时间复杂度O(N)，空间复杂度O(N)","categories":[{"name":"acm","slug":"acm","permalink":"https://silenthly.github.io/categories/acm/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://silenthly.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"c对文件的操作","slug":"c/c对文件的操作","date":"2020-12-29T15:57:45.000Z","updated":"2021-10-27T05:01:03.915Z","comments":true,"path":"2020/12/29/c/c对文件的操作/","link":"","permalink":"https://silenthly.github.io/2020/12/29/c/c%E5%AF%B9%E6%96%87%E4%BB%B6%E7%9A%84%E6%93%8D%E4%BD%9C/","excerpt":"二进制文件与ASCII文件（纯文本文件） 数据在内存中是以二进制形式存储的（因为CPU只认识0和1），如果不加转换的输出到外存，就是二进制文件。也称之为映像文件 ​ 广义的二进制文件即指文件，由文件在外部设备的存放形式为二进制而得名。狭义的二进制文件即除文本文件以外的文件。文本文件是一种由很多行字符构成的计算机文件。文本文件存在于计算机系统中，通常在文本文件最后一行放置文件结束标志。文本文件的编码基于字符定长，译码相对要容易一些；二进制文件编码是变长的，灵活利用率要高，而译码要难一些，不同的二进制文件译码方式是不同的。 ​ 二者本质上没有什么区别，在硬盘上都有一种存放方式——二进制，文本文件是特殊的二进制文件。","text":"二进制文件与ASCII文件（纯文本文件） 数据在内存中是以二进制形式存储的（因为CPU只认识0和1），如果不加转换的输出到外存，就是二进制文件。也称之为映像文件 ​ 广义的二进制文件即指文件，由文件在外部设备的存放形式为二进制而得名。狭义的二进制文件即除文本文件以外的文件。文本文件是一种由很多行字符构成的计算机文件。文本文件存在于计算机系统中，通常在文本文件最后一行放置文件结束标志。文本文件的编码基于字符定长，译码相对要容易一些；二进制文件编码是变长的，灵活利用率要高，而译码要难一些，不同的二进制文件译码方式是不同的。 ​ 二者本质上没有什么区别，在硬盘上都有一种存放方式——二进制，文本文件是特殊的二进制文件。 二进制文件的好处 第一是二进制文件比较节约空间，这两者储存字符型数据时并没有差别。但是在储存数字，特别是实型数字时，二进制更节省空间，比如储存 Real*4 的数据：3.1415927，文本文件需要 9 个字节，分别储存：3 . 1 4 1 5 9 2 7 这 9 个 ASCII 值，而二进制文件只需要 4 个字节（DB 0F 49 40） 第二个原因是，内存中参加计算的数据都是用二进制无格式储存起来的，因此，使用二进制储存到文件就更快捷。如果储存为文本文件，则需要一个转换的过程。在数据量很大的时候，两者就会有明显的速度差别了。 第三，就是一些比较精确的数据，使用二进制储存不会造成有效位的丢失。 什么是缓冲区 缓冲区又称为缓存，它是内存空间的一部分。也就是说，在内存空间中预留了一定的存储空间，这些存储空间用来缓冲输入或输出的数据，这部分预留的空间就叫做缓冲区。缓冲区根据其对应的是输入设备还是输出设备，分为输入缓冲区和输出缓冲区。 为什么要引入缓冲区 我们为什么要引入缓冲区呢？ 比如我们从磁盘里取信息，我们先把读出的数据放在缓冲区，计算机再直接从缓冲区中取数据，等缓冲区的数据取完后再去磁盘中读取，这样就可以减少磁盘的读写次数，再加上计算机对缓冲区的操作大大快于对磁盘的操作，故应用缓冲区可大大提高计算机的运行速度。 又比如，我们使用打印机打印文档，由于打印机的打印速度相对较慢，我们先把文档输出到打印机相应的缓冲区，打印机再自行逐步打印，这时我们的CPU可以处理别的事情。现在您基本明白了吧，缓冲区就是一块内存区，它用在输入输出设备和CPU之间，用来缓存数据。它使得低速的输入输出设备和高速的CPU能够协调工作，避免低速的输入输出设备占用CPU，解放出CPU，使其能够高效率工作。 其中，二进制模式与文本模式操作相似，只不过是以二进制流的形式读写而已，下面以文本模式为例分析： 1.“r” 模式： 1.1 打开文件进行“只读”操作，即只能从文件读取内容。 1.2 若欲操作的文件不存在，则打开失败。 1.3 成功打开文件时，文件指针位于文件开头。 1.4 打开文件后，不会清空文件内原有内容。 1.5 可从文件中任意位置读取内容。 2.“w” 模式： 2.1 打开文件进行“只写”操作，即只能向文件写入内容。 2.2 若欲操作的文件不存在，则新建文件。 2.3 成功打开文件时，文件指针位于文件开头。 2.4 打开文件后，会清空文件内原有的内容。 2.5 可向文件中任意位置写入内容，且进行写入操作时，会覆盖原有位置的内容。 3.“a” 模式： 3.1 打开文件进行“追加”操作，即只能向文件写入内容。 3.2 若欲操作的文件不存在，则新建文件。 3.3 成功打开文件时，文件指针位于文件结尾。 3.4 打开文件后，不会清空文件内原有内容。 3.5 只能向文件**末尾追加(写)**内容。 4.&quot;r+&quot;模式： 4.1 打开文件进行“读写”操作，即既可读取，又可写入。 4.2 若欲操作的文件不存在，则打开失败。 4.3 成功打开文件时，文件指针位于文件开头。 4.4 打开文件后，不会清空文件内原有内容。 4.5 无论是读取内容还是写入内容，都可在文件中任意位置进行，且进行写入操作时，会覆盖原有位置的内容。 5.&quot;w+&quot;模式： 5.1 打开文件进行“读写”操作，即既可读取，又可写入。 5.2 若欲操作的文件不存在，则新建文件。 5.3 成功打开文件时，文件指针位于文件开头。 5.4 打开文件后，会清空文件内原有的内容。 5.5 无论是读取内容还是写入内容，都可在文件中任意位置进行，且进行写入操作时，会覆盖原有位置的内容。 6.&quot;a+&quot;模式： 6.1 打开文件进行“读写”操作，即既可读取，又可写入。 6.2 若欲操作的文件不存在，则新建文件。 6.3 成功打开文件时，文件指针位于文件结尾。 6.4 打开文件后，不会清空文件内原有内容。 6.5 读取内容时，可以在任意位置进行，但写入内容时，只会追加在文件尾部。 文件函数 1、打开与关闭文件函数 1fopen(&quot;文件名&quot;,&quot;使用文件方式&quot;);//打开文件，文件名是一个字符串，使用方式需要加双引号 为了使文件指针与文件建立联系，我们要将函数返回的指针给我们的文件指针，像这样： 12FILE *p;p=fopen(&quot;test.txt&quot;,&quot;r&quot;);//以读的方式打开默认路径下一个叫test的文本文件 1fclose(p);//关闭p指向的文件 示例一： 123456789101112131415161718#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; FILE *p; //设置一个文件指针 char ch; //定义一个字符变量 if((p=fopen(&quot;text.txt&quot;,&quot;w&quot;))==NULL) //以只写的方式打开一个叫test的文本文件，当出错时，即返回值为NULL时，输出错误信息 &#123; printf(&quot;error!&quot;); exit(0); //关闭所有文件，终止正在执行的程序 &#125; for(;ch!=&#x27;\\n&#x27;;) //输入ch直到输入空格 &#123; scanf(&quot;%c&quot;,&amp;ch); fputc(ch,p); //将字符ch写入p所指向的文件 &#125; fclose(p); //关闭文件&#125; 示例二： 12345678910111213141516171819#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;int main()&#123; FILE *p; char ch; if((p=(&quot;text.txt&quot;,&quot;r&quot;))==NULL)//以只读的方式打开text。 &#123; printf(&quot;error!&quot;); exit(0); &#125; for(;ch!=&#x27;\\n&#x27;;) &#123; ch=fgetc(p);//ch得到p所指文件中的每一个字符 putchar(ch);//将得到的字符输出到屏幕 &#125; flose(p);//关闭文件 return 0;&#125; 2、读写字符函数 读字符fgetc 1fgetc(文件指针);//从指针所指向的文件中读入一个字符 写字符fputc 1fputc(ch,p);//把字符变量ch写到p所指向的文件中去 示例：文件复制 123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; FILE *p1,*p2; //设置2个文件指针 char filename1[30],filename2[30],ch; //设置2个字符数组用来输入文件名 printf(&quot;请输入要复制的文件名:\\n&quot;); gets(filename1); //输入文件名 printf(&quot;请输入复制后的文件名:\\n&quot;); gets(filename2); //输入文件名 if((p1=fopen(filename1,&quot;rb&quot;))==NULL) //打开被复制的文件 &#123; printf(&quot;error!&quot;); exit(0); &#125; if((p2=fopen(filename2,&quot;wb&quot;))==NULL) //写入要复制的文件名 &#123; printf(&quot;error!&quot;); exit(0); &#125; while(!feof(p1)) //用一个检查文件是否结束的函数来判断 &#123; ch=fgetc(p1); //读出每一个p1指向的文件中的字节，把ch写入到p2指向的文件中去 fputc(ch,p2); &#125; printf(&quot;复制成功&quot;); fclose(p1); //用完之后，为了避免不必要的操作干扰读写，要关闭文件，即断掉文件指针与文件的联系 fclose(p2); return 0;&#125; 检测文件是否结束的函数 feof(end of file) 1feof(文件指针); //当文件结束时返回非零值，但文件未结束时返回零 再看刚才的循环语句 1while(!feof(p)) //当返回值为0的时候执行循环，返回值非0的时候就结束循环 注意：该函数先读再判断是否结束，参考资料：http://www.voidcn.com/article/p-cycpxclc-no.html 当然对于文本文件可以不用二进制的方式处理 可以把刚才的循环语句换成如下 1while(!(ch=fgetc(p))==EOF) //EOF和NULL在标准函数库里的宏定义分别是-1和0 那么这个-1又代表了什么 文件的所有有效字符后有一个文件尾标志，当读完全部的字符后，文件读写位置标记就会指向最后一个字符的后面的结束字节（里面存放了-1），如果再读取就会读出-1 在文本文件中，数据都是以字符的ASCII代码值的形式存放。我们知道，ASCII代码值的范围是0~127，不可能出现-1，因此可以用EOF作为文件结束标志。 WARNING二进制文件因为是以二进制形式保存的所以不能以字符的方式来存取的，所以不应用刚才的方式对二进制文件进行写入。 字符串读写文件 函数名 调用形式 功能 返回值 fgets fgets(str,n,fp) 从fp指向的文件读入一个长度为n-1的字符串，存放到字符数组str中去 成功返回地址str,失败返回NULL fputs fputs(str,fp) 把str所指向的字符串写入fp所指向的文件中 成功返回0，失败返回非零 例： 1234567891011121314151617#incldue&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; FILE *p; char filename[40],str[30]; //定义一个字符数组来储存文件里的信息 printf(&quot;请输入要打开的文件名\\n&quot;); gets(filename); if((p=fopen(filename,&quot;r&quot;))==NULL) //以只读的方式打开文件 &#123; printf(&quot;error!&quot;); exit(0); &#125; fgets(str,20,p); //将p所指的文件中的20字符读取给字符串str fclose(p); //关闭文件 puts(str); //以字符串形式输出str&#125; 3、以格式化的方式读写文本文件 名称 引用方式 fprintf fprintf(文件指针，格式字符串，输出列表) fscanf fscanf（文件指针，格式字符串，输入列表） 123456789101112131415161718#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; int i=3; float j=4.567; char string[20]; FILE *p; if((p=fopen(&quot;text1.txt&quot;,&quot;r+&quot;))=NULL) //以读写的方式打开test &#123; printf(&quot;error!&quot;); exit(0); &#125; fscanf(p,&quot;%s&quot;,string); //把其中的字符串写入字符数组string中 puts(string); //输出由文件中写入的字符串 fprintf(p,&quot;%d .3%f&quot;,i,j); //以%3d %.3的格式给文本输入整形变量i和浮点型变量j(文件末尾不能有空格，否则无法输入) fclose(p); //关闭文件&#125; 4、用二进制方式向文件读写一组数据 上面的复制文件的例子也是对二进制文件的读写，在这里有一组专门的二进制文件读写函数 名称 引用方式 fread fread(buffer,size,count,stream) fwrite fwrite(buffer,size,count,stream) （也被称为数据块读写） 参 数 buffer 用于接收数据的内存地址（是一个指针，无论输出输入都是首地址） size 要读的每个数据项的字节数，单位是字节 count 要读count个数据项，每个数据项size个字节. stream 文件指针 数据块读写多用于结构体变量的读写（因为结构体所占的字符数是不规则的） fwrite与fprintf的区别(原创地址：https://www.cnblogs.com/hhddcpp/p/4303572.html) 用fwrite 写入文件的如果是能够表示为字符，那么就会显示为字符，如果显示不出来，那就写的是二进制内容（所谓的乱码） fprintf写的是数字转换成ASCII码之后的字符。 用记事本打开看下，fwrite写的打开是乱码，fprintf写入的是可读的字符 其实这四个示例生成的文件用fopen都是可读的，四个文件都没有错 总而言之：如果要让生成的文件自己可以看得懂，那么就选择fprintf，如果想看不懂，那就用fwrite，两者只是写入方式不同，生成的文件倒都是计算机可读的 随机读写数据文件 (1)文件位置标记及其定位 文件位置标记其实是一个文件中的一个指针，在我们的顺序读写当中，都是一个字符一个字符的读出又写入，没有出现跳跃的情况，但在实际使用的过程中，我们不许要每次都要把文件全部都读一遍 只需要稍微的改动某些数据， 5、文件位置标记的定位 rewind 功能是将文件内部的指针重新指向一个文件的开头 注意：不是 文件指针而是文件内部的位置指针，随着对文件的读写文件的位置指针（指向当前读写字节）向后移动。而文件指针是指向整个文件，如果不重新赋值文件指针不会改变。 名称 引用方式 rewind fread(文件指针) 1234567891011121314151617181920212223242526272829#include&lt;stdio.h&gt; int main()&#123; FILE *fp; char ch; if((fp=fopen(&quot;text1.txt&quot;,&quot;w+&quot;))==NULL) &#123; printf(&quot;\\nCannot open file\\nstrike any key exit\\n&quot;); getchar(); return 1; &#125; printf(&quot;input a string:\\n&quot;); ch=getchar(); while(ch!=&#x27;\\n&#x27;) &#123; fputc(ch,fp); ch=getchar(); &#125; rewind(fp); ch=fgetc(fp); while(ch!=EOF) &#123; putchar(ch); ch=fgetc(fp); &#125; fclose(fp); return 0;&#125; rewind§ 每输入一个字符，文件内部位置指针向后移动一个字节。写入完毕，该指针已指向文件末尾, 如果要把文件从头读出，须把指针移到文件头，利用rewind()函数。 fseek函数,文件指针位置函数 名称 引用方式 fseek fseek(文件指针,位移量，起始点) 起始点有3种情况，分别是0，1，2 起始点 名字 用数字代表 文件开始位置 SEEK_SET 0 文件当前位置 SEEK_CUR 1 文件末尾位置 SEEK_END 2 位移量是long形数据要在结尾加上L 123fseek(fp,100L,0);//将文件位置标记向前移动到离文件开头100个字节处fseek(fp,50L,1);//将文件位置标记前移到离当前位置50个字节处fseek(fp,-10L,2);//将文件位置标记从文件末尾后退10个字节 在上面的代码出修改一下 1234567for(i=0;i&lt;NUM;i+=2)&#123; fseek(fp,i*sizeof(struct Student),0);//跳过每次移动2个结构体所占的字节 printf(&quot;%-10s%4d%4d%15s&quot;,Stud[i].name,Stud[i].num,Stud[i].age,Stud[i].add); printf(&quot;\\n&quot;);&#125; 这样就实现了只输出部分的数据","categories":[{"name":"c","slug":"c","permalink":"https://silenthly.github.io/categories/c/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"学生成绩管理系统","slug":"c/学生成绩管理系统","date":"2020-12-28T18:12:23.000Z","updated":"2021-10-27T05:05:57.838Z","comments":true,"path":"2020/12/29/c/学生成绩管理系统/","link":"","permalink":"https://silenthly.github.io/2020/12/29/c/%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/","excerpt":"1）要求： (1) 每条记录包括：学号、姓名、专业和5门课程的成绩； (2) 能够实现添加、删除、修改功能； (3) 能够计算某学生的总分和平均分； (4) 能按照总分排序输出； (5) 建议使用链表结构，与文件存储功能。 2）涉及的内容或知识点： 内容：需求分析、概要设计、详细设计、程序调试、说明书撰写； 知识点：C语言的基本语法、结构化程序设计、数组、函数、结构体、指针、链表、排序算法、文件存储等。","text":"1）要求： (1) 每条记录包括：学号、姓名、专业和5门课程的成绩； (2) 能够实现添加、删除、修改功能； (3) 能够计算某学生的总分和平均分； (4) 能按照总分排序输出； (5) 建议使用链表结构，与文件存储功能。 2）涉及的内容或知识点： 内容：需求分析、概要设计、详细设计、程序调试、说明书撰写； 知识点：C语言的基本语法、结构化程序设计、数组、函数、结构体、指针、链表、排序算法、文件存储等。 主函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;struct student&#123; char name[10]; int num; char professional[10]; int s1; int s2; int s3; int s4; int s5; double ave; int sum; struct student *next;&#125;;typedef struct student stu;int main()&#123; stu *head=filelist(); /*从文件读取带头节点的链表*/ stu *node=head; while(node-&gt;next!=NULL) &#123; node=node-&gt;next; &#125; /*遍历到最后一个节点，方便用尾插法创建新的节点*/ int n,i,x,y=1; while(y) &#123; system(&quot;cls&quot;); /*清屏，操作页面更美观*/ showmenu(); /*显示菜单*/ printf(&quot;选择操作&lt;0-7&gt;:\\n&quot;); scanf(&quot;%d&quot;,&amp;x); switch(x) &#123; case 0:y=0;listtofile(head);break; /*保存信息并退出系统*/ case 1:&#123; node = creatnode(node); add(head); &#125;system(&quot;pause&quot;);break; /*添加成绩*/ case 2:delnode(head);system(&quot;pause&quot;);break; /*删除成绩*/ case 3:mod(head);add(head);system(&quot;pause&quot;);break; /*修改成绩*/ case 4:sort(head);break; /*排名*/ case 5:list(head);system(&quot;pause&quot;);break; /*显示成绩信息*/ case 6:fine(head);break; /*查找成绩*/ case 7:average(head);system(&quot;pause&quot;);break; /*查看各科平均分 */ default:printf(&quot;输入错误，请重试！\\n&quot;);system(&quot;pause&quot;); &#125; &#125; return 0;&#125; 菜单： 123456789101112131415void showmenu()&#123; printf(&quot;*----------------------------------------------------*\\n&quot;); printf(&quot;* 欢迎使用学生成绩管理系统 *\\n&quot;); printf(&quot;*----------------------------------------------------*\\n&quot;); printf(&quot;* 1： 添加成绩 *\\n&quot;); printf(&quot;* 2： 删除成绩 *\\n&quot;); printf(&quot;* 3： 修改成绩 *\\n&quot;); printf(&quot;* 4： 排名 *\\n&quot;); printf(&quot;* 5： 显示成绩信息 *\\n&quot;); printf(&quot;* 6： 查找成绩 *\\n&quot;); printf(&quot;* 7： 查看各科平均分 *\\n&quot;); printf(&quot;* 0： 保存信息并退出系统 *\\n&quot;); printf(&quot;*----------------------------------------------------*\\n&quot;);&#125; 录入成绩： 1234567891011121314151617181920212223242526stu *creatnode(stu *node)&#123; stu *p; p = (stu *)malloc(sizeof(stu)); p-&gt;next = NULL; printf(&quot;请输入学生名：\\n&quot;); scanf(&quot;%s&quot;,&amp;p-&gt;name,&amp;p-&gt;num); printf(&quot;请输入学号：\\n&quot;); scanf(&quot;%d&quot;,&amp;p-&gt;num); printf(&quot;请输入专业：\\n&quot;); scanf(&quot;%s&quot;,&amp;p-&gt;professional); printf(&quot;请输入思修成绩：\\n&quot;); scanf(&quot;%d&quot;,&amp;p-&gt;s1); printf(&quot;请输入数学成绩：\\n&quot;); scanf(&quot;%d&quot;,&amp;p-&gt;s2); printf(&quot;请输入程序设计成绩：\\n&quot;); scanf(&quot;%d&quot;,&amp;p-&gt;s3); printf(&quot;请输入计导成绩：\\n&quot;); scanf(&quot;%d&quot;,&amp;p-&gt;s4); printf(&quot;请输入英语成绩：\\n&quot;); scanf(&quot;%d&quot;,&amp;p-&gt;s5); node-&gt;next = p; /*用尾插法创建新节点*/ node = p; printf(&quot;添加成功！\\n&quot;); return node;&#125; 删除成绩： 123456789101112131415161718192021222324252627282930313233343536373839404142434445void delnode(stu *head)&#123; int i=1,n; stu *p1 = head,*p2 = head; printf(&quot;* 1： 删除指定学生成绩 *\\n&quot;); printf(&quot;* 2： 删除全部成绩 *\\n&quot;); printf(&quot;* 3： 取消操作 *\\n&quot;); while(i) &#123; printf(&quot;选择操作&lt;1-3&gt;:\\n&quot;); scanf(&quot;%d&quot;,&amp;n); switch(n) &#123; case 1: &#123; char *name1; int flag = 1,n; name1 = (char *)malloc(10); /*开辟一个临时空间存储输入的名字*/ printf(&quot;请输入需要删除的学生姓名：\\n&quot;); scanf(&quot;%s&quot;,name1); while(flag) &#123; if(!strcmp(p1-&gt;name,name1)) /*比较函数查找名字*/ &#123; flag = 0; printf(&quot;确定删除该生的成绩吗？\\n&quot;); listnode(p1); printf(&quot;1、是 2、否\\n&quot;); scanf(&quot;%d&quot;,&amp;n); switch(n) &#123;case 1:p2-&gt;next = p1-&gt;next; printf(&quot;删除成功！\\n&quot;);break; case 2:printf(&quot;取消删除！\\n&quot;);break; default:printf(&quot;输入错误，请重试！\\n&quot;);&#125; &#125;break; else &#123; p2 = p1; p1 = p1-&gt;next;&#125; &#125;&#125;i=0;break; case 2:p1-&gt;next = NULL;printf(&quot;全部删除成功！\\n&quot;);i=0;break;/*头节点的指针域指向空，将头节点后的链表清除掉*/ case 3:printf(&quot;取消删除！\\n&quot;);i=0;break; default:printf(&quot;输入错误，请重试！\\n&quot;); &#125; &#125;&#125; 修改成绩： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546void mod(stu *head)&#123; stu *p = head; char *name1; int flag = 1,n; name1 = (char *)malloc(10); /*开辟一个临时空间存储输入的名字*/ printf(&quot;请输入需要修改的学生姓名：\\n&quot;); scanf(&quot;%s&quot;,name1); while(flag) &#123; if(!strcmp(p-&gt;name,name1)) /*比较函数查找名字*/ &#123; flag=0; printf(&quot;确定修改该生的成绩吗？\\n&quot;); listnode(p); printf(&quot;1、是 2、否\\n&quot;); scanf(&quot;%d&quot;,&amp;n); switch(n) &#123;case 1:printf(&quot;请重新输入信息\\n&quot;); printf(&quot;请输入学生名：\\n&quot;); scanf(&quot;%s&quot;,&amp;p-&gt;name,&amp;p-&gt;num); printf(&quot;请输入学号：\\n&quot;); scanf(&quot;%d&quot;,&amp;p-&gt;num); printf(&quot;请输入专业：\\n&quot;); scanf(&quot;%s&quot;,&amp;p-&gt;professional); printf(&quot;请输入思修成绩：\\n&quot;); scanf(&quot;%d&quot;,&amp;p-&gt;s1); printf(&quot;请输入数学成绩：\\n&quot;); scanf(&quot;%d&quot;,&amp;p-&gt;s2); printf(&quot;请输入程序设计成绩：\\n&quot;); scanf(&quot;%d&quot;,&amp;p-&gt;s3); printf(&quot;请输入计导成绩：\\n&quot;); scanf(&quot;%d&quot;,&amp;p-&gt;s4); printf(&quot;请输入英语成绩：\\n&quot;); scanf(&quot;%d&quot;,&amp;p-&gt;s5); printf(&quot;修改成功！\\n&quot;); break; case 2:printf(&quot;取消修改！\\n&quot;);break; default:printf(&quot;输入错误，请重试！\\n&quot;);&#125; &#125; else &#123; p = p-&gt;next; &#125; &#125;&#125; 显示成绩信息： 12345678910111213141516171819void list(stu *head)&#123; printf(&quot;--------------------------------------------------------------------------------------\\n&quot;); printf(&quot;| 姓名 | 学号 | 专业 | 高数 | 英语 | 程序设计基础 | 数据结构 | 数据库 | 总分 | 平均分|\\n&quot;); printf(&quot;--------------------------------------------------------------------------------------\\n&quot;); stu *p = head-&gt;next; while(p != NULL) /*遍历法输出所有节点的内容*/ &#123; printf(&quot;%6s%6d%8s%7d%7d%11d\\t%10d%10d%10d%8.2lf\\n&quot;,p-&gt;name,p-&gt;num,p-&gt;professional,p-&gt;s1,p-&gt;s2,p-&gt;s3,p-&gt;s4,p-&gt;s5,p-&gt;sum,p-&gt;ave); p = p-&gt;next; &#125;&#125;void listnode(stu *p)&#123; printf(&quot;--------------------------------------------------------------------------------------\\n&quot;); printf(&quot;| 姓名 | 学号 | 专业 | 高数 | 英语 | 程序设计基础 | 数据结构 | 数据库 | 总分 | 平均分|\\n&quot;); printf(&quot;--------------------------------------------------------------------------------------\\n&quot;); printf(&quot;%6s%6d%8s%7d%7d%11d\\t%10d%10d%10d%8.2lf\\n&quot;,p-&gt;name,p-&gt;num,p-&gt;professional,p-&gt;s1,p-&gt;s2,p-&gt;s3,p-&gt;s4,p-&gt;s5,p-&gt;sum,p-&gt;ave); /*输出某一个节点的内容*/&#125; 排名： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758void sort(stu *head)&#123; stu *p,*q,*r,*s; /*用四个指针实现连续三个链表节点的变换*/ int n,i=1; while(i)&#123; system(&quot;cls&quot;); showmenu(); printf(&quot;* 1： 按学号排序 *\\n&quot;); printf(&quot;* 2： 按成绩排序 *\\n&quot;); printf(&quot;* 3： 取消操作 *\\n&quot;); printf(&quot;选择操作&lt;1-3&gt;:\\n&quot;); scanf(&quot;%d&quot;,&amp;n); switch(n) &#123; case 1: p=head; while(p-&gt;next != NULL) &#123; q = p-&gt;next; r = p; while(q-&gt;next != NULL) &#123; if(q-&gt;next-&gt;num &lt; r-&gt;next-&gt;num) r = q; q=q-&gt;next; &#125; if(r != p) &#123; s = r-&gt;next; r-&gt;next = s-&gt;next; s-&gt;next = p-&gt;next; p-&gt;next = s; &#125; p = p-&gt;next; &#125;list(head);system(&quot;pause&quot;);break; case 2: p=head; while(p-&gt;next != NULL) &#123; q = p-&gt;next; r = p; while(q-&gt;next != NULL) &#123; if(q-&gt;next-&gt;sum &gt; r-&gt;next-&gt;sum) r = q; q=q-&gt;next; &#125; if(r != p) &#123; s = r-&gt;next; r-&gt;next = s-&gt;next; s-&gt;next = p-&gt;next; p-&gt;next = s; &#125; p = p-&gt;next; &#125;list(head);system(&quot;pause&quot;);break; case 3:i=0;break; default:printf(&quot;输入错误，请重试！\\n&quot;);system(&quot;pause&quot;); &#125; &#125;&#125; 链表保存到文件： 12345678910111213141516void listtofile(stu *head)&#123; FILE *fp; stu *p=head-&gt;next; if((fp=fopen(&quot;student.txt&quot;,&quot;wb&quot;))==NULL) /*打开文件*/ &#123; printf(&quot;cannot open file\\n&quot;); exit(0); &#125; while(p != NULL) /*遍历链表*/ &#123; fwrite(p,sizeof(stu),1,fp); /*以二进制的方式把链表数据写入文件*/ p = p-&gt;next; &#125; fclose(fp);&#125; 从文件读入链表： 12345678910111213141516171819202122232425262728stu *filelist()&#123; FILE *fp; stu *p,*p1; stu *head; head = (stu *)malloc(sizeof(stu)); memset(head,0,sizeof(stu)); head-&gt;next = NULL; /*创建一个头节点*/ if((fp = fopen(&quot;student.txt&quot;,&quot;rb&quot;))==NULL) &#123; printf(&quot;cannot open flie\\n&quot;); exit(0); &#125; p1 = head; while(!feof(fp)) /*feof作用过程为先读后判断*/ &#123; p = (stu *)malloc(sizeof(stu)); p-&gt;next = NULL; if(fread(p,sizeof(stu),1,fp)!=0) /*用于判断文件指针是否到结尾*/ &#123; p1-&gt;next = p; p1 = p; &#125; else break; &#125; fclose(fp); return head;&#125; 查找方式： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051void fine(stu *head)&#123; int i = 1,y = 1,n; stu *p; while(y) &#123; system(&quot;cls&quot;); showmenu(); printf(&quot;* 1： 按姓名查找 *\\n&quot;); printf(&quot;* 2： 按学号查找 *\\n&quot;); printf(&quot;* 3： 取消操作 *\\n&quot;); printf(&quot;选择操作&lt;1-3&gt;:\\n&quot;); scanf(&quot;%d&quot;,&amp;n); switch(n) &#123; case 1: p=head; i = 1; char *name1; name1 = (char *)malloc(10); printf(&quot;请输入学生姓名：\\n&quot;); scanf(&quot;%s&quot;,name1); while(i) &#123; if(!strcmp(p-&gt;name,name1)) /*遍历查找*/ &#123; i = 0; listnode(p); &#125; else &#123;p = p-&gt;next;&#125; &#125; system(&quot;pause&quot;);break; case 2: p = head; i = 1; int x; printf(&quot;请输入学生学号：\\n&quot;); scanf(&quot;%d&quot;,&amp;x); while(i) &#123; if(x == p-&gt;num) &#123; i = 0; listnode(p); &#125; else &#123;p = p-&gt;next;&#125; &#125; system(&quot;pause&quot;);break; case 3:y = 0;break; default:printf(&quot;输入错误，请重试！\\n&quot;);system(&quot;pause&quot;); &#125; &#125;&#125; 成绩计算： 1234567891011121314151617181920212223242526272829303132333435void add(stu *head)&#123; stu *p = head-&gt;next; while(p != NULL) &#123; p-&gt;sum = p-&gt;s1 + p-&gt;s2 + p-&gt;s3 + p-&gt;s4 +p-&gt;s5; p-&gt;ave=(double)p-&gt;sum/5; p = p-&gt;next; &#125;&#125;void average(stu *head)&#123; int sum1=0,sum2=0,sum3=0,sum4=0,sum5=0,i=0; double a1,a2,a3,a4,a5; stu *p=head; while(p != NULL) &#123; i++; sum1 += p-&gt;s1; sum2 += p-&gt;s2; sum3 += p-&gt;s3; sum4 += p-&gt;s4; sum5 += p-&gt;s5; p = p-&gt;next; &#125; a1 =(double)sum1 / i; a2 =(double)sum2 / i; a3 =(double)sum3 / i; a4 =(double)sum4 / i; a5 =(double)sum5 / i; list(head); printf(&quot;-------------------------------------------------------------------------------------\\n&quot;);printf(&quot;各科平均分：\\t\\t%6.2lf%7.2lf %10.2lf%13.2lf%10.2lf%\\n&quot;,a1,a2,a3,a4,a5); printf(&quot;--------------------------------------------------------------------------------------\\n&quot;);&#125;","categories":[{"name":"c","slug":"c","permalink":"https://silenthly.github.io/categories/c/"}],"tags":[{"name":"课程设计","slug":"课程设计","permalink":"https://silenthly.github.io/tags/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"}]},{"title":"memset函数","slug":"c/memset函数","date":"2020-12-02T06:55:57.000Z","updated":"2021-10-27T05:02:41.547Z","comments":true,"path":"2020/12/02/c/memset函数/","link":"","permalink":"https://silenthly.github.io/2020/12/02/c/memset%E5%87%BD%E6%95%B0/","excerpt":"​ memset()的函数， 它可以一字节一字节地把整个数组设置为一个指定的值。 memset()函数在mem.h头文件中声明，它把数组的起始地址作为其第一个参数，第二个参数是设置数组每个字节的值，第三个参数是数组的长度(字节数，不是元素个数)。其函数原型为：","text":"​ memset()的函数， 它可以一字节一字节地把整个数组设置为一个指定的值。 memset()函数在mem.h头文件中声明，它把数组的起始地址作为其第一个参数，第二个参数是设置数组每个字节的值，第三个参数是数组的长度(字节数，不是元素个数)。其函数原型为： 1void *memset(void*，int，unsigned)； 其中void*表示地址。 1、例如，下面的代码用数组做参数传递给标准函数memset()，以让其将数组设置成全0： 123456789#include&lt;stdring.h&gt; void main() &#123; int ia1[50]； int ia2[500]； memset(iai,0,50*sizeof(int))； memset(ia2,0,500*sizeof(int))； // &#125; 当然，如果用malloc分配的内存，一般只能使用memset来初始化了，用第一种初始化方法明显不合适。 2、例：char ch[10] 比如memset(ch,0,8),就是把数组ch前八项置为零，后面的不一定为零。比如刚开 ch[1]=‘z’,ch[8]=‘a’,ch[9]=‘b’,经过memset后，ch[1]为零了，而ch[8],ch[9]都不变. 3.memset函数详细说明 1) 1void *memset(void *s,int c,size_t n) ​ 总的作用：将已开辟内存空间 s 的首 n 个字节的值设为值 c。 ​ 2).memset() 函数常用于内存空间初始化。如： 12char str[100];memset(str,0,100); memset可以方便的清空一个结构类型的变量或数组。 ​ 如： ​ 12345struct sample_struct&#123; char csName[16]; int iSeq; int iType; &#125;; ​ 对于变量： ​ struct sample_strcut stTest; 1memset(&amp;stTest,0,sizeof(struct sample_struct)); 如果是数组： struct sample_struct TEST[10]; 则 1memset(TEST,0,sizeof(struct sample_struct)*10);","categories":[{"name":"c","slug":"c","permalink":"https://silenthly.github.io/categories/c/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"typedef详解","slug":"c/typedf详解","date":"2020-12-01T17:34:57.000Z","updated":"2021-10-27T05:04:49.912Z","comments":true,"path":"2020/12/02/c/typedf详解/","link":"","permalink":"https://silenthly.github.io/2020/12/02/c/typedf%E8%AF%A6%E8%A7%A3/","excerpt":"用途一 定义一种类型的别名，而不只是简单的宏替换。可以用作同时声明指针型的多个对象。比如： 12345678char* pa, pb; // 这多数不符合我们的意图，它只声明了一个指向字符变量的指针， // 和一个字符变量；（不用管* 离谁近，只生效一次。）以下则可行：typedef char* PCHAR; // 一般用大写PCHAR pa, pb; // 可行，同时声明了两个指向字符变量的指针虽然：char *pa, *pb;也可行，但相对来说没有用typedef的形式直观，尤其在需要大量指针的地方，typedef的方式更省事。","text":"用途一 定义一种类型的别名，而不只是简单的宏替换。可以用作同时声明指针型的多个对象。比如： 12345678char* pa, pb; // 这多数不符合我们的意图，它只声明了一个指向字符变量的指针， // 和一个字符变量；（不用管* 离谁近，只生效一次。）以下则可行：typedef char* PCHAR; // 一般用大写PCHAR pa, pb; // 可行，同时声明了两个指向字符变量的指针虽然：char *pa, *pb;也可行，但相对来说没有用typedef的形式直观，尤其在需要大量指针的地方，typedef的方式更省事。 用途二 为复杂的声明定义一个新的简单的别名。方法是：在原来的声明里逐步用别名替换一部分复杂声明，如此循环，把带变量名的部分留到最后替换，得到的就是原声明的最简化版。举例： 123451. 原声明：int *(*a[5])(int, char*);变量名为a，直接用一个新别名pFun替换a就可以了：typedef int *(*pFun)(int, char*); 原声明的最简化版：pFun a[5]; 12345672. 原声明：void (* b[10]) (void (* )());变量名为b，先替换右边部分括号里的，pFunParam为别名一：typedef void (* pFunParam)();再替换左边的变量b，pFunx为别名二：typedef void (*pFunx)(pFunParam);原声明的最简化版：pFunx b[10]; 12345673. 原声明：doube(* )() (* e)[9]; 变量名为e，先替换左边部分，pFuny为别名一：typedef double(* pFuny)();再替换右边的变量e，pFunParamy为别名二typedef pFuny (*pFunParamy)[9];原声明的最简化版：pFunParamy e; 理解复杂声明可用的“右左法则”： 从变量名看起，先往右，再往左，碰到一个圆括号就调转阅读的方向；括号内分析完就跳出括号，还是按先右后左的顺序，如此循环，直到整个声明分析完。举例： 1int (*func)(int * p); 首 先找到变量名func，外面有一对圆括号，而且左边是一个* 号，这说明func是一个指针；然后跳出这个圆括号，先看右边，又遇到圆括号，这说明 (* func)是一个函数，所以func是一个指向这类函数的指针，即函数指针，这类函数具有int* 类型的形参，返回值类型是int。 1int (*func[5])(int *); func 右边是一个[]运算符，说明func是具有5个元素的数组；func的左边有一个 * ，说明func的元素是指针（注意这里的* 不是修饰func，而是修饰 func[5]的，原因是[]运算符优先级比* 高，func先跟[]结合）。跳出这个括号，看右边，又遇到圆括号，说明func数组的元素是函数类型的指 针，它指向的函数具有int*类型的形参，返回值类型为int。 也可以记住2个模式： 12type (* )(....)函数指针 type (*)[]数组指针 两大陷阱 陷阱一 记住，typedef是定义了一种类型的新别名，不同于宏，它不是简单的字符串替换。比如： 先定义： 123typedef char* PSTR;然后：int mystrcmp(const PSTR, const PSTR); const PSTR实际上相当于const char* 吗？不是的，它实际上相当于char* const。 原因在于const给予了整个指针本身以常量性，也就是形成了常量指针char* const。 简单来说，记住当const和typedef一起出现时，typedef不会是简单的字符串替换就行。 陷阱二 typedef在语法上是一个存储类的关键字（如auto、extern、mutable、static、register等一样），虽然它并不真正影响对象的存储特性，如： typedef static int INT2; //不可行 编译将失败，会提示“指定了一个以上的存储类” typedef与#define的区别 案例一： 通常讲，typedef要比#define要好，特别是在有指针的场合。请看例子： 1234typedef char *pStr1; #define pStr2 char *; pStr1 s1, s2; pStr2 s3, s4; 在上述的变量定义中，s1、s2、s3都被定义为char *，而s4则定义成了char，不是我们所预期的指针变量，根本原因就在于#define只是简单的字符串替换而typedef则是为一个类型起新名字。 案例二： 下面的代码中编译器会报一个错误，你知道是哪个语句错了吗？ 123456typedef char * pStr; char string[4] = &quot;abc&quot;; const char *p1 = string; const pStr p2 = string; p1++; p2++; 是p2出错了。这个问题再一次提醒我们：typedef和#define不同，它不是简单的文本替换。上述代码中const pStr p2并不等于const char * p2。const pStr p2和const long x本质上没有区别，都是对变量进行只读限制，只不过此处变量p2的数据类型是我们自己定义的而不是系统固有类型而已。因此，const pStr p2的含义是：限定数据类型为char *的变量p2为只读，因此p2错误。 附加：const char* a和char* const a的区别 const char* a : 底层const char *const a : 顶层const 底层const是说：一个指针指向的对象的值，不可通过这个指针改变 比如： 12345char z;const char *a = &amp;z;char *b = &amp;z;const char &amp;c = z;char &amp;d = z; const限定：不可通过为* a和c赋值来改变z的值，但是可以通过*b和d改变z的值。 顶层const是说这个变量本身不可改变。 char* const b表示b是一个常指针，也就是说b必须始终指向同一个地址（但是可以改变b所指向的元素的值） 此外： 由于引用不是对象，只是别名，所以它只有底层const。 1const int &amp;e = z; // 不可通过为e赋值改变z的值。 既不是指针也不是引用的变量，只有顶层const。 1const int f = 10; // f本身不可改变。 指针既可以有底层const也可以有顶层const，二者可以同时出现： 123int *const g; // 顶层const，g本身不可改变。const int * h; // 底层const，h指向的值，即*h不可改变。const int * const i; // 底层+顶层const，i本身不可改变，*i也不可改变。 以上资料出自：C/C++ typedef用法详解（真的很详细）_superhoy的专栏-CSDN博客_c++ typedef作者：键盘tops舞者","categories":[{"name":"c","slug":"c","permalink":"https://silenthly.github.io/categories/c/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"字符数组与字符指针","slug":"c/字符数组与字符指针","date":"2020-11-25T06:31:56.000Z","updated":"2021-10-27T05:06:04.610Z","comments":true,"path":"2020/11/25/c/字符数组与字符指针/","link":"","permalink":"https://silenthly.github.io/2020/11/25/c/%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88/","excerpt":"1、存储位置与储存方式 (1)字符数组在内存中开辟了一段空间来存放字符串，每个元素存放一个字符。 (2)字符指针在文字常量区开辟了一段空间来存放字符串，并把字符串的首地址赋给指针变量str。","text":"1、存储位置与储存方式 (1)字符数组在内存中开辟了一段空间来存放字符串，每个元素存放一个字符。 (2)字符指针在文字常量区开辟了一段空间来存放字符串，并把字符串的首地址赋给指针变量str。 2、可否被修改 (1)字符数组内容可以被修改，但字符数组名做代表的字符串首地址不能被修改。 (2)指针变量指向的字符串内容不能被修改，但指针变量的值(存放的地址或者指向)是可以被修改的 3、赋值与初始化 真确的赋值： 12345数组：char str[10]=&quot;string&quot;;指针：char *str;str=&quot;string&quot;; 初始化： 1234567数组：char str[10];scanf(&quot;%s&quot;,str);//或用strcpy拷贝赋值指针：char *str=NULL;str=(char *)malloc(10);scanf(&quot;%s&quot;,str);","categories":[{"name":"c","slug":"c","permalink":"https://silenthly.github.io/categories/c/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"leetcode刷题第一期（1/3）","slug":"c/leetcode刷题第一期","date":"2020-11-16T14:44:57.000Z","updated":"2021-10-27T05:01:27.017Z","comments":true,"path":"2020/11/16/c/leetcode刷题第一期/","link":"","permalink":"https://silenthly.github.io/2020/11/16/c/leetcode%E5%88%B7%E9%A2%98%E7%AC%AC%E4%B8%80%E6%9C%9F/","excerpt":"用力扣做题最坑的是力扣默认用32位系统，而我们平时用的都是64位，做题老是出错。 1、整数反转 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。","text":"用力扣做题最坑的是力扣默认用32位系统，而我们平时用的都是64位，做题老是出错。 1、整数反转 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 示例 1: 12输入: 123输出: 321 示例 2: 12输入: -123输出: -321 示例 3: 12输入: 120输出: 21 回答： 123456789int reverse(int x)&#123;long num=0;while(x!=0)&#123; num=num*10+x%10; x=x/10;&#125;return (num&gt;2147483647||num&lt;-2147483648)?0:num;&#125; 2、判断回文数 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例 1: 12输入: 121输出: true 示例 2: 123输入: -121输出: false解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 示例 3: 123输入: 10输出: false解释: 从右向左读, 为 01 。因此它不是一个回文数。 回答： 1234567891011bool isPalindrome(int x)&#123;long num1=x,num2=0;while(num1&gt;0)&#123; num2=num2*10+num1%10; num1/=10;&#125;if(num2==x)return 1;else return 0;&#125;![](https://coding-pages-bucket-3481714-7975552-3088-345232-1303949375.cos-website.ap-hongkong.myqcloud.com/photo/%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E6%95%B0.png/罗马数字转整数.png) 3、罗马数字转整数 罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 12345678字符 数值I 1V 5X 10L 50C 100D 500M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 示例 1: 12输入: &quot;III&quot;输出: 3 示例 2: 12输入: &quot;IV&quot;输出: 4 示例 3: 12输入: &quot;IX&quot;输出: 9 示例 4: 123输入: &quot;LVIII&quot;输出: 58解释: L = 50, V= 5, III = 3. 示例 5: 123输入: &quot;MCMXCIV&quot;输出: 1994解释: M = 1000, CM = 900, XC = 90, IV = 4. 回答： 123456789101112131415161718192021222324int toint(char c)&#123; char roman[7]=&#123;&#x27;I&#x27;,&#x27;V&#x27;,&#x27;X&#x27;,&#x27;L&#x27;,&#x27;C&#x27;,&#x27;D&#x27;,&#x27;M&#x27;&#125;; int number[7]=&#123;1,5,10,50,100,500,1000&#125;; for(int i=0;i&lt;7;i++) &#123; if(c==roman[i]) return number[i]; &#125; return 0;&#125;int romanToInt(char * s)&#123;int len=strlen(s);int a,b;int v=0;for(int i=0;i&lt;len-1;i++)&#123; a=toint(s[i]); b=toint(s[i+1]); v=(a&lt;b)?v-a:v+a;&#125;v+=toint(s[len-1]);return v;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://silenthly.github.io/categories/leetcode/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://silenthly.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"字符判断","slug":"c/第二次笔记","date":"2020-10-31T04:04:34.000Z","updated":"2021-10-27T05:05:22.554Z","comments":true,"path":"2020/10/31/c/第二次笔记/","link":"","permalink":"https://silenthly.github.io/2020/10/31/c/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E7%AC%94%E8%AE%B0/","excerpt":"字符判断题为什么不用ASCII值的范围来判断 1、用ASCII值，你得记住它们才行，记不住容易出错。 2、用单引号括住数字，比用 ASCII值更具有可移植性。因答为用单引号括住数字表示的是这个数字的编码，而编码不一定是ASCII啊。这样，用单引号， 在不使用 ASCII码的环境中，移植这个程序不需要修改源代码。试想，如果要比较一个字符c是否为0。如果用c==48，在不使用ASCII的环境中，如果0的编码是其它数值，岂不是要将48改成这个数值。但如果用单引号，就没有这个问题了。 3、因为这样写，能直观的看出这个是在判断是否为数字。","text":"字符判断题为什么不用ASCII值的范围来判断 1、用ASCII值，你得记住它们才行，记不住容易出错。 2、用单引号括住数字，比用 ASCII值更具有可移植性。因答为用单引号括住数字表示的是这个数字的编码，而编码不一定是ASCII啊。这样，用单引号， 在不使用 ASCII码的环境中，移植这个程序不需要修改源代码。试想，如果要比较一个字符c是否为0。如果用c==48，在不使用ASCII的环境中，如果0的编码是其它数值，岂不是要将48改成这个数值。但如果用单引号，就没有这个问题了。 3、因为这样写，能直观的看出这个是在判断是否为数字。 （判断语句中用了条件判断符，而不是三个&amp;&amp;，是为了防止判断时前后矛盾） 12345678910111213#include&lt;stdio.h&gt;int main()&#123; char ch; ch=getchar(); while(ch!=&#x27;q&#x27;) &#123; if((ch&gt;=&#x27;a&#x27;&amp;&amp;ch&lt;=&#x27;z&#x27;)?(ch&gt;=&#x27;a&#x27;&amp;&amp;ch&lt;=&#x27;z&#x27;):(ch&gt;=&#x27;A&#x27;&amp;&amp;ch&lt;=&#x27;Z&#x27;)) putchar(ch); ch=getchar(); &#125; return 0;&#125;","categories":[{"name":"c","slug":"c","permalink":"https://silenthly.github.io/categories/c/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"hello-world","slug":"c/hello-world","date":"2020-10-31T03:19:23.000Z","updated":"2021-10-27T05:01:12.993Z","comments":true,"path":"2020/10/31/c/hello-world/","link":"","permalink":"https://silenthly.github.io/2020/10/31/c/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"密文加密与解密","slug":"c/密文加密与解密","date":"2020-10-19T09:40:02.000Z","updated":"2021-10-27T05:05:51.745Z","comments":true,"path":"2020/10/19/c/密文加密与解密/","link":"","permalink":"https://silenthly.github.io/2020/10/19/c/%E5%AF%86%E6%96%87%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/","excerpt":"在 main() 函数中使用 while 语句设计一个无限循环，并定义两个字符数组，用来保存，明文和密文字符串，在首次循环中要求用户输入字符串，进行将明文加密成密文的操作， 之后的操作则是根据用户输入的命令字符进行判断，输入 1 加密新的明文，输入 2 对刚加密的密文进行解密，输入3对密文解密，输入4退出系统。","text":"在 main() 函数中使用 while 语句设计一个无限循环，并定义两个字符数组，用来保存，明文和密文字符串，在首次循环中要求用户输入字符串，进行将明文加密成密文的操作， 之后的操作则是根据用户输入的命令字符进行判断，输入 1 加密新的明文，输入 2 对刚加密的密文进行解密，输入3对密文解密，输入4退出系统。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main()&#123; int result; int i; int count=0; char Text[128]=&#123;&#x27;\\0&#x27;&#125;; char cryptograph[128]=&#123;&#x27;\\0&#x27;&#125;; printf(&quot;输入1加密明文（执行1后再输入2），3对密文解密，输入4退出系统：\\n&quot;); scanf(&quot;%d&quot;,&amp;result); while(1) &#123; if(result==1) &#123; printf(&quot;请输入要加密的明文：\\n&quot;); scanf (&quot;%s&quot;,&amp;Text); count=strlen(Text); for(i=0;i&lt;count;i++) &#123; cryptograph[i]=Text[i]+i+5; &#125; cryptograph[i]=&#x27;\\0&#x27;; printf(&quot;加密后的密文是：%s\\n&quot;,cryptograph); &#125; else if(result==2) &#123; count=strlen(Text); for(i=0;i&lt;count;i++) &#123; Text[i]=cryptograph[i]-i-5; &#125; Text[i]=&#x27;\\0&#x27;; printf(&quot;解密后的明文是：%s\\n&quot;,Text); &#125; else if(result==3) &#123; printf(&quot;请输入要解密的密文：&quot;); scanf (&quot;%s&quot;,&amp;Text); count=strlen(Text); for(i=0;i&lt;count;i++) &#123; cryptograph[i]=Text[i]-i-5; &#125; cryptograph[i]=&#x27;\\0&#x27;; printf(&quot;解密后的明文是：%s\\n&quot;,cryptograph); &#125; else if(result==4) &#123; break; &#125; else &#123; printf(&quot;请输入正确的命令符：\\n&quot;); &#125; printf(&quot;输入1加密新的明文，输入2对刚加密的密文进行解密，输入3对密文解密，输入4退出系统：\\n&quot;); printf(&quot;请输入命令符：\\n&quot;); scanf(&quot;%d&quot;,&amp;result); &#125; return 0;&#125;","categories":[{"name":"c","slug":"c","permalink":"https://silenthly.github.io/categories/c/"}],"tags":[]}],"categories":[{"name":"java","slug":"java","permalink":"https://silenthly.github.io/categories/java/"},{"name":"数据结构","slug":"数据结构","permalink":"https://silenthly.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"acm","slug":"acm","permalink":"https://silenthly.github.io/categories/acm/"},{"name":"c","slug":"c","permalink":"https://silenthly.github.io/categories/c/"},{"name":"leetcode","slug":"leetcode","permalink":"https://silenthly.github.io/categories/leetcode/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"杂项","slug":"杂项","permalink":"https://silenthly.github.io/tags/%E6%9D%82%E9%A1%B9/"},{"name":"排序","slug":"排序","permalink":"https://silenthly.github.io/tags/%E6%8E%92%E5%BA%8F/"},{"name":"动态规划","slug":"动态规划","permalink":"https://silenthly.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"贪心算法","slug":"贪心算法","permalink":"https://silenthly.github.io/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"},{"name":"课程设计","slug":"课程设计","permalink":"https://silenthly.github.io/tags/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"},{"name":"刷题","slug":"刷题","permalink":"https://silenthly.github.io/tags/%E5%88%B7%E9%A2%98/"}]}
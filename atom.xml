<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Buyan-Blog</title>
  
  
  <link href="https://silenthly.github.io/atom.xml" rel="self"/>
  
  <link href="https://silenthly.github.io/"/>
  <updated>2021-10-27T00:05:21.010Z</updated>
  <id>https://silenthly.github.io/</id>
  
  <author>
    <name>buyan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>文本组件</title>
    <link href="https://silenthly.github.io/2021/10/18/%E6%96%87%E6%9C%AC%E7%BB%84%E4%BB%B6/"/>
    <id>https://silenthly.github.io/2021/10/18/%E6%96%87%E6%9C%AC%E7%BB%84%E4%BB%B6/</id>
    <published>2021-10-18T14:14:23.000Z</published>
    <updated>2021-10-27T00:05:21.010Z</updated>
    
    <content type="html"><![CDATA[<p>​文本组件用于显示和编辑文本。Swing 支持大多数编辑软件常见的一些编辑功能，如光标的各种移动方式，文本字符、文本行或文本块的选择、插入、删除、拷贝、粘贴等。本文将介绍 JTextField 单行文本组件、JPasswordField 密码框组件和 JTextArea 文本区域组件。</p><h3 id="单行文本组件jtextfield"><a class="markdownIt-Anchor" href="#单行文本组件jtextfield"></a> 单行文本组件：JTextField</h3><p>​<strong>JTextField 单行文本组件允许用户输入一行字符，将需要的字符添加到文本框中</strong>。JTextField 类的常用方法如下表所示。</p><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">方法</th><th style="text-align:center">类型</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">JTextField()</td><td style="text-align:center">构造</td><td style="text-align:center">构造一个新的TextField</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">JTextField(Document doc,String text,int columns)</td><td style="text-align:center">构造</td><td style="text-align:center">构造一个指定文本存储模型，设定初始化字符串并给定列数的JTextField</td></tr><tr><td style="text-align:center"><strong>3</strong></td><td style="text-align:center"><strong>JTextField(int columns)</strong></td><td style="text-align:center"><strong>构造</strong></td><td style="text-align:center"><strong>构造一个具有指定列数的新的空TextField</strong></td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">JTextField(String text)</td><td style="text-align:center">构造</td><td style="text-align:center">构造一个用指定文本初始化的新TextField</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">JTextField(String text,int columns)</td><td style="text-align:center">构造</td><td style="text-align:center">构造一个指定文本和列初始化的新TextField</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">int getColumns()</td><td style="text-align:center">普通</td><td style="text-align:center">返回TextField中的列数</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">void setColumns(Document doc)</td><td style="text-align:center">普通</td><td style="text-align:center">设置此TextField中的列数</td></tr><tr><td style="text-align:center"><strong>8</strong></td><td style="text-align:center"><strong>public String getText()</strong></td><td style="text-align:center"><strong>普通</strong></td><td style="text-align:center"><strong>返回此TextComponent中包含的文本</strong></td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">public void setText(String t)</td><td style="text-align:center">普通</td><td style="text-align:center">将此TextComponent文本设置为指定文本</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">public void setEditable(boolean b)</td><td style="text-align:center">普通</td><td style="text-align:center">设置文本框是否可编辑</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">void setFont(Font t)</td><td style="text-align:center">普通</td><td style="text-align:center">设置当前字体</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">void setDocument(Document doc)</td><td style="text-align:center">普通</td><td style="text-align:center">将编辑器与一个文本文档关联</td></tr></tbody></table><p>​JTextField常用的事件有以下几个。</p><ul><li>TextEvent：当文本内容发生改变时触发</li><li>ActionEvent：用户按下回车后触发</li><li>KeyEvent：在输入框中按下按键时触发</li></ul><h3 id="密码框组件jpasswordfield"><a class="markdownIt-Anchor" href="#密码框组件jpasswordfield"></a> 密码框组件：JPasswordField</h3><p>​JPasswordField 密码框主要用于输入密码，不同于 JTextField，JPasswordField 将输入的字符回显为其他字符。JPasswordField 类的常用方法如下表所示。</p><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">方法</th><th style="text-align:center">类型</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">JPasswordField()</td><td style="text-align:center">构造</td><td style="text-align:center">构造一个空的JPasswordField</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">JPasswordField(Document doc,String txt,int columns)</td><td style="text-align:center">构造</td><td style="text-align:center">构造一个指定文本存储模型，设定初始化字符串并给定列数的JPasswordField</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">JPasswordField(int columns)</td><td style="text-align:center">构造</td><td style="text-align:center">构造一个具有指定列数的JPasswordField</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">JPasswordField(String txt)</td><td style="text-align:center">构造</td><td style="text-align:center">构造一个利用指定文本初始化的JPasswordField</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">JPasswordField(String text,int  columns)</td><td style="text-align:center">构造</td><td style="text-align:center">构造一个利用指定文本和列初始化的JPasswordField</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">char getEchoChar()</td><td style="text-align:center">普通</td><td style="text-align:center">返回用于回显的字符，默认字符为&quot;*&quot;</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">char[] getPassword()</td><td style="text-align:center">普通</td><td style="text-align:center">返回此TextComponent中所包含的文本</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">protected String paramString()</td><td style="text-align:center">普通</td><td style="text-align:center">返回此JPasswordField的字符串表示形式</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">void setEcho(char c)</td><td style="text-align:center">普通</td><td style="text-align:center">设置此JPasswordField的回显字符</td></tr></tbody></table><p>​下面使用 JTextField 组件和 JPasswordField 组件完成一个简单的登录界面。</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.awt.Color;</span><br><span class="line"><span class="keyword">import</span> java.awt.Font;</span><br><span class="line"><span class="keyword">import</span> java.awt.GridLayout;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JPanel;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JButton;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JLabel;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JFrame;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionListener;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionEvent;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JTextField;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JPasswordField;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">连接到数据库</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DatabaseCheck</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DBDRIVER=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DBURL=<span class="string">&quot;jdbc:mysql://localhost:3306/javaTest&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DBPASSWORD=<span class="string">&quot;123456&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DBUSER=<span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String passwd;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DatabaseCheck</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DatabaseCheck</span><span class="params">(String name,String passwd)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">        <span class="keyword">this</span>.passwd=passwd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">connDatabase</span><span class="params">()</span><span class="comment">//连接数据库</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Connection conn=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            Class.forName(DBDRIVER);</span><br><span class="line">            conn=DriverManager.getConnection(DBURL,DBUSER,DBPASSWORD);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;MySQL数据库连接失败！！！&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> conn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    用户登录</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">prepared</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Connection conn=<span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement perstat=<span class="keyword">null</span>;</span><br><span class="line">        ResultSet rs=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            conn=connDatabase();</span><br><span class="line">            String sql=<span class="string">&quot;SELECT name,password FROM StudentUser WHERE name=? and password=?&quot;</span>;</span><br><span class="line">            perstat=conn.prepareStatement(sql);<span class="comment">//执行sql语句</span></span><br><span class="line">            perstat.setString(<span class="number">1</span>,name);</span><br><span class="line">            perstat.setString(<span class="number">2</span>,passwd);</span><br><span class="line">            rs=perstat.executeQuery();</span><br><span class="line">            <span class="keyword">if</span>(rs.next())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">注册用户</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">register</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Connection conn=<span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement perstat=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> rs;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            conn=connDatabase();</span><br><span class="line">            String sql=<span class="string">&quot;INSERT INTO StudentUser (name,password) VALUES (?,?)&quot;</span>;</span><br><span class="line">            perstat=conn.prepareStatement(sql);<span class="comment">//执行sql语句</span></span><br><span class="line">            perstat.setString(<span class="number">1</span>,name);</span><br><span class="line">            perstat.setString(<span class="number">2</span>,passwd);</span><br><span class="line">            rs=perstat.executeUpdate();</span><br><span class="line">            <span class="keyword">if</span>(rs!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">登录界面</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> JLabel userlab=<span class="keyword">new</span> JLabel(<span class="string">&quot;用户名：&quot;</span>,JLabel.CENTER);</span><br><span class="line">    <span class="keyword">private</span> JTextField userText=<span class="keyword">new</span> JTextField(<span class="number">25</span>);</span><br><span class="line">    <span class="keyword">private</span> JLabel passwdlab=<span class="keyword">new</span> JLabel(<span class="string">&quot;密 码： &quot;</span>,JLabel.CENTER);</span><br><span class="line">    <span class="keyword">private</span> JPasswordField passwdText=<span class="keyword">new</span> JPasswordField(<span class="number">25</span>);</span><br><span class="line">    <span class="keyword">private</span> JLabel loginlab=<span class="keyword">new</span> JLabel(<span class="string">&quot;登录状态&quot;</span>,JLabel.CENTER);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        JFrame jf=<span class="keyword">new</span> JFrame(<span class="string">&quot;登录界面&quot;</span>);</span><br><span class="line">        JPanel userPanel=<span class="keyword">new</span> JPanel();</span><br><span class="line">        JPanel passwdPanel=<span class="keyword">new</span> JPanel();</span><br><span class="line">        JPanel buttonPanel=<span class="keyword">new</span> JPanel();</span><br><span class="line">        JPanel labelPanel=<span class="keyword">new</span> JPanel();</span><br><span class="line">        userPanel.add(userlab);</span><br><span class="line">        userPanel.add(userText);</span><br><span class="line">        passwdPanel.add(passwdlab);</span><br><span class="line">        passwdPanel.add(passwdText);</span><br><span class="line">        JButton submit=<span class="keyword">new</span> JButton(<span class="string">&quot;登录&quot;</span>);</span><br><span class="line">        JButton reset=<span class="keyword">new</span> JButton(<span class="string">&quot;注册&quot;</span>);</span><br><span class="line">        buttonPanel.add(submit);</span><br><span class="line">        buttonPanel.add(reset);</span><br><span class="line">        Font font=<span class="keyword">new</span> Font(<span class="string">&quot;楷体&quot;</span>,Font.BOLD+Font.PLAIN,<span class="number">35</span>);</span><br><span class="line">        loginlab.setFont(font);</span><br><span class="line">        loginlab.setForeground(Color.blue);</span><br><span class="line">        labelPanel.add(loginlab);</span><br><span class="line">        submit.addActionListener(<span class="keyword">new</span> ActionListener()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                String user=userText.getText();</span><br><span class="line">                String passwd=<span class="keyword">new</span> String(passwdText.getPassword());</span><br><span class="line">                DatabaseCheck date=<span class="keyword">new</span> DatabaseCheck(user,passwd);</span><br><span class="line">                <span class="keyword">boolean</span> flag=date.prepared();</span><br><span class="line">                <span class="keyword">if</span>(flag)</span><br><span class="line">                &#123;</span><br><span class="line">                    loginlab.setForeground(Color.green);</span><br><span class="line">                    loginlab.setText(<span class="string">&quot;登录成功！！！&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    loginlab.setForeground(Color.red);</span><br><span class="line">                    loginlab.setText(<span class="string">&quot;登录失败！！！&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                passwdText.setText(<span class="string">&quot;&quot;</span>); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        reset.addActionListener(<span class="keyword">new</span> ActionListener()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                String user=userText.getText();</span><br><span class="line">                String passwd=<span class="keyword">new</span> String(passwdText.getPassword());</span><br><span class="line">                DatabaseCheck date=<span class="keyword">new</span> DatabaseCheck(user,passwd);</span><br><span class="line">                <span class="keyword">boolean</span> flag=date.register();</span><br><span class="line">                <span class="keyword">if</span>(flag)</span><br><span class="line">                &#123;</span><br><span class="line">                    loginlab.setForeground(Color.green);</span><br><span class="line">                    loginlab.setText(<span class="string">&quot;注册成功！！！&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    loginlab.setForeground(Color.red);</span><br><span class="line">                    loginlab.setText(<span class="string">&quot;注册失败！！！&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                passwdText.setText(<span class="keyword">null</span>); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        jf.setLayout(<span class="keyword">new</span> GridLayout(<span class="number">4</span>,<span class="number">1</span>));</span><br><span class="line">        jf.add(userPanel);</span><br><span class="line">        jf.add(passwdPanel);</span><br><span class="line">        jf.add(buttonPanel);</span><br><span class="line">        jf.add(labelPanel);</span><br><span class="line">        jf.setSize(<span class="number">400</span>,<span class="number">200</span>);</span><br><span class="line">        jf.setLocation(<span class="number">250</span>,<span class="number">300</span>);</span><br><span class="line">        jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); </span><br><span class="line">        jf.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://silenthty.gitee.io/photo/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/GUIx11.png" alt="" /></p><p><img src="https://silenthty.gitee.io/photo/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/GUIx8.png" alt="" /></p><p><img src="https://silenthty.gitee.io/photo/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/GUIx9.png" alt="" /></p><p><img src="https://silenthty.gitee.io/photo/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/GUIx10.png" alt="" /></p><p>​在以上程序中，只要输入 StudentUser 数据表中存在的用户，即可登录成功。窗体上的文本框和密码框分别接收用户名和密码，当单击“登录”按钮时，触发 ActionEvent 事件， 从文本框和密码框读取内容并通过 DatabaseCheck 类进行验证，并且将密码框的内容清空。当单击“登录”按钮时，触发 ActionEvent 事件，从文本框和密码框读取内容并通过 DatabaseCheck 类对数据库输入数据进行注册，并且将密码框的内容清空。</p><h3 id="文本区域组件jtextarea"><a class="markdownIt-Anchor" href="#文本区域组件jtextarea"></a> 文本区域组件：JTextArea</h3><p>​JTextField 文本框只允许用户输入一行信息，JTextArea 文本区域组件可以允许用户输入多行信息。JTextArea 类的常用方法如下表所示。</p><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">方法</th><th style="text-align:center">类型</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">JTextArea()</td><td style="text-align:center">构造</td><td style="text-align:center">构造新的JTextArea</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">JTextArea(Document doc)</td><td style="text-align:center">构造</td><td style="text-align:center">构造一个指定的文件存储模式的JTextArea</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">JTextArea(Document doc,String txt,int rows,int columns)</td><td style="text-align:center">构造</td><td style="text-align:center">构造一个指定的文件存储模式，设置其初始文本并具有指定行数和列数的JTextArea</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">JTextArea(int rows,int columns)</td><td style="text-align:center">构造</td><td style="text-align:center">构造具有指定行数和列数的JTextArea</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">JTextArea(String txt)</td><td style="text-align:center">构造</td><td style="text-align:center">构造显示指定文本的TextArea</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">JTextArea(String txt,int rows,int columns)</td><td style="text-align:center">构造</td><td style="text-align:center">构造具有指定文本、行数和列数的新的JTextArea</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">void append(String str)</td><td style="text-align:center">普通</td><td style="text-align:center">将给定文本追加到文档结尾</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">void setColumns()</td><td style="text-align:center">普通</td><td style="text-align:center">设置此 TextArea 中的列数</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">int getColumns()</td><td style="text-align:center">普通</td><td style="text-align:center">返回此 TextArea 中的列数</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">void setRows()</td><td style="text-align:center">普通</td><td style="text-align:center">设置此 TextArea 中的行数</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">int getRows()</td><td style="text-align:center">普通</td><td style="text-align:center">返回此 TextArea 中的行数</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">void setFont(Font f)</td><td style="text-align:center">普通</td><td style="text-align:center">设置当前字体</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">int getLineCount()</td><td style="text-align:center">普通</td><td style="text-align:center">返回此文本区中所包含的行数</td></tr><tr><td style="text-align:center">14</td><td style="text-align:center">void insert(String str,int pos)</td><td style="text-align:center">普通</td><td style="text-align:center">将指定文本插入指定位置</td></tr><tr><td style="text-align:center">15</td><td style="text-align:center">void replaceRange(String str,int start,int end)</td><td style="text-align:center">普通</td><td style="text-align:center">用给定的新文本替换从指示的起始位置到结尾位置的文本</td></tr><tr><td style="text-align:center">16</td><td style="text-align:center">void setLineWrap(boolean wrap)</td><td style="text-align:center">普通</td><td style="text-align:center">设置文本区中是否自动换行，若wrap为true，则自动换行，否则不自动换行，默认为false</td></tr></tbody></table><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.JTextArea;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JFrame;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JScrollPane;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        JFrame jf=<span class="keyword">new</span> JFrame(<span class="string">&quot;JTextArea组件&quot;</span>);</span><br><span class="line">        JTextArea text=<span class="keyword">new</span> JTextArea(<span class="number">8</span>,<span class="number">25</span>);</span><br><span class="line">        text.setLineWrap(<span class="keyword">true</span>);</span><br><span class="line">        JScrollPane scroll=<span class="keyword">new</span> JScrollPane(text);</span><br><span class="line">        jf.add(scroll);</span><br><span class="line">        jf.pack();</span><br><span class="line">        jf.setLocation(<span class="number">400</span>,<span class="number">400</span>);</span><br><span class="line">        jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">        jf.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://silenthty.gitee.io/photo/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/GUIx7.png" alt="" /></p><p>参考书目：</p><p><a href="http://product.dangdang.com/23248198.html?ref=book-35530-3032_5-231497-4">《Java编程手记——从实践中学习Java（配光盘）》(欧二强　等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​		文本组件用于显示和编辑文本。Swing 支持大多数编辑软件常见的一些编辑功能，如光标的各种移动方式，文本字符、文本行或文本块的选择、插入、删除、拷贝、粘贴等。本文将介绍 JTextField 单行文本组件、JPasswordField 密码框组件和 JTextArea</summary>
      
    
    
    
    <category term="java" scheme="https://silenthly.github.io/categories/java/"/>
    
    
    <category term="笔记" scheme="https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>布局管理器</title>
    <link href="https://silenthly.github.io/2021/10/17/%E5%B8%83%E5%B1%80%E7%AE%A1%E7%90%86%E5%99%A8/"/>
    <id>https://silenthly.github.io/2021/10/17/%E5%B8%83%E5%B1%80%E7%AE%A1%E7%90%86%E5%99%A8/</id>
    <published>2021-10-17T14:14:23.000Z</published>
    <updated>2021-10-19T01:54:45.459Z</updated>
    
    <content type="html"><![CDATA[<p>​在图形用户界面程序中往往要使用众多的GUI组件，需要将这些组件合理地放置到容器中。这就需要对这些组件的布置进行管理，可以使用布局管理器的类来排列界面上的组件。</p><h3 id="流式布局管理器flowlayout"><a class="markdownIt-Anchor" href="#流式布局管理器flowlayout"></a> 流式布局管理器：FlowLayout</h3><p>​FlowLayout 布局管理器是 JPanel 容器的默认布局管理器，该布局管理器是最简单的一种布局管理器，其排列方式是以容器中的组件大小为首选尺寸，按顺序向容器中添加组件，当一行放不下所有组件时，自动折为多行。在创建 FlowLayout 布局管理器时，可设置一行组件的对齐方式，默认为中间对齐，也可设置为左、右对齐。FlowLayout 类的常用常量和方法如下表所示。</p><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">方法</th><th style="text-align:center">类型</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">static int CENTER</td><td style="text-align:center">常量</td><td style="text-align:center">每一行组件都应该是居中的</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">static int LEADING</td><td style="text-align:center">常量</td><td style="text-align:center">每一行组件都应该与容器方向的开始边对齐</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">static int LEFT</td><td style="text-align:center">常量</td><td style="text-align:center">每一行组件都应该是左对齐的</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">static int RIGHT</td><td style="text-align:center">常量</td><td style="text-align:center">每一行组件都应该是右对齐的</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">static int TRALING</td><td style="text-align:center">常量</td><td style="text-align:center">每一行组件都应该与容器方向的结束边对齐</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">FlowLayout()</td><td style="text-align:center">构造</td><td style="text-align:center">钩针一个新的FlowLayout，它是居中对齐的，默认的水平和垂直间距是5个单位</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">FlowLayout(int align)</td><td style="text-align:center">构造</td><td style="text-align:center">钩针一个新的FlowLayout，它具有指定的对齐方式，默认的水平和垂直间距是5个单位</td></tr><tr><td style="text-align:center"><strong>8</strong></td><td style="text-align:center"><strong>FlowLayout(itn align,int hgap,int vgap)</strong></td><td style="text-align:center"><strong>构造</strong></td><td style="text-align:center"><strong>钩针一个新的FlowLayout，它具有指定的对齐方式，及指定的水平和垂直间距</strong></td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">int getHgap()</td><td style="text-align:center">普通</td><td style="text-align:center">获取组件之间及组件与容器的边之间的水平间距</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">int getVgap()</td><td style="text-align:center">普通</td><td style="text-align:center">获取组件之间及组件与容器的边之间的垂直间距</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">void setHgap(int Hgap)</td><td style="text-align:center">普通</td><td style="text-align:center">设置组件之间及组件与容器的边之间的水平间距</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">void setVgap(int vgap)</td><td style="text-align:center">普通</td><td style="text-align:center">设置组件之间及组件与容器的边之间的垂直间距</td></tr></tbody></table><blockquote><p>提示：间距单位为像素</p></blockquote><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.FlowLayout;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JFrame;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JButton;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JPanel;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        JFrame jf=<span class="keyword">new</span> JFrame(<span class="string">&quot;FlowLayout布局窗口&quot;</span>);</span><br><span class="line">        FlowLayout flow=<span class="keyword">new</span> FlowLayout(FlowLayout.LEFT,<span class="number">5</span>,<span class="number">5</span>);</span><br><span class="line">        JPanel panel=<span class="keyword">new</span> JPanel(flow);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            panel.add(<span class="keyword">new</span> JButton(<span class="string">&quot;按钮&quot;</span>+i));</span><br><span class="line">        &#125;</span><br><span class="line">        jf.add(panel);</span><br><span class="line">        jf.setSize(<span class="number">235</span>,<span class="number">150</span>);</span><br><span class="line">        jf.setLocation(<span class="number">250</span>,<span class="number">300</span>);</span><br><span class="line">        jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">        jf.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://silenthty.gitee.io/photo/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/GUI9.png" alt="" /></p><p>​其实 JPanel 面板默认的布局管理器就是 FlowLayout。从程序的运行结果可以发现，按钮组件的从左到右从上到下顺序排序的。若使用 pack() 方法替代 setSize(235,150)，则显示结果如下图所示：</p><p><img src="https://silenthty.gitee.io/photo/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/GUI10.png" alt="" /></p><h3 id="边界布局管理器borderlayout"><a class="markdownIt-Anchor" href="#边界布局管理器borderlayout"></a> 边界布局管理器：BorderLayout</h3><p>​BorderLayout 是JFrame、JWindow、JDialog、JInternalFrame 及 JApplet 的默认布局管理器。边界布局管理器使用类 BorderLayout 将容器划分为东、西、南、北和中5个区域，每个区域可放置一个组件。中央区域通常放置比较大的组件，而其他其余放置比较小的组件。BorderLayout 类的常用常量和方法如下表所示。</p><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">方法</th><th style="text-align:center">类型</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><strong>1</strong></td><td style="text-align:center"><strong>static String CENTER</strong></td><td style="text-align:center"><strong>常量</strong></td><td style="text-align:center"><strong>将组件设置在中间区域</strong></td></tr><tr><td style="text-align:center"><strong>2</strong></td><td style="text-align:center"><strong>static String EAST</strong></td><td style="text-align:center"><strong>常量</strong></td><td style="text-align:center"><strong>将组件设置在东区域</strong></td></tr><tr><td style="text-align:center"><strong>3</strong></td><td style="text-align:center"><strong>static String NORTH</strong></td><td style="text-align:center"><strong>常量</strong></td><td style="text-align:center"><strong>将组件设置在北区域</strong></td></tr><tr><td style="text-align:center"><strong>4</strong></td><td style="text-align:center"><strong>static String SOUTH</strong></td><td style="text-align:center"><strong>常量</strong></td><td style="text-align:center"><strong>将组件设置在南区域</strong></td></tr><tr><td style="text-align:center"><strong>5</strong></td><td style="text-align:center"><strong>static String WEST</strong></td><td style="text-align:center"><strong>常量</strong></td><td style="text-align:center"><strong>将组件设置在西区域</strong></td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">BorderLayout()</td><td style="text-align:center">构造</td><td style="text-align:center">构造一个组件之间没有间距的新边框布局</td></tr><tr><td style="text-align:center"><strong>7</strong></td><td style="text-align:center"><strong>BorderLayout(int hgap,int vgap)</strong></td><td style="text-align:center"><strong>构造</strong></td><td style="text-align:center"><strong>构造一个具有指定组件间距的边框布局</strong></td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">float getLayoutAlignmentX(Container parent)</td><td style="text-align:center">普通</td><td style="text-align:center">返回沿X轴的对齐方式</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">float getLayoutAlignmentY(Container parent)</td><td style="text-align:center">普通</td><td style="text-align:center">返回沿Y轴的对齐方式</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">void removeLayoutComponent(Container comp)</td><td style="text-align:center">普通</td><td style="text-align:center">从此边框布局中移除指定组件</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">int getHgap()</td><td style="text-align:center">普通</td><td style="text-align:center">返回组件之间的水平间距</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">int getVgap()</td><td style="text-align:center">普通</td><td style="text-align:center">返回组件之间的垂直间距</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">void setHgap(int Hgap)</td><td style="text-align:center">普通</td><td style="text-align:center">设置组件之间的水平间距</td></tr><tr><td style="text-align:center">14</td><td style="text-align:center">void setVgap(int vgap)</td><td style="text-align:center">普通</td><td style="text-align:center">设置组件之间的垂直间距</td></tr></tbody></table><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.BorderLayout;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JFrame;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JButton;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JPanel;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        JFrame jf=<span class="keyword">new</span> JFrame(<span class="string">&quot;BoderLayout布局管理器&quot;</span>);</span><br><span class="line">        BorderLayout border=<span class="keyword">new</span> BorderLayout(<span class="number">5</span>,<span class="number">5</span>);</span><br><span class="line">        JPanel panel=<span class="keyword">new</span> JPanel(border);</span><br><span class="line">        panel.add(<span class="keyword">new</span> JButton(<span class="string">&quot;东（EAST）&quot;</span>),BorderLayout.EAST);</span><br><span class="line">        panel.add(<span class="keyword">new</span> JButton(<span class="string">&quot;南（SOUTH）&quot;</span>),BorderLayout.SOUTH);</span><br><span class="line">        panel.add(<span class="keyword">new</span> JButton(<span class="string">&quot;西（WEST）&quot;</span>),BorderLayout.WEST);</span><br><span class="line">        panel.add(<span class="keyword">new</span> JButton(<span class="string">&quot;北（NORTH）&quot;</span>),BorderLayout.NORTH);</span><br><span class="line">        panel.add(<span class="keyword">new</span> JButton(<span class="string">&quot;中（CENTER）&quot;</span>),BorderLayout.CENTER);</span><br><span class="line">        jf.add(panel);</span><br><span class="line">        jf.setSize(<span class="number">400</span>,<span class="number">300</span>);</span><br><span class="line">        jf.setLocation(<span class="number">250</span>,<span class="number">300</span>);</span><br><span class="line">        jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">        jf.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://silenthty.gitee.io/photo/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/GUI11.png" alt="" /></p><h3 id="网格布局管理器gridlayout"><a class="markdownIt-Anchor" href="#网格布局管理器gridlayout"></a> 网格布局管理器：GridLayout</h3><p>​GridLayout 布局管理器将容器划分为指定行数、列数的单元格，每个单元格都有相同的尺寸，可以放置一个组件，该组件占据单元个的整个空间。使用 GridLayout 布局管理器向容器中添加组件时，默认是从左到右、从上到下依次添加到每一个表格中。与  FlowLayout 不同的是，<strong>GridLayout 布局管理器中的各个组件的大小由组件所在的网格大小决定</strong>，每一个组件都会自动调整为沾满整个表格。GridLayout 类的常用方法如下表所示。</p><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">方法</th><th style="text-align:center">类型</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">GridLayout()</td><td style="text-align:center">构造</td><td style="text-align:center">创建具有默认的网格布局管理器，即每个组件占据一行一列</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">GridLayout(int rows,int cols)</td><td style="text-align:center">构造</td><td style="text-align:center">创建具有指定行数和列数的网络布局管理器</td></tr><tr><td style="text-align:center"><strong>3</strong></td><td style="text-align:center"><strong>GridLayout(int rows,int cols,int hgap,int vgap)</strong></td><td style="text-align:center"><strong>构造</strong></td><td style="text-align:center"><strong>创建具有指定行数和列数的网络布局管理器</strong></td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">void addLayoutComponent(String name,Component comp)</td><td style="text-align:center">普通</td><td style="text-align:center">将具有指定名称的指定组件添加到网格布局管理器</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">int getColumns()</td><td style="text-align:center">普通</td><td style="text-align:center">获取此网格布局管理器中的列数</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">int getRows()</td><td style="text-align:center">普通</td><td style="text-align:center">获取此网格布局管理器中的行数</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">int getHgap()</td><td style="text-align:center">普通</td><td style="text-align:center">获取组件之间的水平间距</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">int getVgap()</td><td style="text-align:center">普通</td><td style="text-align:center">获取组件之间的垂直间距</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">void removeLayoutComponent(Component comp)</td><td style="text-align:center">普通</td><td style="text-align:center">从网格布局管理器中移除指定组件</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">void setColumns(int cols)</td><td style="text-align:center">普通</td><td style="text-align:center">将此网格布局管理器中的列数设置为指定值</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">void setRows(int rows)</td><td style="text-align:center">普通</td><td style="text-align:center">将此网格布局管理器中的列数设置为指定值</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">void setHgap(int hgap)</td><td style="text-align:center">普通</td><td style="text-align:center">将组件之间的水平间距设置为指定值</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">void setVgap(int vgap)</td><td style="text-align:center">普通</td><td style="text-align:center">将组件之间的垂直间距设置为指定值</td></tr></tbody></table><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.GridLayout;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JFrame;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JPanel;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JButton;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        JFrame jf=<span class="keyword">new</span> JFrame(<span class="string">&quot;GridLayout布局管理器&quot;</span>);</span><br><span class="line">        GridLayout grid=<span class="keyword">new</span> GridLayout(<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>);</span><br><span class="line">        JPanel panel=<span class="keyword">new</span> JPanel(grid);</span><br><span class="line">        String str[]=&#123;<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;x&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;5&quot;</span>,<span class="string">&quot;6&quot;</span>,<span class="string">&quot;÷&quot;</span>,<span class="string">&quot;7&quot;</span>,<span class="string">&quot;8&quot;</span>,<span class="string">&quot;9&quot;</span>,<span class="string">&quot;+&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;—&quot;</span>,<span class="string">&quot;=&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            panel.add(<span class="keyword">new</span> JButton(str[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        jf.add(panel);</span><br><span class="line">        jf.setSize(<span class="number">400</span>,<span class="number">300</span>);</span><br><span class="line">        jf.setLocation(<span class="number">250</span>,<span class="number">300</span>);</span><br><span class="line">        jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">        jf.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://silenthty.gitee.io/photo/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/GUI12.png" alt="" /></p><h3 id="网格包布局管理器gridbaglayout"><a class="markdownIt-Anchor" href="#网格包布局管理器gridbaglayout"></a> 网格包布局管理器：GridBagLayout</h3><p>​GridBagLayout 可以说是 GridBagLayout 的增强版本，是所有布局管理器中功能最强大也是最复杂的。GridBagLayout 网格包布局管理器将容器划分为指定行数、列数的单元格，每个单元格有相同的尺寸。组件可以放置在一个单元格中，也可以跨行或跨列放置在多个单元格中。</p><p>​在向 GridBagLayout 布局管理器的容器中添加组件时，需要为每个组件创建一个与之关联的 GridBagConstraints 对象。通过该类中的属性可以设置组件的布局信息，如组件在网格中位于第几行、第几列，以及需要占用几行几列等。GridBagConstraints  的对象可设置的实例变量如下表所示。</p><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">方法</th><th style="text-align:center">类型</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">static int CENTER</td><td style="text-align:center">常量</td><td style="text-align:center">将组件置于其显示区域的中部</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">static int EAST</td><td style="text-align:center">常量</td><td style="text-align:center">将组件置于其显示区域的东边，即右部</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">static int NORTH</td><td style="text-align:center">常量</td><td style="text-align:center">将组件置于其显示区域的南边，即底部</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">static int WEST</td><td style="text-align:center">常量</td><td style="text-align:center">将组件置于其显示区域的西边，即左部</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">static int SOUTH</td><td style="text-align:center">常量</td><td style="text-align:center">将组件置于其显示区域的北边，即顶部</td></tr><tr><td style="text-align:center"><strong>6</strong></td><td style="text-align:center"><strong>int fill</strong></td><td style="text-align:center"><strong>变量</strong></td><td style="text-align:center"><strong>组件填充网格的方式</strong></td></tr><tr><td style="text-align:center"><strong>7</strong></td><td style="text-align:center"><strong>int gridhwidth</strong></td><td style="text-align:center"><strong>变量</strong></td><td style="text-align:center"><strong>指定组件显示占据的单元表格列数</strong></td></tr><tr><td style="text-align:center"><strong>8</strong></td><td style="text-align:center"><strong>int gridheight</strong></td><td style="text-align:center"><strong>变量</strong></td><td style="text-align:center"><strong>指定组件显示占据的单元表格行数</strong></td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">int gridx</td><td style="text-align:center">变量</td><td style="text-align:center">指定包含组件的显示区域开始边的单元格，其中一行的第一个单元格(本行第一列)为gridx=0，默认值为RELATIVE</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">int gridy</td><td style="text-align:center">变量</td><td style="text-align:center">指定包含组件的显示区域顶部的单元格，其中最上边的单元格(本行第一行)为gridy=0，默认值为RELATIVE</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">static int HORIZONTAL</td><td style="text-align:center">常量</td><td style="text-align:center">增加组件宽度,使其水平填充显示区域</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">static int VERTICAL</td><td style="text-align:center">常量</td><td style="text-align:center">增加组件高度,使其垂直填充显示区域</td></tr><tr><td style="text-align:center"><strong>13</strong></td><td style="text-align:center"><strong>double weightx</strong></td><td style="text-align:center"><strong>变量</strong></td><td style="text-align:center"><strong>当窗口放大时，组件长度变化</strong></td></tr><tr><td style="text-align:center"><strong>14</strong></td><td style="text-align:center"><strong>double weighty</strong></td><td style="text-align:center"><strong>变量</strong></td><td style="text-align:center"><strong>当窗口放大时，组件高度变化</strong></td></tr><tr><td style="text-align:center">15</td><td style="text-align:center">Insets insets</td><td style="text-align:center">变量</td><td style="text-align:center">此字段指定组件的外部填充，即组件与其显示区域边缘之间间距的最小值</td></tr><tr><td style="text-align:center"><strong>16</strong></td><td style="text-align:center"><strong>static int RELATIVE</strong></td><td style="text-align:center"><strong>常量</strong></td><td style="text-align:center"><strong>指定此组件是其列或行中的倒数第二个单元格( gridwidth, gridheight)，或将此组件放置在先前添加的组件旁边(gridx, gridy)</strong></td></tr><tr><td style="text-align:center"><strong>17</strong></td><td style="text-align:center"><strong>static int REMAINDER</strong></td><td style="text-align:center"><strong>常量</strong></td><td style="text-align:center"><strong>指定此组件占据本行或列的所有剩余空间</strong></td></tr><tr><td style="text-align:center"><strong>18</strong></td><td style="text-align:center"><strong>static int BOTH</strong></td><td style="text-align:center"><strong>常量</strong></td><td style="text-align:center"><strong>使组件填充整个显示区域</strong></td></tr></tbody></table><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.GridBagLayout;</span><br><span class="line"><span class="keyword">import</span> java.awt.GridBagConstraints;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JFrame;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JButton;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JLabel;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    JFrame jf;</span><br><span class="line">    GridBagLayout gridbag;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">makeButton</span><span class="params">(String name,GridBagLayout gridbag,GridBagConstraints c)</span><span class="comment">//根据设置的属性将创建的按钮添加到单元格中</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        JButton btn=<span class="keyword">new</span> JButton(name);</span><br><span class="line">        gridbag.setConstraints(btn,c);</span><br><span class="line">        jf.add(btn);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        GridBagConstraints c=<span class="keyword">new</span> GridBagConstraints();</span><br><span class="line">        gridbag=<span class="keyword">new</span> GridBagLayout();</span><br><span class="line">        jf=<span class="keyword">new</span> JFrame(<span class="string">&quot;GridBagLayout布局管理器&quot;</span>);</span><br><span class="line">        jf.setLayout(gridbag);<span class="comment">//设置指定的布局管理器</span></span><br><span class="line">        c.fill=GridBagConstraints.BOTH;<span class="comment">//指定组件填充整个显示区域</span></span><br><span class="line">        c.weightx=<span class="number">1.0</span>;</span><br><span class="line">        makeButton(<span class="string">&quot;按钮-A&quot;</span>,gridbag,c);</span><br><span class="line">        makeButton(<span class="string">&quot;按钮-B&quot;</span>,gridbag,c);</span><br><span class="line">        makeButton(<span class="string">&quot;按钮-C&quot;</span>,gridbag,c);</span><br><span class="line">        c.gridwidth=GridBagConstraints.REMAINDER;<span class="comment">//将组件作为末尾</span></span><br><span class="line">        makeButton(<span class="string">&quot;按钮-D&quot;</span>,gridbag,c);</span><br><span class="line">        c.weightx=<span class="number">0.0</span>;</span><br><span class="line">        makeButton(<span class="string">&quot;按钮-E&quot;</span>,gridbag,c);</span><br><span class="line">        c.gridwidth=GridBagConstraints.RELATIVE;<span class="comment">//将组件添加行或列的倒数第二个单元格</span></span><br><span class="line">        makeButton(<span class="string">&quot;按钮-F&quot;</span>,gridbag,c);</span><br><span class="line">        c.gridwidth=GridBagConstraints.REMAINDER;<span class="comment">//将下方的第一个组件作为末尾</span></span><br><span class="line">        makeButton(<span class="string">&quot;按钮-G&quot;</span>,gridbag,c);</span><br><span class="line">        c.gridwidth=<span class="number">1</span>;</span><br><span class="line">        c.gridheight=<span class="number">2</span>;</span><br><span class="line">        c.weighty=<span class="number">1.0</span>;</span><br><span class="line">        makeButton(<span class="string">&quot;按钮-H&quot;</span>,gridbag,c);</span><br><span class="line">        c.weighty=<span class="number">0.0</span>;</span><br><span class="line">        c.gridwidth=GridBagConstraints.REMAINDER;</span><br><span class="line">        c.gridheight=<span class="number">1</span>;</span><br><span class="line">        makeButton(<span class="string">&quot;按钮-I&quot;</span>,gridbag,c);</span><br><span class="line">        makeButton(<span class="string">&quot;按钮-J&quot;</span>,gridbag,c);</span><br><span class="line">        jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">        jf.setSize(<span class="number">400</span>,<span class="number">180</span>);</span><br><span class="line">        jf.setLocation(<span class="number">250</span>,<span class="number">300</span>);</span><br><span class="line">        jf.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://silenthty.gitee.io/photo/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/GUI13.png" alt="" /></p><p>​从程序中可以看出 GridBagLayout 的使用非常复杂，如果参数设置地不正确，则得到的图形就会与设计者想象的相距甚远。</p><h3 id="卡片布局管理器cardlayout"><a class="markdownIt-Anchor" href="#卡片布局管理器cardlayout"></a> 卡片布局管理器：CardLayout</h3><p>​CardLayout 卡片布局管理器支持容器中的两个或多个组件共享同一空间。在同一位置放置的组件只有一个可见，只有最外面的一个组件可以被看到，也可以通过指定组件名或遍历组件等方式指定显示哪一组件。CardLayout 类的常用方法如下表所示。</p><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">方法</th><th style="text-align:center">类型</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">CardLayout()</td><td style="text-align:center">构造</td><td style="text-align:center">创建一个间距大小为0的卡片布局管理器</td></tr><tr><td style="text-align:center"><strong>2</strong></td><td style="text-align:center"><strong>CardLayout(int hgap,int vgap)</strong></td><td style="text-align:center"><strong>构造</strong></td><td style="text-align:center"><strong>创建一个具有指定水平间距和垂直间距的卡片布局管理器</strong></td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">void first(Container parent)</td><td style="text-align:center">普通</td><td style="text-align:center">翻转到容器的第一张卡片</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">int setHgap()</td><td style="text-align:center">普通</td><td style="text-align:center">设置组件之间的水平间距</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">int setVgap()</td><td style="text-align:center">普通</td><td style="text-align:center">设置组件之间的垂直间距</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">int getHgap()</td><td style="text-align:center">普通</td><td style="text-align:center">获取组件之间的水平间距</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">int getVgap()</td><td style="text-align:center">普通</td><td style="text-align:center">获取组件之间的垂直间距</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">float getLayoutAlignmentX(Container parent)</td><td style="text-align:center">普通</td><td style="text-align:center">返回沿x轴的对齐方式</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">float getLayoutAlignmentY(Container parent)</td><td style="text-align:center">普通</td><td style="text-align:center">返回沿y轴的对齐方式</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">void last(Container parent)</td><td style="text-align:center">普通</td><td style="text-align:center">翻转到容器的最后一张卡片</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">void layoutContainer(Container parent)</td><td style="text-align:center">普通</td><td style="text-align:center">使用此卡片布局管理器布置指定的容器</td></tr><tr><td style="text-align:center"><strong>12</strong></td><td style="text-align:center"><strong>void next(Container parent)</strong></td><td style="text-align:center"><strong>普通</strong></td><td style="text-align:center"><strong>翻转到指定容器的下一张卡片</strong></td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">void removeLayoutComponent(Component comp)</td><td style="text-align:center">普通</td><td style="text-align:center">从卡片布局管理器中移除指定的组件</td></tr><tr><td style="text-align:center">14</td><td style="text-align:center">void show(Container parent,String name)</td><td style="text-align:center">普通</td><td style="text-align:center">显示具有指定组件名称的卡片</td></tr></tbody></table><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.CardLayout;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JFrame;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JPanel;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JLabel;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JButton;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        JFrame jf=<span class="keyword">new</span> JFrame(<span class="string">&quot;CardLayout 布局管理器&quot;</span>);</span><br><span class="line">        CardLayout card=<span class="keyword">new</span> CardLayout(<span class="number">5</span>,<span class="number">5</span>);</span><br><span class="line">        JPanel panel=<span class="keyword">new</span> JPanel(card);</span><br><span class="line">        panel.add(<span class="keyword">new</span> JLabel(<span class="string">&quot;第一张标签&quot;</span>),JLabel.CENTER);</span><br><span class="line">        panel.add(<span class="keyword">new</span> JLabel(<span class="string">&quot;第二张标签&quot;</span>),JLabel.CENTER);</span><br><span class="line">        panel.add(<span class="keyword">new</span> JLabel(<span class="string">&quot;第三张标签&quot;</span>),JLabel.CENTER);</span><br><span class="line">        panel.add(<span class="keyword">new</span> JLabel(<span class="string">&quot;第四张标签&quot;</span>),JLabel.CENTER);</span><br><span class="line">        panel.add(<span class="keyword">new</span> JLabel(<span class="string">&quot;第五张标签&quot;</span>),JLabel.CENTER);</span><br><span class="line">        jf.add(panel);</span><br><span class="line">        jf.setSize(<span class="number">200</span>,<span class="number">100</span>);</span><br><span class="line">        jf.setLocation(<span class="number">250</span>,<span class="number">300</span>);</span><br><span class="line">        jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">        jf.setVisible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)</span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            card.next(panel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://silenthty.gitee.io/photo/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/GUI14.png" alt="" /></p><p><img src="https://silenthty.gitee.io/photo/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/GUI15.png" alt="" /></p><p><img src="https://silenthty.gitee.io/photo/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/GUI16.png" alt="" /></p><p>​以上程序展现了部分结果，可以发现，并不是按照加入的顺序显示标签的，因为在程序中使用 了 Thread.sleep()方法。</p><h3 id="绝对定位"><a class="markdownIt-Anchor" href="#绝对定位"></a> 绝对定位</h3><p>​绝对定位使用 Component 中提供的 setBounds() 方法设置组件的位置和占用的空间，但在 GUI 程序使用的组件繁多时，绝对定位很难恰当地布置组件，在此建议使用 swing 提供的布局管理器。</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.Font;</span><br><span class="line"><span class="keyword">import</span> java.awt.Color;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JButton;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JFrame;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JLabel;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        JFrame jf=<span class="keyword">new</span> JFrame(<span class="string">&quot;绝对定位&quot;</span>);</span><br><span class="line">        JButton button1=<span class="keyword">new</span> JButton(<span class="string">&quot;按钮1&quot;</span>);</span><br><span class="line">        JButton button2=<span class="keyword">new</span> JButton(<span class="string">&quot;按钮2&quot;</span>);</span><br><span class="line">        JLabel label=<span class="keyword">new</span> JLabel(<span class="string">&quot;标签A&quot;</span>,JLabel.CENTER);</span><br><span class="line">        Font font=<span class="keyword">new</span> Font(<span class="string">&quot;楷体&quot;</span>,Font.BOLD+Font.PLAIN,<span class="number">20</span>);</span><br><span class="line">        label.setFont(font);</span><br><span class="line">        label.setForeground(Color.blue);</span><br><span class="line">        jf.setLayout(<span class="keyword">null</span>);<span class="comment">//这只布局管理器为null</span></span><br><span class="line">        button1.setBounds(<span class="number">5</span>,<span class="number">40</span>,<span class="number">80</span>,<span class="number">30</span>);</span><br><span class="line">        label.setBounds(<span class="number">90</span>,<span class="number">40</span>,<span class="number">80</span>,<span class="number">30</span>);</span><br><span class="line">        button2.setBounds(<span class="number">175</span>,<span class="number">40</span>,<span class="number">80</span>,<span class="number">30</span>);</span><br><span class="line">        jf.add(button1);</span><br><span class="line">        jf.add(button2);</span><br><span class="line">        jf.add(label);</span><br><span class="line">        jf.setSize(<span class="number">280</span>,<span class="number">150</span>);</span><br><span class="line">        jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">        jf.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://silenthty.gitee.io/photo/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/GUI17.png" alt="" /></p><p>​在绝对定位时，不论窗体的大小如何改变，组件的大小和位置都是固定不变的。而使用其他的布局管理器时，若窗体大小改变，则组件的大小和位置也会改变。</p><p>参考链接：</p><p><a href="https://www.cnblogs.com/fancongcong/p/4977636.html">GridBagConstraints详解 - 樊聪 - 博客园 (cnblogs.com)</a></p><p><a href="https://blog.csdn.net/shilonggang000/article/details/8350589">JAVA布局模式：GridBagConstraints终极技巧_shilonggang000的专栏-CSDN博客</a></p><p><a href="https://blog.csdn.net/zsy_gemini/article/details/4049078">JAVA布局管理器_璀璨星空-CSDN博客</a></p><p><a href="https://blog.csdn.net/ddupd/article/details/18777847">java布局之GridBagLayout_eskimoer的专栏-CSDN博客</a></p><p>参考书目：</p><p><a href="http://product.dangdang.com/23248198.html?ref=book-35530-3032_5-231497-4">《Java编程手记——从实践中学习Java（配光盘）》(欧二强　等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​		在图形用户界面程序中往往要使用众多的GUI组件，需要将这些组件合理地放置到容器中。这就需要对这些组件的布置进行管理，可以使用布局管理器的类来排列界面上的组件。&lt;/p&gt;
&lt;h3 id=&quot;流式布局管理器flowlayout&quot;&gt;&lt;a class=&quot;markdownIt-An</summary>
      
    
    
    
    <category term="java" scheme="https://silenthly.github.io/categories/java/"/>
    
    
    <category term="笔记" scheme="https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>滚动面板：JScrollPane</title>
    <link href="https://silenthly.github.io/2021/10/15/%E6%BB%9A%E5%8A%A8%E9%9D%A2%E6%9D%BF%EF%BC%9AJScrollPane/"/>
    <id>https://silenthly.github.io/2021/10/15/%E6%BB%9A%E5%8A%A8%E9%9D%A2%E6%9D%BF%EF%BC%9AJScrollPane/</id>
    <published>2021-10-15T01:37:54.000Z</published>
    <updated>2021-10-15T01:37:22.352Z</updated>
    
    <content type="html"><![CDATA[<p>​滚动面板 JScrollPane 用于显示大于可视区域或大小会自动增长的组件，例如大的图片或者可编辑的文本区域等。JSrollPane 提供了水平和垂直的滚动条，可配合 ScrollPaneLayout 设定布局，构建成需要的滚动窗口。JScrollPane 类的常用常量和方法如下表所示。</p><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">方法</th><th style="text-align:center">类型</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">static int HORIZAONTAL_SCROLLBAR_ALWAYS</td><td style="text-align:center">常量</td><td style="text-align:center">始终显示水平滚动条</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">static int HORIZONTAL_SCROLLBAR_AS_NEEDED</td><td style="text-align:center">常量</td><td style="text-align:center">只在需要时显示水平滚动条</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">static int HORIZONTIAL_SCROLLBAR_NEVER</td><td style="text-align:center">常量</td><td style="text-align:center">从不显示水平滚动条</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">static int VERTICAL_SCROLLBAR_ALWAYS</td><td style="text-align:center">常量</td><td style="text-align:center">始终显示垂直滚动条</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">static int VERTICAL_SCROLLBAR_AS_NEEDED</td><td style="text-align:center">常量</td><td style="text-align:center">只在需要时显示垂直滚动条</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">static int VERTICAL_SCROLLBAR_NEVER</td><td style="text-align:center">常量</td><td style="text-align:center">从不显示垂直滚动条</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">JScrollPane()</td><td style="text-align:center">构造</td><td style="text-align:center">创建一个空的、无试图窗口的JScrollPane，需要时水平和垂直滚动条都可显示</td></tr><tr><td style="text-align:center"><strong>8</strong></td><td style="text-align:center"><strong>JScrollPane(Component view)</strong></td><td style="text-align:center"><strong>构造</strong></td><td style="text-align:center"><strong>创建一个显示指定组件内容的JScrollPane，只要组件的内容超过视图大小就会显示水平和垂直滚动条</strong></td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">JScrollPane(component view,int vsbPolicy,int hsbPolicy)</td><td style="text-align:center">构造</td><td style="text-align:center">创建一个JScrollPane，它将视图组件显示在一个视口中，根据参数设置是否显示水平和垂直滚动条</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">JScrollPane(int vsbPolicy,int hsbPolicy)</td><td style="text-align:center">构造</td><td style="text-align:center">构造一个空的滚动面板，根据参数是否显示水平和垂直滚动条</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">void setHorizontalScrollBarPolicy(int policy)</td><td style="text-align:center">普通</td><td style="text-align:center">设置水平滚动条的显示策略</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">void setVerticalScrollBarPolicy(int policy)</td><td style="text-align:center">普通</td><td style="text-align:center">设置垂直滚动条的显示策略</td></tr></tbody></table><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.ImageIcon;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JFrame;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JLabel;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JScrollPane;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        JFrame jf=<span class="keyword">new</span> JFrame(<span class="string">&quot;JScrollPane滚动面板&quot;</span>);</span><br><span class="line">        ImageIcon icon=<span class="keyword">new</span> ImageIcon(<span class="string">&quot;1.PNG&quot;</span>);</span><br><span class="line">        JLabel label=<span class="keyword">new</span> JLabel(icon);</span><br><span class="line">        JScrollPane panel=<span class="keyword">new</span> JScrollPane(label);</span><br><span class="line">        panel.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_ALWAYS);</span><br><span class="line">        panel.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);</span><br><span class="line">        jf.add(panel);</span><br><span class="line">        jf.setSize(<span class="number">400</span>,<span class="number">300</span>);</span><br><span class="line">        jf.setLocation(<span class="number">250</span>,<span class="number">350</span>);</span><br><span class="line">        jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">        jf.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://silenthty.gitee.io/photo/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/GUI8.png" alt="" /></p><p>​以上程序中，图片已经超过可视窗口的大小，所以只能显示一部分内容，但水平和垂直滚动条都被设置为始终显示，可以滑动滚动条查看没有被显示的内容。</p><p>参考书目：</p><p><a href="http://product.dangdang.com/23248198.html?ref=book-35530-3032_5-231497-4">《Java编程手记——从实践中学习Java（配光盘）》(欧二强　等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​		滚动面板 JScrollPane 用于显示大于可视区域或大小会自动增长的组件，例如大的图片或者可编辑的文本区域等。JSrollPane 提供了水平和垂直的滚动条，可配合 ScrollPaneLayout 设定布局，构建成需要的滚动窗口。JScrollPane 类的常用</summary>
      
    
    
    
    <category term="java" scheme="https://silenthly.github.io/categories/java/"/>
    
    
    <category term="笔记" scheme="https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>面板组件：JPanel</title>
    <link href="https://silenthly.github.io/2021/10/14/%E9%9D%A2%E6%9D%BF%E7%BB%84%E4%BB%B6%EF%BC%9AJPanel/"/>
    <id>https://silenthly.github.io/2021/10/14/%E9%9D%A2%E6%9D%BF%E7%BB%84%E4%BB%B6%EF%BC%9AJPanel/</id>
    <published>2021-10-14T09:13:54.000Z</published>
    <updated>2021-10-14T09:14:01.456Z</updated>
    
    <content type="html"><![CDATA[<p>​JPanel 称为面板一种常用的中间容器。一般情况下，先将其他的组件添加到面板中，然后将 JPanel 添加到其他的容器中，特别是添加到顶级容器中。JPanel 是 Container 的子类，因此，JPanel 类及其子类的实例同样是一个容器也是一个组件。JPanel 类的常用方法如下表所示。</p><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">方法</th><th style="text-align:center">类型</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">JPanel()</td><td style="text-align:center">构造</td><td style="text-align:center">创建具有双缓冲流和流布局的新 JPanel，双缓冲流使用更多内存空间实现快速、无闪烁的更新</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">JPanel(boolean isDoubleBuffered)</td><td style="text-align:center">构造</td><td style="text-align:center">创建具有FlowLayout和指定缓冲策略的新JPanel。若boolean值为true表示使用双缓冲，否则不使用</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">JPanel(LayoutManager layout)</td><td style="text-align:center">构造</td><td style="text-align:center">创建具有指定布局管理器的新缓冲JPanel</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">JPanel(LayoutManager layout,boolean isDoubleBuffer)</td><td style="text-align:center">构造</td><td style="text-align:center">创建具有指定布局管理器的新缓冲JPanel。若boolean值为true表示使用双缓冲，否则不使用</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">public Component add(Companent comp)</td><td style="text-align:center">普通</td><td style="text-align:center">将指定组件追加到此panel的尾部</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">public Component add(Companent comp,int index)</td><td style="text-align:center">普通</td><td style="text-align:center">将指定组件追加到此panel的给定位置上</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">public void setLayout(LayoutManager mgr)</td><td style="text-align:center">普通</td><td style="text-align:center">设置此panel的布局管理器</td></tr></tbody></table><blockquote><p>提示：JPanel 的默认布局管理器是 FlowLayout</p></blockquote><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.Font;</span><br><span class="line"><span class="keyword">import</span> java.awt.Color;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JFrame;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JPanel;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JLabel;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JButton;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        JFrame jf=<span class="keyword">new</span> JFrame(<span class="string">&quot;JPanel组件&quot;</span>);</span><br><span class="line">        JPanel panel=<span class="keyword">new</span> JPanel();</span><br><span class="line">        JLabel label=<span class="keyword">new</span> JLabel(<span class="string">&quot;在JPanel容器上&quot;</span>,JLabel.CENTER);</span><br><span class="line">        JButton button1=<span class="keyword">new</span> JButton(<span class="string">&quot;按钮1&quot;</span>);</span><br><span class="line">        JButton button2=<span class="keyword">new</span> JButton(<span class="string">&quot;按钮2&quot;</span>);</span><br><span class="line">        JButton button3=<span class="keyword">new</span> JButton(<span class="string">&quot;按钮3&quot;</span>);</span><br><span class="line">        Font font=<span class="keyword">new</span> Font(<span class="string">&quot;楷体&quot;</span>,Font.BOLD+Font.PLAIN,<span class="number">15</span>);</span><br><span class="line">        label.setFont(font);</span><br><span class="line">        label.setForeground(Color.blue);</span><br><span class="line">        panel.add(label);</span><br><span class="line">        panel.add(button1);</span><br><span class="line">        panel.add(button2);</span><br><span class="line">        panel.add(button3);</span><br><span class="line">        jf.add(panel);</span><br><span class="line">        jf.setSize(<span class="number">400</span>,<span class="number">300</span>);</span><br><span class="line">        jf.setLocation(<span class="number">250</span>,<span class="number">300</span>);</span><br><span class="line">        jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">        jf.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://silenthty.gitee.io/photo/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/GUI7.png" alt="" /></p><p>​由以上程序可以发现，标签租金啊和按钮组件都是以顺序的形式加入到JPanel面板中的。值得注意的是，JPanel 可以直接添加到 JFrame 容器中，因为 JPanel 本身也是容器。</p><p>参考书目：</p><p><a href="http://product.dangdang.com/23248198.html?ref=book-35530-3032_5-231497-4">《Java编程手记——从实践中学习Java（配光盘）》(欧二强　等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​		JPanel 称为面板一种常用的中间容器。一般情况下，先将其他的组件添加到面板中，然后将 JPanel 添加到其他的容器中，特别是添加到顶级容器中。JPanel 是 Container 的子类，因此，JPanel 类及其子类的实例同样是一个容器也是一个组件。JPane</summary>
      
    
    
    
    <category term="java" scheme="https://silenthly.github.io/categories/java/"/>
    
    
    <category term="笔记" scheme="https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>按钮组件：JButton</title>
    <link href="https://silenthly.github.io/2021/10/10/%E6%8C%89%E9%92%AE%E7%BB%84%E4%BB%B6%EF%BC%9AJButton/"/>
    <id>https://silenthly.github.io/2021/10/10/%E6%8C%89%E9%92%AE%E7%BB%84%E4%BB%B6%EF%BC%9AJButton/</id>
    <published>2021-10-10T01:43:23.000Z</published>
    <updated>2021-10-14T01:43:50.108Z</updated>
    
    <content type="html"><![CDATA[<p>​按钮组件也是 GUI 中常用到的一种组件，使用 JButton 类可以向窗体中添加一个按钮，JButton 类的常用方法如下图所示。</p><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">方法</th><th style="text-align:center">类型</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">JButton()</td><td style="text-align:center">构造</td><td style="text-align:center">创建不带有设置文本或图标的按钮</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">JButton(Icon icon)</td><td style="text-align:center">构造</td><td style="text-align:center">创建一个带图标的按钮</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">JButton(String text)</td><td style="text-align:center">构造</td><td style="text-align:center">创建一个带文本的按钮</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">JButton(String text,Icon icon)</td><td style="text-align:center">构造</td><td style="text-align:center">创建一个带初始文本和图标的按钮</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">Icon getIcon()</td><td style="text-align:center">普通</td><td style="text-align:center">返回默认图标</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">String getText()</td><td style="text-align:center">普通</td><td style="text-align:center">返回按钮的文本</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">void setMnemonic(int mnemonic)</td><td style="text-align:center">普通</td><td style="text-align:center">设置按钮的快捷键</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">void setIcon(Icon defaultIcon)</td><td style="text-align:center">普通</td><td style="text-align:center">设置按钮的默认图标</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">void setLayout(LayoutManager mgr)</td><td style="text-align:center">普通</td><td style="text-align:center">为此容器设置布局管理器</td></tr></tbody></table><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.Font;</span><br><span class="line"><span class="keyword">import</span> java.awt.Color;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JButton;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JFrame;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        JFrame jf=<span class="keyword">new</span> JFrame(<span class="string">&quot;文本按钮&quot;</span>);</span><br><span class="line">        JButton button=<span class="keyword">new</span> JButton(<span class="string">&quot;按钮&quot;</span>);</span><br><span class="line">        Font font=<span class="keyword">new</span> Font(<span class="string">&quot;楷体&quot;</span>,Font.BOLD+Font.PLAIN,<span class="number">35</span>);</span><br><span class="line">        button.setFont(font);</span><br><span class="line">        button.setForeground(Color.blue);</span><br><span class="line">        jf.add(button);</span><br><span class="line">        jf.setSize(<span class="number">300</span>,<span class="number">200</span>);</span><br><span class="line">        jf.setLocation(<span class="number">250</span>,<span class="number">300</span>);</span><br><span class="line">        jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">        jf.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://silenthty.gitee.io/photo/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/GUI5.png" alt="" /></p><p>​与 JLabel 一样，JButton 也可以为按钮设置图片，范例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.JFrame;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JButton;</span><br><span class="line"><span class="keyword">import</span> javax.swing.ImageIcon;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        JFrame jf=<span class="keyword">new</span> JFrame(<span class="string">&quot;图片按钮&quot;</span>);</span><br><span class="line">        ImageIcon icon=<span class="keyword">new</span> ImageIcon(<span class="string">&quot;download.png&quot;</span>);</span><br><span class="line">        JButton button=<span class="keyword">new</span> JButton(icon);</span><br><span class="line">        jf.add(button);</span><br><span class="line">        jf.pack();<span class="comment">//设置内容紧缩</span></span><br><span class="line">        jf.setLocation(<span class="number">250</span>,<span class="number">300</span>);</span><br><span class="line">        jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">        jf.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://silenthty.gitee.io/photo/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/GUI6.png" alt="" /></p><p>参考书目：</p><p><a href="http://product.dangdang.com/23248198.html?ref=book-35530-3032_5-231497-4">《Java编程手记——从实践中学习Java（配光盘）》(欧二强　等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​		按钮组件也是 GUI 中常用到的一种组件，使用 JButton 类可以向窗体中添加一个按钮，JButton 类的常用方法如下图所示。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;序号&lt;/th&gt;
&lt;th </summary>
      
    
    
    
    <category term="java" scheme="https://silenthly.github.io/categories/java/"/>
    
    
    <category term="笔记" scheme="https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>标签组件：JLabel</title>
    <link href="https://silenthly.github.io/2021/10/10/%E6%A0%87%E7%AD%BE%E7%BB%84%E4%BB%B6%EF%BC%9AJLabel/"/>
    <id>https://silenthly.github.io/2021/10/10/%E6%A0%87%E7%AD%BE%E7%BB%84%E4%BB%B6%EF%BC%9AJLabel/</id>
    <published>2021-10-10T01:13:25.000Z</published>
    <updated>2021-10-14T01:13:48.732Z</updated>
    
    <content type="html"><![CDATA[<p>​在GUI程序中几乎每一个窗口都可以见到标签 Label 的存在。标签常用与在窗口中显示文本信息、图像作为分隔符使用。创建 Label 对象后可以通过 Container 类中的 add() 方法加入容器中，JLabel 类的常用常量和方法下表所示。</p><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">方法</th><th style="text-align:center">类型</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><strong>1</strong></td><td style="text-align:center"><strong>static int CENTER</strong></td><td style="text-align:center"><strong>常量</strong></td><td style="text-align:center"><strong>文本/图片在Label控件中居中</strong></td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">static int LEFT</td><td style="text-align:center">常量</td><td style="text-align:center">文本/图片在Label控件中居左</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">static int RIGHT</td><td style="text-align:center">常量</td><td style="text-align:center">文本/图片在Label控件中居右</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">JLabel()</td><td style="text-align:center">构造</td><td style="text-align:center">创建无图像并且标题为空字符串的JLable</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">JLabel(Icon image)</td><td style="text-align:center">构造</td><td style="text-align:center">创建具有指定图像的JLabel实例</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">JLabel(Icon image,int horizontalAlignment)</td><td style="text-align:center">构造</td><td style="text-align:center">创建具有指定图像和水平对齐方式的JLabel实例</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">JLabel(String text)</td><td style="text-align:center">构造</td><td style="text-align:center">创建具有指定文本的JLabel实例</td></tr><tr><td style="text-align:center"><strong>8</strong></td><td style="text-align:center"><strong>JLabel(String text,int horizontalAlignment)</strong></td><td style="text-align:center"><strong>构造</strong></td><td style="text-align:center"><strong>创建具有指定文本和水平对齐方式的JLabel实例</strong></td></tr><tr><td style="text-align:center"><strong>9</strong></td><td style="text-align:center"><strong>JLabel(String text,Icon image,int horizontalAlignment)</strong></td><td style="text-align:center"><strong>构造</strong></td><td style="text-align:center"><strong>创建具有指定文本、图像和水平对齐方式的JLabel实例</strong></td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">Icon getIcon()</td><td style="text-align:center">普通</td><td style="text-align:center">返回该标签显示的图形图像</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">String getText()</td><td style="text-align:center">普通</td><td style="text-align:center">返回该标签显示的文本字符串</td></tr><tr><td style="text-align:center"><strong>12</strong></td><td style="text-align:center"><strong>public void setFont(Font font)</strong></td><td style="text-align:center"><strong>普通</strong></td><td style="text-align:center"><strong>设置标签文字内容的字体格式</strong></td></tr><tr><td style="text-align:center"><strong>13</strong></td><td style="text-align:center"><strong>public void setForeground(Color fg)</strong></td><td style="text-align:center"><strong>普通</strong></td><td style="text-align:center"><strong>设置标签文字内容的字体颜色</strong></td></tr><tr><td style="text-align:center">14</td><td style="text-align:center">public void setAlignment(float alignment)</td><td style="text-align:center">普通</td><td style="text-align:center">设置标签的对齐方式</td></tr><tr><td style="text-align:center">15</td><td style="text-align:center">void setIcon(Icon icon)</td><td style="text-align:center">普通</td><td style="text-align:center">定义此标签将要显示的图标</td></tr><tr><td style="text-align:center">16</td><td style="text-align:center">void setText(String text)</td><td style="text-align:center">普通</td><td style="text-align:center">定义此标签将要显示的单行文本</td></tr></tbody></table><p>​还可以使用 Font 类设置标签的文本字体格式，只需要调用 Component 类中的 setFont() 方法即可。Font 类中常用常量和方法如下表所示。</p><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">方法</th><th style="text-align:center">类型</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><strong>1</strong></td><td style="text-align:center"><strong>static int BOLD</strong></td><td style="text-align:center"><strong>常量</strong></td><td style="text-align:center"><strong>粗体样式</strong></td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">staic int ITALIC</td><td style="text-align:center">常量</td><td style="text-align:center">斜体样式</td></tr><tr><td style="text-align:center"><strong>3</strong></td><td style="text-align:center"><strong>static int PLAIN</strong></td><td style="text-align:center"><strong>常量</strong></td><td style="text-align:center"><strong>普通样式</strong></td></tr><tr><td style="text-align:center"><strong>4</strong></td><td style="text-align:center"><strong>Font(String name,int style,int size)</strong></td><td style="text-align:center"><strong>构造</strong></td><td style="text-align:center"><strong>根据指定名称、样式和磅值大小，创建一个新Font对象</strong></td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">static Font setFont(String nm)</td><td style="text-align:center">构造</td><td style="text-align:center">从系统属性列表返回一个Font对象</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">String getFontName()</td><td style="text-align:center">普通</td><td style="text-align:center">返回此Font的字体外观名称</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">String getName()</td><td style="text-align:center">普通</td><td style="text-align:center">返回此Font的逻辑名称</td></tr></tbody></table><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.Font;</span><br><span class="line"><span class="keyword">import</span> java.awt.Color;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JFrame;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JLabel;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        JFrame jf=<span class="keyword">new</span> JFrame(<span class="string">&quot;文本标签&quot;</span>);</span><br><span class="line">        JLabel label=<span class="keyword">new</span> JLabel(<span class="string">&quot;这是一个标签&quot;</span>,JLabel.CENTER);</span><br><span class="line">        Font font=<span class="keyword">new</span> Font(<span class="string">&quot;楷体&quot;</span>,Font.BOLD+Font.PLAIN,<span class="number">35</span>);</span><br><span class="line">        label.setFont(font);<span class="comment">//设置标签文字字体格式</span></span><br><span class="line">        label.setForeground(Color.blue);<span class="comment">//设置标签文字字体颜色</span></span><br><span class="line">        jf.add(label);<span class="comment">//向容器中添加标签</span></span><br><span class="line">        jf.setSize(<span class="number">400</span>,<span class="number">300</span>);</span><br><span class="line">        jf.setLocation(<span class="number">250</span>,<span class="number">300</span>);</span><br><span class="line">        jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">        jf.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://silenthty.gitee.io/photo/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/GUI2.png" alt="" /></p><p>​Swing 中的标签还有一个特点就是可以放入图片，让程序外观更加美观漂亮。JLabel中提供了两种方法可以在标签中添加图片，一种是利用 JLabel 的构造方法 JLabel(Icon image)，另一种是利用 JLabel 的 setIcon(Icon icon)方法。这两种方法需要使用 ImageIcon 类将图片数据以 byte 数组的形式设置上去，ImageIcon 类常用方法如下表所示。</p><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">方法</th><th style="text-align:center">类型</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">ImageIcon()</td><td style="text-align:center">构造</td><td style="text-align:center">创建一个未初始化的图像图标</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">ImageIcon(byte[] imageData)</td><td style="text-align:center">构造</td><td style="text-align:center">将保存图片信息的byte数组设置到ImageIcon中</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">ImageIcon(byte[] imageData,String description)</td><td style="text-align:center">构造</td><td style="text-align:center">将保存图片信息的byte数组设置到ImageIcon中。其中，参数description为图像的简明文本描述</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">ImageIcon(Image image)</td><td style="text-align:center">构造</td><td style="text-align:center">根据图像对象创建一个ImageIcon</td></tr><tr><td style="text-align:center"><strong>5</strong></td><td style="text-align:center"><strong>ImageIcon(Image image,String description)</strong></td><td style="text-align:center"><strong>构造</strong></td><td style="text-align:center"><strong>根据图像创建一个ImageIcon。其中，参数法description为图像的简明文本描述</strong></td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">ImageIcon(String filename)</td><td style="text-align:center">构造</td><td style="text-align:center">根据指定的文件创建一个ImageIcon</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">ImageIcon(String filename,String description)</td><td style="text-align:center">构造</td><td style="text-align:center">根据指定的文件创建一个ImageIcon。其中，参数description为图像的简明文本描述</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">String getDescription()</td><td style="text-align:center">普通</td><td style="text-align:center">获得图像的描述</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">int getIconHeight()</td><td style="text-align:center">普通</td><td style="text-align:center">获得图标的高度</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">int getIconWidth()</td><td style="text-align:center">普通</td><td style="text-align:center">获得图标的宽度</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">Image getImage()</td><td style="text-align:center">普通</td><td style="text-align:center">返回此图标的Image</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">int getImageLoadStatus()</td><td style="text-align:center">普通</td><td style="text-align:center">返回图像加载操作的状态</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">void paintIcon(Component c,Graphics g,int x,int y)</td><td style="text-align:center">普通</td><td style="text-align:center">绘制图标</td></tr><tr><td style="text-align:center">14</td><td style="text-align:center">void setDescription(String description)</td><td style="text-align:center">普通</td><td style="text-align:center">设置图像的描述</td></tr><tr><td style="text-align:center">15</td><td style="text-align:center">void setImage(Image image)</td><td style="text-align:center">普通</td><td style="text-align:center">设置由此图标显示的图像</td></tr></tbody></table><blockquote><p>提示：ImageIcon 是 Icon 的实现类</p></blockquote><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.Font;</span><br><span class="line"><span class="keyword">import</span> java.awt.Color;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JLabel;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JFrame;</span><br><span class="line"><span class="keyword">import</span> javax.swing.ImageIcon;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        JFrame jf=<span class="keyword">new</span> JFrame(<span class="string">&quot;图片标签&quot;</span>);</span><br><span class="line">        ImageIcon icon=<span class="keyword">new</span> ImageIcon(<span class="string">&quot;GUI2.PNG&quot;</span>,<span class="string">&quot;GUI2&quot;</span>);<span class="comment">//创建ImageIcon对象，并指定图片</span></span><br><span class="line">        JLabel label=<span class="keyword">new</span> JLabel(<span class="string">&quot;GUI2&quot;</span>,icon,JLabel.CENTER);<span class="comment">//创建标签并设置文本</span></span><br><span class="line">        Font font=<span class="keyword">new</span> Font(<span class="string">&quot;楷体&quot;</span>,Font.BOLD+Font.PLAIN,<span class="number">30</span>);</span><br><span class="line">        label.setFont(font);<span class="comment">//设置文本字体格式</span></span><br><span class="line">        label.setForeground(Color.blue);<span class="comment">//设置文本字体颜色</span></span><br><span class="line">        jf.add(label);<span class="comment">//添加标签</span></span><br><span class="line">        jf.setSize(<span class="number">1000</span>,<span class="number">1000</span>);</span><br><span class="line">        jf.setLocation(<span class="number">250</span>,<span class="number">300</span>);</span><br><span class="line">        jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">        jf.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://silenthty.gitee.io/photo/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/GUI3.png" alt="" /></p><p>​以上程序中的图片是从文件中提取出来的，使用 ImageIcon 的构造方法 ImageIcon(Image image) 非常方便。但图片若来自一个输入流，则需要使用 ImageIcon 的另一个构造方法 ImageIcon(byte[] imageData)，范例如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.Font;</span><br><span class="line"><span class="keyword">import</span> java.awt.Color;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JLabel;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JFrame;</span><br><span class="line"><span class="keyword">import</span> javax.swing.ImageIcon;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        File file=<span class="keyword">new</span> File(<span class="string">&quot;GUI2.PNG&quot;</span>);</span><br><span class="line">        FileInputStream fin=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">byte</span> b[]=<span class="keyword">new</span> <span class="keyword">byte</span>[(<span class="keyword">int</span>)file.length()];</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            fin=<span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">            fin.read(b,<span class="number">0</span>,(<span class="keyword">int</span>)file.length());</span><br><span class="line">            fin.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        JFrame jf=<span class="keyword">new</span> JFrame(<span class="string">&quot;输入流图片标签&quot;</span>);</span><br><span class="line">        ImageIcon icon=<span class="keyword">new</span> ImageIcon(b,<span class="string">&quot;GUI2&quot;</span>);</span><br><span class="line">        JLabel label=<span class="keyword">new</span> JLabel(<span class="string">&quot;输入流中的图片&quot;</span>,icon,JLabel.CENTER);</span><br><span class="line">        Font font=<span class="keyword">new</span> Font(<span class="string">&quot;楷体&quot;</span>,Font.BOLD+Font.PLAIN,<span class="number">35</span>);</span><br><span class="line">        label.setFont(font);</span><br><span class="line">        label.setForeground(Color.blue);</span><br><span class="line">        jf.add(label);</span><br><span class="line">        jf.setSize(<span class="number">700</span>,<span class="number">500</span>);</span><br><span class="line">        jf.setLocation(<span class="number">250</span>,<span class="number">300</span>);</span><br><span class="line">        jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">        jf.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://silenthty.gitee.io/photo/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/GUI4.png" alt="" /></p><p>​以上程序通过输入流来获取图片，常用于从数据库、网络中读取图片。</p><p>参考书目：</p><p><a href="http://product.dangdang.com/23248198.html?ref=book-35530-3032_5-231497-4">《Java编程手记——从实践中学习Java（配光盘）》(欧二强　等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​		在GUI程序中几乎每一个窗口都可以见到标签 Label 的存在。标签常用与在窗口中显示文本信息、图像作为分隔符使用。创建 Label 对象后可以通过 Container 类中的 add() 方法加入容器中，JLabel 类的常用常量和方法下表所示。&lt;/p&gt;
&lt;tabl</summary>
      
    
    
    
    <category term="java" scheme="https://silenthly.github.io/categories/java/"/>
    
    
    <category term="笔记" scheme="https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>基本容器：JFrame</title>
    <link href="https://silenthly.github.io/2021/10/09/%E5%9F%BA%E6%9C%AC%E5%AE%B9%E5%99%A8%EF%BC%9AJFrame/"/>
    <id>https://silenthly.github.io/2021/10/09/%E5%9F%BA%E6%9C%AC%E5%AE%B9%E5%99%A8%EF%BC%9AJFrame/</id>
    <published>2021-10-09T09:29:14.000Z</published>
    <updated>2021-10-11T07:30:36.540Z</updated>
    
    <content type="html"><![CDATA[<p>​Swing 有4中顶层的容器，即 JFrame、JDialog、JApplet 和 JWindow ，在此优先对 JFrame 进行讲解，其他容器以后补充。使用 JFrame 类可以创建一个窗口，它是 Component 的子类，其常用常量和方法如下表所示。</p><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">常量或方法</th><th style="text-align:center">类型</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><strong>1</strong></td><td style="text-align:center"><strong>static int EXIT_ON_CLOSE</strong></td><td style="text-align:center"><strong>常量</strong></td><td style="text-align:center"><strong>退出应用程序后的默认窗口关闭操作</strong></td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">JFrame()</td><td style="text-align:center">构造</td><td style="text-align:center">创建一个初始时不可见的新窗体</td></tr><tr><td style="text-align:center"><strong>3</strong></td><td style="text-align:center"><strong>JFrame(String title)</strong></td><td style="text-align:center"><strong>构造</strong></td><td style="text-align:center"><strong>创建一个新的、初始不可见的、具有指定标题的窗口</strong></td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">public Component add(Component comp)</td><td style="text-align:center">普通</td><td style="text-align:center">将指定组件追加到此容器的尾部</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">public Component add(Component comp,int index)</td><td style="text-align:center">普通</td><td style="text-align:center">将指定组件添加到此容器的给定位置上</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">int getDefaultCloseOperation()</td><td style="text-align:center">普通</td><td style="text-align:center">返回用户在此窗体上发起关闭时默认执行的操作</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">JMenuBar getJMenuBar()</td><td style="text-align:center">普通</td><td style="text-align:center">返回此窗体上设置的菜单栏</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">public String getTitle()</td><td style="text-align:center">普通</td><td style="text-align:center">获得窗体的标题。标题显示在窗体的边框中</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">public void pack()</td><td style="text-align:center">普通</td><td style="text-align:center">调整此窗口的大小，以合适其子组件的首选大小和布局</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">void remove(Component comp)</td><td style="text-align:center">普通</td><td style="text-align:center">从该容器中移除指定组件</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">void repaint(long time,int x,int y,int width,int height)</td><td style="text-align:center">普通</td><td style="text-align:center">在time毫秒内重绘此组件的指定矩形区域</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">public void setBackground(Color c)</td><td style="text-align:center">普通</td><td style="text-align:center">设置组件的背景色</td></tr><tr><td style="text-align:center"><strong>13</strong></td><td style="text-align:center"><strong>void setDefaultCloseOperation(int Operation)</strong></td><td style="text-align:center"><strong>普通</strong></td><td style="text-align:center"><strong>设置用户在此窗体上发起close时默认执行的操作</strong></td></tr><tr><td style="text-align:center">14</td><td style="text-align:center">void setIconImage(Image image)</td><td style="text-align:center">普通</td><td style="text-align:center">设置要作为此窗口图标显示的图像</td></tr><tr><td style="text-align:center">15</td><td style="text-align:center">void setJMenuBar(JMenuBar menubar)</td><td style="text-align:center">普通</td><td style="text-align:center">设置此窗体的菜单栏</td></tr><tr><td style="text-align:center">16</td><td style="text-align:center">public void setLocation(int x,int y)</td><td style="text-align:center">普通</td><td style="text-align:center">将组件移到新位置。通过此组件父级坐标空间中的x和y参数，来指定新位置的左上角</td></tr><tr><td style="text-align:center"><strong>17</strong></td><td style="text-align:center"><strong>public void setLocation(Point p)</strong></td><td style="text-align:center"><strong>普通</strong></td><td style="text-align:center"><strong>设置组件的显示位置。通过点p来指定新位置的左上角。在父级坐标空间中给出点p</strong></td></tr><tr><td style="text-align:center">18</td><td style="text-align:center">void setLayout(LayoutMananger manager)</td><td style="text-align:center">普通</td><td style="text-align:center">设置布局管理器</td></tr><tr><td style="text-align:center">19</td><td style="text-align:center">public void setSize(int width,int height)</td><td style="text-align:center">普通</td><td style="text-align:center">调整组件的大小为指定宽与高</td></tr><tr><td style="text-align:center"><strong>20</strong></td><td style="text-align:center"><strong>public void setSize(Dimension d)</strong></td><td style="text-align:center"><strong>普通</strong></td><td style="text-align:center"><strong>调整组件的大小为组件d的大小</strong></td></tr><tr><td style="text-align:center">21</td><td style="text-align:center">public void setTitle(String title)</td><td style="text-align:center">普通</td><td style="text-align:center">将此窗口的标题设置为指定的字符串</td></tr><tr><td style="text-align:center"><strong>22</strong></td><td style="text-align:center"><strong>public void setVisible(boolean b)</strong></td><td style="text-align:center"><strong>普通</strong></td><td style="text-align:center"><strong>根据参数b的值显示或隐藏此窗口。若b为true，则显示，否则隐藏</strong></td></tr></tbody></table><p>​在上表中使用的两个类，Dimension 类和 Point 类。Dimension 类用于设置窗体的大小，而 Point 类用于设置窗体的显示位置。Dimension 类和 Point 类的常用常量和方法如下所示。</p><center>Dimension类的常用方法</center><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">方法</th><th style="text-align:center">类型</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">int height</td><td style="text-align:center">常量</td><td style="text-align:center">Dimension的高度，可以使用负值</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">int width</td><td style="text-align:center">常量</td><td style="text-align:center">Dimension的宽度，可以使用负值</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">Dimension()</td><td style="text-align:center">构造</td><td style="text-align:center">创建Dimension的一个示例，其宽度为0，高度为0</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">Dimension(Dimension d)</td><td style="text-align:center">构造</td><td style="text-align:center">创建Dimension的一个示例，大小与指定的对象d相同</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">Dimension(int width,int height)</td><td style="text-align:center">构造</td><td style="text-align:center">构造一个Dimension，并将其初始化为指定宽度和高度</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">double getHeight()</td><td style="text-align:center">普通</td><td style="text-align:center">返回此Dimension的高度</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">Dimension getSize()</td><td style="text-align:center">普通</td><td style="text-align:center">获得此Dimension对象的大小</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">double getWidth()</td><td style="text-align:center">普通</td><td style="text-align:center">返回此Dimension的宽度</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">void setSize(Dimension d)</td><td style="text-align:center">普通</td><td style="text-align:center">设置此Dimension对象的大小为指定大小</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">void setSize(double width,double height)</td><td style="text-align:center">普通</td><td style="text-align:center">设置此Dimension对象的大小为指定大小</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">void setSize(int width,int height)</td><td style="text-align:center">普通</td><td style="text-align:center">设置此Dimension对象的大小为指定大小</td></tr></tbody></table><center>Point类的常用常量和方法</center><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">方法</th><th style="text-align:center">类型</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">int x</td><td style="text-align:center">常量</td><td style="text-align:center">x坐标</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">int y</td><td style="text-align:center">常量</td><td style="text-align:center">y 坐标</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">Point()</td><td style="text-align:center">构造</td><td style="text-align:center">在坐标空间的原点(0,0)构造并初始化一个点</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">Point(x,y)</td><td style="text-align:center">构造</td><td style="text-align:center">在坐标空间中指定的(x,y)位置构造并初始化一个点</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">Point(Point p)</td><td style="text-align:center">构造</td><td style="text-align:center">在坐标空间中构造并初始化一个与p相同位置的点</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">Point getLocation()</td><td style="text-align:center">普通</td><td style="text-align:center">返回此点的位置</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">double getX()</td><td style="text-align:center">普通</td><td style="text-align:center">以双精度类型返回点的X坐标</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">double getY()</td><td style="text-align:center">普通</td><td style="text-align:center">以双精度类型返回点的y坐标</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">void move(int x,int y)</td><td style="text-align:center">普通</td><td style="text-align:center">将此点移动到(x,y)坐标平面中的指定位置</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">void setLocation(double x,double y)</td><td style="text-align:center">普通</td><td style="text-align:center">将此点的位置设置为指定的双精度坐标</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">void setLocation(int x,int y)</td><td style="text-align:center">普通</td><td style="text-align:center">将此点的位置更改为指定位置</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">void setLocation(Point p)</td><td style="text-align:center">普通</td><td style="text-align:center">将此点的位置设为指定位置</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">void translate(int dx,int dy)</td><td style="text-align:center">普通</td><td style="text-align:center">平移(x,y)位置的点，沿x轴平移dx，沿y轴平移dy，移动后得到点(x+dx,y+dy)</td></tr></tbody></table><p>​根据以上的类方法创建以新的窗口，范例如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.Dimension;</span><br><span class="line"><span class="keyword">import</span> java.awt.Point;</span><br><span class="line"><span class="comment">//import java.awt.Container;</span></span><br><span class="line"><span class="keyword">import</span> javax.swing.JFrame;</span><br><span class="line"><span class="comment">//import java.awt.Color;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        JFrame jf=<span class="keyword">new</span> JFrame(<span class="string">&quot;第一个窗口&quot;</span>);</span><br><span class="line">        <span class="comment">//Container con=jf.getContentPane();</span></span><br><span class="line">        <span class="comment">//con.setBackground(Color.black);</span></span><br><span class="line">        Dimension d=<span class="keyword">new</span> Dimension(<span class="number">400</span>,<span class="number">300</span>);</span><br><span class="line">        Point p=<span class="keyword">new</span> Point(<span class="number">250</span>,<span class="number">300</span>);</span><br><span class="line">        jf.setLocation(p);<span class="comment">//设置窗口的初始位置</span></span><br><span class="line">        jf.setSize(d);<span class="comment">//设置窗口的大小</span></span><br><span class="line">        jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);<span class="comment">//设置窗口关闭方式</span></span><br><span class="line">        jf.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://silenthty.gitee.io/photo/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/swing1.png" alt="" /></p><p>​以上程序创建了一个空白的窗口，其中setDefaultCloseOperation(jf.EXIT_ON_CLOSE)设置了窗口的关闭方式。若没有设置窗口的关闭方式，单击“关闭”按钮是不能真正关闭窗口的。就是说，单击关闭按钮时窗口会消失，虽然窗口不见了，但是JVM并没有退出。</p><p>参考书目：</p><p><a href="http://product.dangdang.com/23248198.html?ref=book-35530-3032_5-231497-4">《Java编程手记——从实践中学习Java（配光盘）》(欧二强　等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​		Swing 有4中顶层的容器，即 JFrame、JDialog、JApplet 和 JWindow ，在此优先对 JFrame 进行讲解，其他容器以后补充。使用 JFrame 类可以创建一个窗口，它是 Component 的子类，其常用常量和方法如下表所示。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="java" scheme="https://silenthly.github.io/categories/java/"/>
    
    
    <category term="笔记" scheme="https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Swing概述</title>
    <link href="https://silenthly.github.io/2021/10/07/Swing%E6%A6%82%E8%BF%B0/"/>
    <id>https://silenthly.github.io/2021/10/07/Swing%E6%A6%82%E8%BF%B0/</id>
    <published>2021-10-07T07:32:42.000Z</published>
    <updated>2021-10-10T07:30:34.568Z</updated>
    
    <content type="html"><![CDATA[<p>​Swing 是 java 提供的 GUI 编程的类库，并且Swing组件是完全采用 java 语言来编写、操作和显示的，可以用来开发跨平台的 GUI 组件。使用 Swing 来开发 GUI 比 AWT更加优秀，Swing 是一组轻量级的组件，而且 Swing 除了包含 AWT 中的组件以外还提供了大量新的组件，如滚动窗口、选项版和表格等。</p><h3 id="认识swing"><a class="markdownIt-Anchor" href="#认识swing"></a> 认识Swing</h3><p>​Swing 包是 JDK1.2 起引入的界面设计接口。Swing 对 AWT 进行了大量的扩展，通过 Swing 可以设计出功能强大、界面优美的 GUI 程序。Swing 不但提供了很多功能完善的组件，还具有良好的扩展能力，使用 Swing 可以开发出跨平台的 GUI 程序。</p><p>​Swing 类库非常庞大，其功能涉及图形用户界面开发的各个方面，绝大部分相关的类都位于 java.swing 包及其子包中，Swing库中常用的包及其相关功能如下表所示。</p><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">包名</th><th style="text-align:center">功能说明</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">javax.accessibilty</td><td style="text-align:center">定义了用户界面组件与提供这些组件进行访问的辅助技术之间的协定。该包中提供了很多具有辅助功能的类和接口，这些类和接口可以与Swing组件进行交流。注意：此包不是Swing包中的一部分，但是在Swing中应用得非常广泛</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">javax.swing</td><td style="text-align:center">提供一组“轻量级”(全部是java语言)组件，尽量让这些组件在所有平台上的工作方式都相同</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">javax.swing.border</td><td style="text-align:center">提供围绕Swing组件绘制特殊边框的类和接口</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">javax.swing.colorchooser</td><td style="text-align:center">包含为JColorChooser组件使用提供支持的类和接口</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">javax.swing.event</td><td style="text-align:center">包含了关于Swing监听器和事件处理的类和接口</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">javax.swing.filechooser</td><td style="text-align:center">包含为JColorChooser组件使用提供支持的类和接口</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">javax.swing.plaf</td><td style="text-align:center">包含了支持不同操作系统平台显示外观的类，其中包括了实现Metal和Multi外观风格的类，通过包中的类可以调整界面的外观风格。此包中包含多个子包，可在API帮助文档进行查阅</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">javax.swing.table</td><td style="text-align:center">包含了为表格组件提供支持的类</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">javax.swing.text</td><td style="text-align:center">提供了一些为文本组件使用的支持类</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">javax.swing.text.html</td><td style="text-align:center">提供了HTMLEditorKit和创建HTML文本编辑器的支持类</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">javax.swing.text.html.parser</td><td style="text-align:center">提供默认的HTML解析器及支持类</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">javax.swing.text.rtf</td><td style="text-align:center">提供一个类(RTFEditorKit)，用于创建富文本格式(Rich-Text-Format)的文本编辑器</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">javax.swing.tree</td><td style="text-align:center">包含了为树状列表组件提供支持的类</td></tr><tr><td style="text-align:center">14</td><td style="text-align:center">javax.swing.undo</td><td style="text-align:center">允许开发人员为应用程序(例如文本编辑器)中的撤销/恢复提供支持</td></tr></tbody></table><blockquote><p>提示：javax中的x是Extension的缩写形式，表示java核心类的扩展包</p></blockquote><h3 id="swing-与-awt-的对比"><a class="markdownIt-Anchor" href="#swing-与-awt-的对比"></a> Swing 与 AWT 的对比</h3><p>​Swing 是在 AWT 组件的基础上构建的，也就是说 Swing 组件实际上也是 AWT 的一部分。下面介绍 Swing 与 AWT 的关系。</p><p>​（1）AWT 是随着早期的 JDK 一起发布的 GUI 工具包，所有的 JDK 中都包含有基本的 GUI 工具包。AWT 本身就提供了基本的组件和丰富的事件处理接口。Swing 则是在 AWT 的基础上引入的轻量级的 GUI 工具包，也就是说 AWT 是 Swing 的基础。</p><p>​（2）AWT 提供的组件数量非常有限，远远没有 Swing 那么丰富，如 Swing 提供的滚动窗口、选项板和表格等在 AWT 中并不存在。另外，在 AWT 中提供的都是重量级组件， 如果希望编写能在不同平台运行的程序，必须在每一个平台上单独测试，无法实现“Write  Once，Run Anywhere”的跨平台特性。</p><p>​（3）需要说明的是 Swing 的出现并不是为了替代 AWT，只是提供更加丰富的组件， 为开发人员提供更多的选择。Swing 使用的事件处理就是 AWT 提供的。因此，在实际的程序设计中会同时使用到 Swing 和 AWT，但组件一般只使用 Swing，而很多的辅助类常常使用的却是 AWT，特别是在事件处理的开发上。</p><blockquote><p>提示：AWT 提供的是重量级组件，是依赖于本地操作系统的 GUI 工具包。而 Swing 属于轻量级组件，是纯 Java 语言编写，使用基本的图形元素直接在屏幕上绘制。因此，在搭建界面时，如果将 Swing 和 AWT 同时使用，就可能会出现先后遮挡的正常现象。因为 AWT 组件是依赖本地系统对等体显示的，而 Swing 使用基本的图形元素是直接由 Java 所绘制的。所以当 AWT 与 Swing 组件重叠时，AWT 的显示优先级高，也就是说 AWT 组件总是会显示在 Swing 组件前面。建议不要将 Swing 和 AWT 组件进行混用。</p></blockquote><p>​前面多次强调 Swing 组件是采用纯 Java 编写的，不再调用本地操作系统的函数，所以 Swing 图形界面的组件显示速度要比 AWT 要慢一些。但相对于高速发展的硬件设备而言， 这样微小的速度差别是没有任何妨碍的。相比 AWT，Swing 组件的优势十分明显：</p><ul><li>Swing 是采用纯 Java 实现的，不依赖本地操作系统的支持，在不同的平台上运行 时可以保证具有相同的图形界面外观，具有良好的跨平台特性。</li><li>Swing 提供了更多的组件，且在 AWT 的基础上进行扩展，以“J”字母开头，如增加了很多的高级组件 JTable、JTree 等。</li><li>Swing 组件遵守 MVC（Model-View-Controlle，模式-视图-控制器）的设计模式。 将模式和视图分隔开，可以方便用户直接通过模式管理数据。</li><li>Swing 可以使用可插拔式外观感觉（Pluggable Look and Feel，PL&amp;F）来控制组件外观。开发人员可以在程序中加入相应的开关，使得用户可以根据喜好选择不同的界面。</li><li>Swing 加入了支持键盘操作。通过使用 JComponent 类中的 registerKeyboardAction() 方法，用户可以通过键盘操作代替鼠标控制 Swing 组件。</li></ul><p>参考书目：</p><p><a href="http://product.dangdang.com/23248198.html?ref=book-35530-3032_5-231497-4">《Java编程手记——从实践中学习Java（配光盘）》(欧二强　等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​		Swing 是 java 提供的 GUI 编程的类库，并且Swing组件是完全采用 java 语言来编写、操作和显示的，可以用来开发跨平台的 GUI 组件。使用 Swing 来开发 GUI 比 AWT更加优秀，Swing 是一组轻量级的组件，而且 Swing 除了包含</summary>
      
    
    
    
    <category term="java" scheme="https://silenthly.github.io/categories/java/"/>
    
    
    <category term="笔记" scheme="https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>事务处理</title>
    <link href="https://silenthly.github.io/2021/10/05/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/"/>
    <id>https://silenthly.github.io/2021/10/05/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/</id>
    <published>2021-10-05T08:14:45.000Z</published>
    <updated>2021-10-26T11:46:07.554Z</updated>
    
    <content type="html"><![CDATA[<p>​对数据库而言，事务处理都是很重要的，因为在对数据库的操作中并不能保证完全不出错。事务是保证数据库中数据的完整性和统一性的重要手段。</p><h3 id="事务简介"><a class="markdownIt-Anchor" href="#事务简介"></a> 事务简介</h3><p>​在操作数据库时，经常出现这样一种情况，数据库中已经存在了一些记录。现在想要向数据库中插入数据，但数据插入一半时，系统发生了错误。此时已经有一半的数据已经成功插入数据，但还有一部分没有插入，若重新执行插入操作，很可能会引起数据库错误。这时就需要使用事务处理。</p><p>​事务是SQL中单个的逻辑执行单元，可由一步或多步的数据库操作组成。一个事务内的所有语句作为整体执行，遇到错误时可以回滚事务，取消事务所作的所有改变，就是说这一系列操作要么全部执行，要么全部放弃，从而保证数据库的一致性和可恢复性。</p><p>​事务一般具有以下4种特性：</p><ul><li>原子性：一个事务必须作为一个原子单位，是最小的执行单位。它所作的数据修改要么全部执行，要么全部取消。</li><li>一致性：当事务执行结束，数据库必须从一个一致性状态，转变为另一个一致性状态。事务的一致性是需要原子性来保证的。</li><li>隔离性：一个事务所作的修改必须能够跟其他事务所作的修改是隔离的，就是说并发执行的事务之间不能知道对方的中间状态。并发执行的事务之间不能相互影响，以免在并发处理时发生数据错误。</li><li>持久性：事务执行结束后，它对数据库所作的修改被永久保存。</li></ul><h3 id="mysql对事务的支持"><a class="markdownIt-Anchor" href="#mysql对事务的支持"></a> MySQL对事务的支持</h3><p>​MySQL默认情况下是关闭事务，这就需要用户手动开启MySQL的事务支持。MySQL中提供的事务处理命令如下表所示。</p><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">命令</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">SET AUTOCOMMIT=0</td><td style="text-align:center">取消自动提交处理，开启事务处理</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">SET AUTOCOMMIT=1</td><td style="text-align:center">打开自动提交处理，关闭事务处理</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">START TRANSACTION</td><td style="text-align:center">启动事务</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">BEGIN</td><td style="text-align:center">启动事务，相当于执行START TRANSACTION</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">COMMIT</td><td style="text-align:center">提交事务</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">ROLLBACK</td><td style="text-align:center">回滚全部操作</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">SAVEPOINT 事务保存点名称</td><td style="text-align:center">设置事务保存点</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">ROLLBACK TO SAVEPOINT 保存点名称</td><td style="text-align:center">回滚操作到保存点</td></tr></tbody></table><h4 id="执行事务处理"><a class="markdownIt-Anchor" href="#执行事务处理"></a> 执行事务处理</h4><p>​在此删除前面的StudentUser表，新建一个StudentUser表，SQL语句如下：</p><p>​删除StudentUser表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE StudentUser;</span><br></pre></td></tr></table></figure><p>​新建StudentUser表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE StudentUser(</span><br><span class="line">id INT NOT NULL PRIMARY KEY,</span><br><span class="line">name VARCHAR(15) NOT NULL,</span><br><span class="line">password VARCHAR(20) NOT NULL, </span><br><span class="line">sex VARCHAR(2) NOT NULL,</span><br><span class="line">mail VARCHAR(25),</span><br><span class="line">college VARCHAR(15) NOT NULL</span><br><span class="line">)ENGINE=InnoDB;</span><br></pre></td></tr></table></figure><p>​插入两条记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO StudentUser (id,name,password,sex,mail,college) VALUES (123,&#x27;小强&#x27;,&#x27;qian&#x27;,&#x27;男&#x27;,&#x27;qiangmzsx@gmail.com&#x27;,&#x27;信通学院&#x27;),(456,&#x27;小明&#x27;,&#x27;ming&#x27;,&#x27;男&#x27;,&#x27;tonglyu@gmail.com&#x27;,&#x27;信通学院&#x27;);</span><br></pre></td></tr></table></figure><p>​其中，ENGINE指定表的默认引擎为InnoDB，因为InnoDB引擎支持事务处理。下面通过一个范例来演示事务处理中的回滚功能。</p><p>代码示例：(事务处理)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DBDRIVER=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DBURL=<span class="string">&quot;jdbc:mysql://localhost:3306/javaTest&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DBUSER=<span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DBPASSWORD=<span class="string">&quot;123456&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Connection conn=<span class="keyword">null</span>;<span class="comment">//声明静态的Connection对象</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    连接数据库</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">connDatebase</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            Class.forName(DBDRIVER);</span><br><span class="line">            conn=DriverManager.getConnection(DBURL,DBUSER,DBPASSWORD);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;MySQL数据库连接失败！&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> conn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    使用PreparedStatement执行SQL语句</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepared</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        PreparedStatement perstat=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            perstat=conn.prepareStatement(<span class="string">&quot;INSERT INTO StudentUser (id,name,password,sex,mail,college) VALUES (?,?,?,?,?,?)&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                perstat.setInt(<span class="number">1</span>,i);</span><br><span class="line">                perstat.setString(<span class="number">2</span>,<span class="string">&quot;小强&quot;</span>);</span><br><span class="line">                perstat.setString(<span class="number">3</span>,<span class="string">&quot;qian&quot;</span>);</span><br><span class="line">                perstat.setString(<span class="number">4</span>,<span class="string">&quot;男&quot;</span>);</span><br><span class="line">                perstat.setString(<span class="number">5</span>,<span class="string">&quot;qiangmzsx@gmail.com&quot;</span>);</span><br><span class="line">                perstat.setString(<span class="number">6</span>,<span class="string">&quot;信通学院&quot;</span>);</span><br><span class="line">                perstat.executeUpdate();<span class="comment">//执行更新</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    查询操作</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        PreparedStatement perstat=<span class="keyword">null</span>;</span><br><span class="line">        ResultSet res=<span class="keyword">null</span>;</span><br><span class="line">        String sql=<span class="string">&quot;SELECT id,name,password,sex,mail,college from StudentUser&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            perstat=conn.prepareStatement(sql);</span><br><span class="line">            res=perstat.executeQuery();</span><br><span class="line">            System.out.println(<span class="string">&quot;id\tname\tpassword\tsex\t\tmail\t\t\tcollege&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span>(res.next())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> id=res.getInt(<span class="number">1</span>);</span><br><span class="line">                String name=res.getString(<span class="number">2</span>);</span><br><span class="line">                String password=res.getString(<span class="number">3</span>);</span><br><span class="line">                String sex=res.getString(<span class="number">4</span>);</span><br><span class="line">                String mail=res.getString(<span class="number">5</span>);</span><br><span class="line">                String college=res.getString(<span class="number">6</span>);</span><br><span class="line">                System.out.println(id+<span class="string">&quot;\t&quot;</span>+name+<span class="string">&quot;\t&quot;</span>+password+<span class="string">&quot;\t\t&quot;</span>+ </span><br><span class="line"> sex+<span class="string">&quot;\t&quot;</span>+mail+<span class="string">&quot;\t\t&quot;</span>+college); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            Test tra=<span class="keyword">new</span> Test();</span><br><span class="line">            conn=tra.connDatebase();</span><br><span class="line">            conn.setAutoCommit(<span class="keyword">false</span>);<span class="comment">//关闭自动提交</span></span><br><span class="line">            System.out.println(<span class="string">&quot;数据库插入前：&quot;</span>);</span><br><span class="line">            tra.query();<span class="comment">//查询插入操作前的数据表</span></span><br><span class="line">            tra.prepared();<span class="comment">//执行插入操作</span></span><br><span class="line">            System.out.println(<span class="string">&quot;数据库插入后：&quot;</span>);</span><br><span class="line">            tra.query();</span><br><span class="line">            tra.conn.rollback();<span class="comment">//执行回滚操作</span></span><br><span class="line">            System.out.println(<span class="string">&quot;数据库回滚后：&quot;</span>);</span><br><span class="line">            tra.query();</span><br><span class="line">            conn.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://silenthty.gitee.io/photo/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/JDBC%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86.png" alt="" /></p><p>​在以上程序中实现了事务的回滚操作，但有两点需要注意，第一，JDBC的事务范围仅局限于一个数据库连接，不能跨越多个数据库连接；第二，在插入操作后，若执行commit()办法提交事务，则无法再进行回滚操作，即执行rollback()方法是没有效果的。</p><p>参考书目：</p><p><a href="http://product.dangdang.com/23248198.html?ref=book-35530-3032_5-231497-4">《Java编程手记——从实践中学习Java（配光盘）》(欧二强　等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)</a></p>]]></content>
    
    
    <summary type="html">这是显示在首页的概述，正文内容均会被隐藏。</summary>
    
    
    
    <category term="java" scheme="https://silenthly.github.io/categories/java/"/>
    
    
    <category term="笔记" scheme="https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>预处理操作:PreparedStatement接口</title>
    <link href="https://silenthly.github.io/2021/10/02/%E9%A2%84%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9CPreparedStatement%E6%8E%A5%E5%8F%A3/"/>
    <id>https://silenthly.github.io/2021/10/02/%E9%A2%84%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9CPreparedStatement%E6%8E%A5%E5%8F%A3/</id>
    <published>2021-10-02T04:21:13.000Z</published>
    <updated>2021-10-18T18:20:29.979Z</updated>
    
    <content type="html"><![CDATA[<p>​Statement接口用于向数据库发送SQL语句。在JDBC中含有3种类型的Statement对象，分别是Statement、PreparedStatement和CallableStatement。其中Statement对象用于执行静态的SQL语句，PreparedStatement对象用于执行动态的SQL语句，而CallableStatement对用于执行对数据库存储过程调用，本文介绍PreparedStatement接口的应用。</p><h4 id="preparedstatement接口"><a class="markdownIt-Anchor" href="#preparedstatement接口"></a> PreparedStatement接口</h4><p>​PreparedStatement接口的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PreparedStatement</span> <span class="keyword">extends</span> <span class="title">Statement</span></span></span><br></pre></td></tr></table></figure><p>​PreparedStatement继承了Statement接口，可以完成Statement所有的功能，用于执行动态的SQL语句，即包含参数的SQL语句。</p><p>​数据库在执行SQL语句的时候如果使用PreparedStatement语句会有一点优势：因为数据库会对PreparedStatement语句进行预编译，下次执行相同的SQL语句时，数据库端不会再进行预编译了，而是直接使用数据库的缓冲区，提高数据访问的效率（但尽量尽量采用使用？号的方式传递参数），如果SQL语句只执行一次，以后不再复用。PreparedStatement的常用方法如下表所示。</p><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">方法</th><th style="text-align:center">类型</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">public boolean execute()throws SQLException</td><td style="text-align:center">普通</td><td style="text-align:center">执行任意的SQL语句</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">public ResultSet executeQuery()throws Exception</td><td style="text-align:center">普通</td><td style="text-align:center">执行给定的SQL查询语句，该语句返回单个ResultSet对象</td></tr><tr><td style="text-align:center"><strong>3</strong></td><td style="text-align:center"><strong>public int executeUpdate()throws Exception</strong></td><td style="text-align:center"><strong>普通</strong></td><td style="text-align:center"><strong>执行给定的INSERT、UPDATE和DELETE的SQL语句，返回更新记录数</strong></td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">public void setLong(int parameterIndex,long x)throws Exception</td><td style="text-align:center">普通</td><td style="text-align:center">将指定索引设置为给定的long值，可重写为其他基本类型及Time，Timestamp型</td></tr></tbody></table><blockquote><p>提示：在程序开发中，大多数情况下都会使用PreparedStatement替代Statement。因为使用PreparedStatement可以提高代码的可读性和可维护性，同时也尽可能地提高程序的运行效率，最重要的是增强了安全性。</p></blockquote><h4 id="使用preparedstatement对数据库进行操作"><a class="markdownIt-Anchor" href="#使用preparedstatement对数据库进行操作"></a> 使用PreparedStatement对数据库进行操作</h4><p>​下面通过插入操作比较 Statement 和 PreparedStatement 的执行效率。分别向StudentUser表插入50条记录，使用Statement则需要传入50条插入语句，而PreparedStatement只需要传入一条SQL插入语句，然后再为PreparedStatement的参数设置即可。</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DBDRIVER=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DBURL=<span class="string">&quot;jdbc:mysql://localhost:3306/javaTest&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DBUSER=<span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DBPASSWORD=<span class="string">&quot;ren74520&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    连接数据库</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">connDatebase</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Connection con=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            Class.forName(DBDRIVER);</span><br><span class="line">            con=DriverManager.getConnection(DBURL,DBUSER,DBPASSWORD);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;MySQL数据库连接失败！&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> con;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    使用Statement实例执行SQL语句</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">statement</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Connection conn=<span class="keyword">null</span>;</span><br><span class="line">        Statement stat=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            conn=connDatebase();</span><br><span class="line">            stat=conn.createStatement();</span><br><span class="line">            <span class="keyword">long</span> start=System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">50</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                stat.executeUpdate(<span class="string">&quot;INSERT INTO StudentUser (id,name,password,sex,mail,college) VALUES (&quot;</span>+i+<span class="string">&quot;,&#x27;姓名&#x27;,&#x27;密码&#x27;,&#x27;性别&#x27;,&#x27;邮箱&#x27;,&#x27;学院&#x27;)&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;使用Statement插入耗时：&quot;</span>+(System.currentTimeMillis()-start));</span><br><span class="line">        &#125;<span class="keyword">catch</span>(SQLException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">            conn.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(SQLException e)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;MySQL数据库关闭失败！&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    使用PreparedStatement示例执行SQL语句</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepared</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Connection conn=<span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement perstat=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            conn=connDatebase();</span><br><span class="line">            perstat=conn.prepareStatement(<span class="string">&quot;INSERT INTO StudentUser (id,name,password,sex,mail,college) VALUES(?,&#x27;姓名&#x27;,&#x27;密码&#x27;,&#x27;性别&#x27;,&#x27;邮箱&#x27;,&#x27;学院&#x27;)&quot;</span>);</span><br><span class="line">            <span class="keyword">long</span> start=System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">51</span>;i&lt;=<span class="number">100</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                perstat.setInt(<span class="number">1</span>,i);</span><br><span class="line">                perstat.executeUpdate();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;使用PreparedStatement插入耗时：&quot;</span>+(System.currentTimeMillis()-start));</span><br><span class="line">        &#125;<span class="keyword">catch</span>(SQLException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">            conn.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(SQLException e)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;MySQL数据库关闭失败！&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Test per=<span class="keyword">new</span> Test();</span><br><span class="line">        per.statement();</span><br><span class="line">        per.prepared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​运行结果如图所示：</p><p><img src="https://silenthty.gitee.io/photo/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/JDBC%E9%A2%84%E5%8A%A0%E8%BD%BD1.png" alt="" /></p><p>​从程序运行结果可以发现，使用 PrepareStatement 消耗的时间反而比使用 Statement 消耗的时间要长，这是为什么呢？通过查找资料发现，PreparedStatement并不是绝对提高性能的，可以参考下方信息。</p><blockquote><p>对于Oracle（非常肯定，实践证明+测试结果表明）和PostgreSQL8（较肯定），使用PreparedStatement时，性能更高；<br />对于MySQL（非常肯定，测试结果表明），使用PreparedStatement时，性能反而低。</p></blockquote><p>​使用 Statement 时，执行的 SQL 语句需要拼接而成，容易产生错误，而使用 PreparedStatement 则不需要拼接 SQL 语句， 使用“?”进行占位。</p><p>参考链接：<a href="https://blog.csdn.net/yyg_5106/article/details/83368067">PreparedStatement真的比Statement快吗？_kang的专栏-CSDN博客</a></p><p>参考书目：</p><p><a href="http://product.dangdang.com/23248198.html?ref=book-35530-3032_5-231497-4">《Java编程手记——从实践中学习Java（配光盘）》(欧二强　等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​		Statement接口用于向数据库发送SQL语句。在JDBC中含有3种类型的Statement对象，分别是Statement、PreparedStatement和CallableStatement。其中Statement对象用于执行静态的SQL语句，PreparedS</summary>
      
    
    
    
    <category term="java" scheme="https://silenthly.github.io/categories/java/"/>
    
    
    <category term="笔记" scheme="https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>事务处理</title>
    <link href="https://silenthly.github.io/2021/10/01/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86(GUI)/"/>
    <id>https://silenthly.github.io/2021/10/01/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86(GUI)/</id>
    <published>2021-10-01T07:01:41.000Z</published>
    <updated>2021-10-18T15:22:58.304Z</updated>
    
    <content type="html"><![CDATA[<p>​前面介绍了多个 GUI 常用的组件和布局管理器，但是这些组件还不能响应用户的任何操作，如单击按钮没有任何响应。如果不对组件产生的事件进行处理，那么界面将不具有相应的功能，这样的 GUI 程序也没有多大意义。Java 语言为图形用户界面响应用户操作提供了相应的事件处理。</p><h3 id="事务处理的基本概念"><a class="markdownIt-Anchor" href="#事务处理的基本概念"></a> 事务处理的基本概念</h3><p>​Java 的事件处理采用了委托事件模式（Delegation Event Model）是指 GUI 组件将整个事件处理委托一个或多个事件监听器来处理。就是说当事件源发生指定的事件时，就通知所委托的事件监听器来处理该事件。</p><p>​委托事件模式主要涉及3部分：事件、事件源和事件监听器。</p><ul><li>事件是指一个描述事件源状态改变的对象，它作为用户对界面操作在 Java 语言上的描述。例如，按下按钮时，实际上这个按钮的状态就发生了改变，就会产生一个事件。</li><li>事件源是指产生事件的对象，通常就是各个组件。每当这些组件内部的状态发生改变时，事件就会产生。值得注意的是，一个事件源一次可以不止产生一个事件。</li><li>事件监听器是指在事件发生时被通知的对象，其中定义了当被监听的事件发生时系统要调用的方法。一个事件源必须注册监听器，以便监听器接收特定事件的通知。每一种事件都有各自的组成方法，一般形式如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTypeListener</span><span class="params">(TypeListener)</span></span></span><br></pre></td></tr></table></figure><p>​用于接收和处理事件的方法在 java.awt.event 中被定义为一系列的接口。最底层的监听器都是以接口的形式提供的，而一个接口中往往提供多个抽象方法，为了避免重复实现这些方法，系统提供了对这些方法实现的类，这些类就被称为适配器。</p><blockquote><p>提示：事件也可能不是用户直接触发的，可能是一个操作完成后而产生。</p></blockquote><p>​swing 编程中依旧使用 AWT 的事件处理方式，所有的事件都是 EventObject 的子类。这些事件监听器的接口大多定义在 java.awt.event 中，它们如下表所示。</p><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">接口</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">ActionListener</td><td style="text-align:center">用于接收<strong>操作事件</strong>的监视器接口，也就是用户对组件的操作，例如处理用户单击按钮时触发的事件</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">AdjustmentListenr</td><td style="text-align:center">用于接收<strong>调整事件</strong>的监听器接口，例如用户滑动滚动条触发的事件</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">FocusListenr</td><td style="text-align:center">用于接收组件上<strong>键盘焦点事件</strong>的监听器接口，例如将当前事件的焦点转移到某个对话框时使用</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">InputMethodListener</td><td style="text-align:center">接收<strong>输入方法事件</strong>的监听器接口。文本编辑组件必须安装输入方法事件监听器，以使用输入法</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">ItemListener</td><td style="text-align:center">用于处理<strong>选项事件</strong>的监听器接口，例如用户单击复选框时，处理相应的事件</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">KeyListener</td><td style="text-align:center">用于接收**键盘事件(击键)**的监听器接口。例如接收用户键盘输入信息时，处理用户的触击键盘事件</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">MouseListener</td><td style="text-align:center">用于处理<strong>鼠标事件</strong>(按下、释放、单击、进入或离开)的监听器接口</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">MouseMotionListener</td><td style="text-align:center">用于处理<strong>鼠标移动事件</strong>的监听器接口</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">WindowListener</td><td style="text-align:center">用于处理<strong>窗口事件</strong>的监听器接口，例如单击对话框上的最大化、最小化以及关闭等事件的实现</td></tr></tbody></table><h3 id="窗体事件"><a class="markdownIt-Anchor" href="#窗体事件"></a> 窗体事件</h3><p>​WindowListener 是用于处理窗口事件的监听器接口，对窗体的所有变化，包括窗口的最大化、最小化以及关闭等事件进行监听。WindowListener 接口的方法如下表所示。</p><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">方法</th><th style="text-align:center">类型</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><strong>1</strong></td><td style="text-align:center"><strong>void windowActicated(WindowEvent e)</strong></td><td style="text-align:center"><strong>普通</strong></td><td style="text-align:center"><strong>将窗口设置为活跃时触发</strong></td></tr><tr><td style="text-align:center"><strong>2</strong></td><td style="text-align:center"><strong>void windowClosed(WindowEvent e)</strong></td><td style="text-align:center"><strong>普通</strong></td><td style="text-align:center"><strong>将窗口关闭时触发</strong></td></tr><tr><td style="text-align:center"><strong>3</strong></td><td style="text-align:center"><strong>void windowClosing(WindowEvent e)</strong></td><td style="text-align:center"><strong>普通</strong></td><td style="text-align:center"><strong>窗口正在关闭时触发</strong></td></tr><tr><td style="text-align:center"><strong>4</strong></td><td style="text-align:center"><strong>void windowDeactivated(WindowEvent e)</strong></td><td style="text-align:center"><strong>普通</strong></td><td style="text-align:center"><strong>将窗口设置为非活跃时触发</strong></td></tr><tr><td style="text-align:center"><strong>5</strong></td><td style="text-align:center"><strong>void windowDeiconified(WindowEvent e)</strong></td><td style="text-align:center"><strong>普通</strong></td><td style="text-align:center"><strong>将窗口从最小化状态变为活动时触发</strong></td></tr><tr><td style="text-align:center"><strong>6</strong></td><td style="text-align:center"><strong>void windowIconified(WindowEvent e)</strong></td><td style="text-align:center"><strong>普通</strong></td><td style="text-align:center"><strong>将窗口设置为最小化时触发</strong></td></tr><tr><td style="text-align:center"><strong>7</strong></td><td style="text-align:center"><strong>void windowOpened(WindowEvent e)</strong></td><td style="text-align:center"><strong>普通</strong></td><td style="text-align:center"><strong>将窗口打开时触发</strong></td></tr></tbody></table><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.Point;</span><br><span class="line"><span class="keyword">import</span> java.awt.Dimension;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.WindowListener;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.WindowEvent;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JFrame;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WindowListenerClass</span> <span class="keyword">implements</span> <span class="title">WindowListener</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowOpened</span><span class="params">(WindowEvent e)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;窗口被打开.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowClosing</span><span class="params">(WindowEvent e)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;窗口将要被关闭.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowClosed</span><span class="params">(WindowEvent e)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;窗口被关闭.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowIconified</span><span class="params">(WindowEvent e)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;窗口被最小化......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowDeiconified</span><span class="params">(WindowEvent e)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;窗口被激活.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowActivated</span><span class="params">(WindowEvent e)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;窗口处于活动状态.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowDeactivated</span><span class="params">(WindowEvent e)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;窗口处于非活动状态.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] age)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        JFrame jf=<span class="keyword">new</span> JFrame(<span class="string">&quot;窗口事件&quot;</span>);</span><br><span class="line">        Dimension d=<span class="keyword">new</span> Dimension(<span class="number">400</span>,<span class="number">300</span>);</span><br><span class="line">        Point p=<span class="keyword">new</span> Point(<span class="number">250</span>,<span class="number">300</span>);</span><br><span class="line">        jf.setSize(d);</span><br><span class="line">        jf.setLocation(p);</span><br><span class="line">        jf.addWindowListener(<span class="keyword">new</span> WindowListenerClass());<span class="comment">//添加窗口事件监听器</span></span><br><span class="line">        jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">        jf.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://silenthty.gitee.io/photo/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/GUIx1.png" alt="" /></p><p>​以上程序实现了对窗口事件的监听，但是需要程序实现 WindowListener 接口中的所有方法，这无疑会增加劳动量。若只需要对窗口的最小化事件进行监听，并不需要监听其他的事件，那么直接使用监听接口是不合适的。为此 java 提供了各个事件的适配器，在实现类和接口之间增加一个过渡的抽象类，子类可以根据自身的需求实现事件处理中的方法。<strong>Window 事件的适配器是 WindowAdapter，子类只需要继承该类并覆写自己需要的方法即可。</strong></p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.event.WindowListener;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.WindowAdapter;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.WindowEvent;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JFrame;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">windowAdapterClass</span> <span class="keyword">extends</span> <span class="title">WindowAdapter</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowIconified</span><span class="params">(WindowEvent e)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;窗口被最小化.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        JFrame jf=<span class="keyword">new</span> JFrame(<span class="string">&quot;窗口事件&quot;</span>);</span><br><span class="line">        jf.setSize(<span class="number">400</span>,<span class="number">300</span>);</span><br><span class="line">        jf.setLocation(<span class="number">250</span>,<span class="number">300</span>);</span><br><span class="line">        jf.addWindowListener(<span class="keyword">new</span> windowAdapterClass());</span><br><span class="line">        jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">        jf.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://silenthty.gitee.io/photo/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/GUIx2.png" alt="" /></p><p>​除此之外，还可以使用匿名类来完成监听操作，这样有利于减少代码量增强代码的可读性。</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.event.WindowListener;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.WindowAdapter;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.WindowEvent;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JFrame;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        JFrame jf=<span class="keyword">new</span> JFrame(<span class="string">&quot;窗口事件&quot;</span>);</span><br><span class="line">        jf.setSize(<span class="number">400</span>,<span class="number">300</span>);</span><br><span class="line">        jf.setLocation(<span class="number">250</span>,<span class="number">300</span>);</span><br><span class="line">        jf.addWindowListener(<span class="keyword">new</span> WindowAdapter()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowIconified</span><span class="params">(WindowEvent e)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;窗口被最小化.....&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">        jf.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://silenthty.gitee.io/photo/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/GUIx3.png" alt="" /></p><p>​在以上程序中使用匿名类进行适配器的操作，可以减少监听类，这是在程序设计中最常用的方法。</p><h3 id="键盘事件"><a class="markdownIt-Anchor" href="#键盘事件"></a> 键盘事件</h3><p>​当用户按下或松开键盘上的按键时，就会产生一个键盘事件。在 Swing 编程中，可以使用 KeyListener 接口对键盘的操作进行监听。KeyListener 接口提供了用于处理键盘事件的方法，在键盘事件被触发时，会产生一个 KeyEvent 事件对象。KeyEvent 负责捕获键盘事件，可以通过 getKeyCode() 方法获取按下的是键盘上的哪个按键。KeyListener 接口的方法如下表所示。</p><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">方法</th><th style="text-align:center">类型</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">void keyPressed(KeyEvent e)</td><td style="text-align:center">普通</td><td style="text-align:center">在键盘上的按键被按下使调用此方法</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">void keyReleased(KeyEvent e)</td><td style="text-align:center">普通</td><td style="text-align:center">在键盘上的按键被释放时调用此方法</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">void keyTyped(KeyEvent e)</td><td style="text-align:center">普通</td><td style="text-align:center">在按下键盘上的按键输入一个字符时调用此方法</td></tr></tbody></table><p>​在 KeyLisiener 接口中的每一个方法都传入 KeyEvent 对象，KeyEvent 类的常用方法如下表所示。</p><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">方法</th><th style="text-align:center">类型</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><strong>1</strong></td><td style="text-align:center"><strong>char getKeyChar()</strong></td><td style="text-align:center"><strong>普通</strong></td><td style="text-align:center"><strong>返回此事件中的键关联的字符</strong></td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">int getKeyCode()</td><td style="text-align:center">普通</td><td style="text-align:center">返回此事件中的键关联的整数keyCode</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">int getLocation()</td><td style="text-align:center">普通</td><td style="text-align:center">返回产生此按键事件的键位置</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">static String getKeyModifiersText(int modifiers)</td><td style="text-align:center">静态</td><td style="text-align:center">返回描述修改键的String，如Shift或Ctrl+Shift</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">static String getKeyText(int keyCode)</td><td style="text-align:center">静态</td><td style="text-align:center">返回描述 KeyCode 的String，如HOME、F1或A</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">boolean isActionKey()</td><td style="text-align:center">普通</td><td style="text-align:center">返回此事件中的键是否为&quot;动作&quot;键</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">String  paremString()</td><td style="text-align:center">普通</td><td style="text-align:center">返回标识此事件的参数字符串</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">void setKeyChar(char keyChar)</td><td style="text-align:center">普通</td><td style="text-align:center">设置keyChar值，以表示某个逻辑字符</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">void setKeyCode(int keyCode)</td><td style="text-align:center">普通</td><td style="text-align:center">设置keyCode值，以表示某个物理按键</td></tr></tbody></table><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.event.KeyEvent;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.KeyAdapter;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JFrame;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JTextArea;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JScrollPane;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    JTextArea text=<span class="keyword">new</span> JTextArea(<span class="number">5</span>,<span class="number">20</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        JFrame jf=<span class="keyword">new</span> JFrame(<span class="string">&quot;键盘事件&quot;</span>);</span><br><span class="line">        JScrollPane scroll=<span class="keyword">new</span> JScrollPane(text);</span><br><span class="line">        jf.add(scroll);</span><br><span class="line">        jf.setSize(<span class="number">400</span>,<span class="number">300</span>);</span><br><span class="line">        jf.setLocation(<span class="number">250</span>,<span class="number">300</span>);</span><br><span class="line">        text.addKeyListener(<span class="keyword">new</span> KeyAdapter()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">keyTyped</span><span class="params">(KeyEvent e)</span></span>&#123;</span><br><span class="line">                text.append(<span class="string">&quot;\n 按下的按键为：&quot;</span>+e.getKeyChar()+<span class="string">&quot;\n&quot;</span>); </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;);</span><br><span class="line">        jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">        jf.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://silenthty.gitee.io/photo/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/GUIx4.png" alt="" /></p><h3 id="行为事件"><a class="markdownIt-Anchor" href="#行为事件"></a> 行为事件</h3><p>​ActionListener 接口用于处理行为事件，也就是用户对组件的操作，如 ActionListener 接口可以处理按钮的行为事件。ActionListener 接口中只有一个方法如下表所示。</p><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">方法</th><th style="text-align:center">类型</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><strong>1</strong></td><td style="text-align:center"><strong>void actionPerformed(ActionEvent e)</strong></td><td style="text-align:center"><strong>普通</strong></td><td style="text-align:center"><strong>发生操作时调用</strong></td></tr></tbody></table><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.event.ActionListener;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionEvent;</span><br><span class="line"><span class="keyword">import</span> java.awt.Font;</span><br><span class="line"><span class="keyword">import</span> java.awt.GridLayout;</span><br><span class="line"><span class="keyword">import</span> java.awt.Color;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JLabel;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JFrame;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JButton;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        JFrame jf=<span class="keyword">new</span> JFrame(<span class="string">&quot;行为事件&quot;</span>);</span><br><span class="line">        JButton button=<span class="keyword">new</span> JButton(<span class="string">&quot;按钮事件源&quot;</span>);</span><br><span class="line">        Font font=<span class="keyword">new</span> Font(<span class="string">&quot;楷体&quot;</span>,Font.BOLD+Font.PLAIN,<span class="number">20</span>);</span><br><span class="line">        JLabel label=<span class="keyword">new</span> JLabel(<span class="string">&quot;没有按下按钮&quot;</span>,JLabel.CENTER);</span><br><span class="line">        label.setFont(font);</span><br><span class="line">        label.setForeground(Color.red);</span><br><span class="line">        jf.setLayout(<span class="keyword">new</span> GridLayout(<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>));</span><br><span class="line">        button.addActionListener(<span class="keyword">new</span> ActionListener()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                count++;</span><br><span class="line">                label.setText(<span class="string">&quot;第&quot;</span>+count+<span class="string">&quot;次按下按钮！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        jf.add(label);</span><br><span class="line">        jf.add(button);</span><br><span class="line">        jf.setSize(<span class="number">400</span>,<span class="number">300</span>);</span><br><span class="line">        jf.setLocation(<span class="number">250</span>,<span class="number">300</span>);</span><br><span class="line">        jf.setDefaultCloseOperation(jf.EXIT_ON_CLOSE);</span><br><span class="line">        jf.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://silenthty.gitee.io/photo/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/GUIx5.png" alt="" /></p><p><img src="https://silenthty.gitee.io/photo/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/GUIx6.png" alt="" /></p><p>​以上程序中，在按下按钮后标签中的文字就会改变。</p><p>参考书目：</p><p><a href="http://product.dangdang.com/23248198.html?ref=book-35530-3032_5-231497-4">《Java编程手记——从实践中学习Java（配光盘）》(欧二强　等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​		前面介绍了多个 GUI 常用的组件和布局管理器，但是这些组件还不能响应用户的任何操作，如单击按钮没有任何响应。如果不对组件产生的事件进行处理，那么界面将不具有相应的功能，这样的 GUI 程序也没有多大意义。Java 语言为图形用户界面响应用户操作提供了相应的事件处理。</summary>
      
    
    
    
    <category term="java" scheme="https://silenthly.github.io/categories/java/"/>
    
    
    <category term="笔记" scheme="https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>接收操作数据库结果</title>
    <link href="https://silenthly.github.io/2021/10/01/%E6%8E%A5%E6%94%B6%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%93%E6%9E%9C/"/>
    <id>https://silenthly.github.io/2021/10/01/%E6%8E%A5%E6%94%B6%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%93%E6%9E%9C/</id>
    <published>2021-10-01T00:32:55.000Z</published>
    <updated>2021-10-18T16:46:03.809Z</updated>
    
    <content type="html"><![CDATA[<p>​数据库操作中使用最多的就是查询操作。java程序对数据库进行查询操作时，需要利用SQL语句中的SELECT命令查询得到结果，然后将结果放在一个ResultSet集中，再遍历这个集合，就可以做关于此查询的操作。</p><h3 id="查询数据"><a class="markdownIt-Anchor" href="#查询数据"></a> 查询数据</h3><p>​为了能更清楚地讲解数据库的查询操作，我们先向 StudentUser 表中添加多条记录，其 SQL 语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO StudentUser (id,name,password,sex,mail,college) VALUES </span><br><span class="line">(12,&#x27;小明&#x27;,&#x27;ming&#x27;,&#x27;男&#x27;,&#x27;ming@mail.com&#x27;,&#x27;海运学院&#x27;),</span><br><span class="line">(34,&#x27;小婷&#x27;,&#x27;ting&#x27;,&#x27;女&#x27;,&#x27;tingx@cumt.edu.cn&#x27;,&#x27;外语学院&#x27;), </span><br><span class="line">(56,&#x27;小华&#x27;,&#x27;hua&#x27;,&#x27;男&#x27;,&#x27;huaql@gmail.com&#x27;,&#x27;信通学院&#x27;), </span><br><span class="line">(78,&#x27;小琴&#x27;,&#x27;xiaoqin&#x27;,&#x27;女&#x27;,&#x27;567890@uu.com&#x27;,&#x27;外语学院&#x27;), </span><br><span class="line">(90,&#x27;晓同&#x27;,&#x27;tong&#x27;,&#x27;男&#x27;,&#x27;tonglx@gmail.com&#x27;,&#x27;信通学院&#x27;); </span><br></pre></td></tr></table></figure><p>​执行上面的 SQL 语句后，查看 MySQL 数据库中的 StudentUser 表，得到如图1所示的结果。</p><p><img src="https://silenthty.gitee.io/photo/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/JDBC%E6%8E%A5%E6%94%B61.png" alt="" /></p><center>图1</center><p>​数据库的查询操作使用的是 Statement 接口的 executeQuery()方法，该方法返回的是 ResultSet 实例，此实例中存放了所有的查询结果，再通过 ResultSet 接口的 next()方法将查询的结果一条条地输出。next()方法返回的boolean值，当指针移动最后一行时就会返回false。 下面通过一个范例实现将 StudentUser 表中的全部数据显示在控制台上。</p><p>代码示例：(顺序查询)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DBDRIVER=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DBURL=<span class="string">&quot;jdbc:mysql://localhost:3306/javaTest&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DBUSER=<span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DBPASSWORD=<span class="string">&quot;ren74520&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Connection conn=<span class="keyword">null</span>;</span><br><span class="line">        Statement stat=<span class="keyword">null</span>;</span><br><span class="line">        ResultSet res=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        String sql=<span class="string">&quot;SELECT id,name,password,sex,mail,college FROM StudentUser&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            Class.forName(DBDRIVER);</span><br><span class="line">            System.out.println(<span class="string">&quot;JDBC加载成功！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;JDBC加载失败！&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            conn=DriverManager.getConnection(DBURL,DBUSER,DBPASSWORD);</span><br><span class="line">            stat=conn.createStatement();</span><br><span class="line">            res=stat.executeQuery(sql);</span><br><span class="line">            System.out.println(<span class="string">&quot;id\tname\tpassword\tsex\t\tmail\t\t\tcollege&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span>(res.next())</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">int</span> id=res.getInt(<span class="number">1</span>);</span><br><span class="line">                String name=res.getString(<span class="number">2</span>);</span><br><span class="line">                String password=res.getString(<span class="number">3</span>);</span><br><span class="line">                String sex=res.getString(<span class="number">4</span>);</span><br><span class="line">                String mail=res.getString(<span class="number">5</span>);</span><br><span class="line">                String college=res.getString(<span class="number">6</span>);</span><br><span class="line">                System.out.println(id+<span class="string">&quot;\t&quot;</span>+name+<span class="string">&quot;\t&quot;</span>+password+<span class="string">&quot;\t\t&quot;</span>+ </span><br><span class="line"> sex+<span class="string">&quot;\t&quot;</span>+mail+<span class="string">&quot;\t\t&quot;</span>+college); </span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;\n 此次查询的结果集中的数目：&quot;</span>+count+<span class="string">&quot;条&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">                System.out.println(<span class="string">&quot;数据库关闭成功！&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;数据库关闭失败！&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如图2所示：</p><p><img src="https://silenthty.gitee.io/photo/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/JDBC%E6%8E%A5%E6%94%B62.png" alt="" /></p><center>图2</center><p>​在以上程序中，先用 SQL 语句查询并获取一个结果集，然后遍历这个结果集，将其记录输出到屏幕。这个结果集由 ResultSet 实例接收并保存在内存之中。除了上面以顺序编码的形式将内容读取出来，还可以在读取数据时输入列的名称，如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(res.next())</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">int</span> id=res.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">    String name=res.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    String password=res.getString(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    String sex=res.getString(<span class="string">&quot;sex&quot;</span>);</span><br><span class="line">    String mail=res.getString(<span class="string">&quot;mail&quot;</span>);</span><br><span class="line">    String college=res.getString(<span class="string">&quot;college&quot;</span>);</span><br><span class="line">    System.out.println(id+<span class="string">&quot;\t&quot;</span>+name+<span class="string">&quot;\t&quot;</span>+password+<span class="string">&quot;\t\t&quot;</span>+ </span><br><span class="line"> sex+<span class="string">&quot;\t&quot;</span>+mail+<span class="string">&quot;\t\t&quot;</span>+college); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以上程序的 SQL 查询语句虽然可以写成“SELECT * FROM StudentUser;”，但笔 者不推荐在程序开发中这么使用，最好是明确写出需要查询的列。</p></blockquote><h3 id="牛刀小试"><a class="markdownIt-Anchor" href="#牛刀小试"></a> 牛刀小试</h3><p>比较 Statement 接口中的 execute()、executeQuery()和 executeUpdate()方法。</p><blockquote><p>答：execute()方法用于执行返回多个结果集、多个更新计数或二者相结合的语句。executeQuery()产生一个结果集的语句，常用于执行 SELECT 命令的 SQL 语句。executeUpdate()方法用于执行 INSERT、UPDATE、DELETE 语句和 SQL 语言的 DDL 语句。executeUpdate()方法返回的是一个整型，表示受影响的记录数。对于 CREATE TABLE 和 DROP TABLE 等不操作记录的语句，返回值为 0。</p></blockquote><p>参考书目：</p><p><a href="http://product.dangdang.com/23248198.html?ref=book-35530-3032_5-231497-4">《Java编程手记——从实践中学习Java（配光盘）》(欧二强　等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​		数据库操作中使用最多的就是查询操作。java程序对数据库进行查询操作时，需要利用SQL语句中的SELECT命令查询得到结果，然后将结果放在一个ResultSet集中，再遍历这个集合，就可以做关于此查询的操作。&lt;/p&gt;
&lt;h3 id=&quot;查询数据&quot;&gt;&lt;a class=&quot;m</summary>
      
    
    
    
    <category term="java" scheme="https://silenthly.github.io/categories/java/"/>
    
    
    <category term="笔记" scheme="https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>JAVA对数据库的更新操作</title>
    <link href="https://silenthly.github.io/2021/09/30/JAVA%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%9B%B4%E6%96%B0%E6%93%8D%E4%BD%9C/"/>
    <id>https://silenthly.github.io/2021/09/30/JAVA%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%9B%B4%E6%96%B0%E6%93%8D%E4%BD%9C/</id>
    <published>2021-09-30T15:54:11.000Z</published>
    <updated>2021-10-19T13:26:11.100Z</updated>
    
    <content type="html"><![CDATA[<p>​获得数据库的连接后，程序就可以操作数据库了，本节将介绍数据库的数据更新操作，这就需要将SQL语句传入Statement对象中，再执行executeUpdate()方法即可。</p><h3 id="执行数据库插入操作"><a class="markdownIt-Anchor" href="#执行数据库插入操作"></a> 执行数据库插入操作</h3><p>​数据库的更新操作需要对数据表进行操作，为此先建立一个StudentUser表，其SQL语句如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE StudentUser(</span><br><span class="line">id INT NOT NULL PRIMARY KEY,</span><br><span class="line">name VARCHAR(15) NOT NULL,</span><br><span class="line">password VARCHAR(20) NOT NULL,</span><br><span class="line">sex VARCHAR(2) NOT NULL,</span><br><span class="line">mail VARCHAR(25),</span><br><span class="line">college VARCHAR(15) NOT NULL</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>执行以下命令查看表结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DESC 表名;</span><br></pre></td></tr></table></figure><p>StudentUser表结构如图：</p><p><img src="https://silenthty.gitee.io/photo/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/JDBC%E6%9B%B4%E6%96%B01.png" alt="" /></p><center>图1</center><p>​由于插入表的信息中含有中文字符，因此在执行插入语句前先把表中所有属性的编码更改为UTF-8，表自身的编码可改可不改。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE StudentUser CONVERT TO CHARACTER SET utf8;</span><br></pre></td></tr></table></figure><p>​下面通过java程序向StudentUser表中插入一条新的记录，其中的SQL语句为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO StudentUser (id,name,password,sex,mail,college) values (123456,&#x27;小明&#x27;,&#x27;ming&#x27;,&#x27;男&#x27;,&#x27;ming@mail.com&#x27;,&#x27;麻省理工&#x27;);</span><br></pre></td></tr></table></figure><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Connection conn=<span class="keyword">null</span>;</span><br><span class="line">        Statement stat=<span class="keyword">null</span>;</span><br><span class="line">        String sql=<span class="string">&quot;INSERT INTO StudentUser (id,name,password,sex,mail,college) values (123456,&#x27;小明&#x27;,&#x27;ming&#x27;,&#x27;男&#x27;,&#x27;ming@mail.com&#x27;,&#x27;麻省理工&#x27;)&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);<span class="comment">//加载JDBC</span></span><br><span class="line">            System.out.println(<span class="string">&quot;JDBC加载成功！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;JDBC加载失败&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            conn=DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/javaTest&quot;</span>,<span class="string">&quot;root&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;MySQL数据库连接成功！&quot;</span>);</span><br><span class="line">            stat=conn.createStatement();</span><br><span class="line">            stat.executeUpdate(sql);</span><br><span class="line">            System.out.println(<span class="string">&quot;数据插入成功！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">                System.out.println(<span class="string">&quot;数据库关闭成功！&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;数据库关闭失败！&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Loading <span class="class"><span class="keyword">class</span> `<span class="title">com</span>.<span class="title">mysql</span>.<span class="title">cj</span>.<span class="title">jdbc</span>.<span class="title">Driver</span>&#x27;. <span class="title">This</span> <span class="title">is</span> <span class="title">deprecated</span>. <span class="title">The</span> <span class="title">new</span> <span class="title">driver</span> <span class="title">class</span> <span class="title">is</span> `<span class="title">com</span>.<span class="title">mysql</span>.<span class="title">cj</span>.<span class="title">jdbc</span>.<span class="title">Driver</span>&#x27;. <span class="title">The</span> <span class="title">driver</span> <span class="title">is</span> <span class="title">automatically</span> <span class="title">registered</span> <span class="title">via</span> <span class="title">the</span> <span class="title">SPI</span> <span class="title">and</span> <span class="title">manual</span> <span class="title">loading</span> <span class="title">of</span> <span class="title">the</span> <span class="title">driver</span> <span class="title">class</span> <span class="title">is</span> <span class="title">generally</span> <span class="title">unnecessary</span>.</span></span><br><span class="line"><span class="class"><span class="title">JDBC</span>加载成功！</span></span><br><span class="line"><span class="class"><span class="title">MySQL</span>数据库连接成功！</span></span><br><span class="line"><span class="class">数据插入成功！</span></span><br><span class="line"><span class="class">数据库关闭成功！</span></span><br></pre></td></tr></table></figure><p>​程序结果如上所示，执行完或查看MySQL数据库中的StudentUser表，得到如图2所示结果。</p><p><img src="https://silenthty.gitee.io/photo/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/JDBC%E6%9B%B4%E6%96%B02.png" alt="" /></p><center>图2</center><h3 id="修改数据"><a class="markdownIt-Anchor" href="#修改数据"></a> 修改数据</h3><p>​使用SQL语句的UPDATE命令可以修改数据表中的数据，范例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Connection conn=<span class="keyword">null</span>;</span><br><span class="line">        Statement stat=<span class="keyword">null</span>;</span><br><span class="line">        String sql=<span class="string">&quot;UPDATE StudentUser SET College=&#x27;清华大学&#x27; WHERE id=123456;&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;JDBC加载成功！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;JDBC加载失败&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            conn=DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/javatest&quot;</span>,<span class="string">&quot;root&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;数据库连接成功！&quot;</span>);</span><br><span class="line">            stat=conn.createStatement();</span><br><span class="line">            stat.executeUpdate(sql);</span><br><span class="line">            System.out.println(<span class="string">&quot;数据修改成功！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">                System.out.println(<span class="string">&quot;数据库关闭成功&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;数据库关闭失败&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​以上程序执行完或查看MySQL数据库中的StudentUser表，得到如图3所示结果。</p><p><img src="https://silenthty.gitee.io/photo/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/JDBC%E6%9B%B4%E6%96%B03.png" alt="" /></p><center>图3</center><h3 id="执行数据库删除操作"><a class="markdownIt-Anchor" href="#执行数据库删除操作"></a> 执行数据库删除操作</h3><p>​数据库只要执行SQL语句中的DELETE命令，即可完成记录的删除操作。在程序设计中，一般将驱动程序、数据库URL甚至用户名和密码设置成public static final属性。</p><p>代码示例：(删除数据)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DBDRIVER=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DBURL=<span class="string">&quot;jdbc:mysql://localhost:3306/javatest&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DBUSER=<span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DBPASSWORD=<span class="string">&quot;123456&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Scanner scan=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入要删除的账号：&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> id=scan.nextInt();</span><br><span class="line">        Connection conn=<span class="keyword">null</span>;</span><br><span class="line">        Statement stat=<span class="keyword">null</span>;</span><br><span class="line">        String sql=<span class="string">&quot;DELETE FROM StudentUser WHERE id=id&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            Class.forName(DBDRIVER);</span><br><span class="line">            System.out.println(<span class="string">&quot;JDBC加载成功！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;JDBC加载失败！&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            conn=DriverManager.getConnection(DBURL,DBUSER,DBPASSWORD);</span><br><span class="line">            System.out.println(<span class="string">&quot;数据库连接成功！&quot;</span>);</span><br><span class="line">            stat=conn.createStatement();</span><br><span class="line">            stat.executeUpdate(sql);</span><br><span class="line">            System.out.println(<span class="string">&quot;数据删除成功&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                </span><br><span class="line">                conn.close();</span><br><span class="line">                System.out.println(<span class="string">&quot;数据库关闭成功！&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;数据库关闭失败！&quot;</span>);</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​以上程序执行完或查看MySQL数据库中的StudentUser表，得到以下结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Empty set (0.00 sec)</span><br></pre></td></tr></table></figure><p>参考书目：</p><p><a href="http://product.dangdang.com/23248198.html?ref=book-35530-3032_5-231497-4">《Java编程手记——从实践中学习Java（配光盘）》(欧二强　等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​		获得数据库的连接后，程序就可以操作数据库了，本节将介绍数据库的数据更新操作，这就需要将SQL语句传入Statement对象中，再执行executeUpdate()方法即可。&lt;/p&gt;
&lt;h3 id=&quot;执行数据库插入操作&quot;&gt;&lt;a class=&quot;markdownIt-Anc</summary>
      
    
    
    
    <category term="java" scheme="https://silenthly.github.io/categories/java/"/>
    
    
    <category term="笔记" scheme="https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>连接数据库</title>
    <link href="https://silenthly.github.io/2021/09/30/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%BF%9E%E6%8E%A5/"/>
    <id>https://silenthly.github.io/2021/09/30/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%BF%9E%E6%8E%A5/</id>
    <published>2021-09-30T00:34:34.000Z</published>
    <updated>2021-10-19T13:26:31.294Z</updated>
    
    <content type="html"><![CDATA[<h3 id="配置mysql数据库的驱动程序"><a class="markdownIt-Anchor" href="#配置mysql数据库的驱动程序"></a> 配置MySQL数据库的驱动程序</h3><p>​在连接之前首先需要下载连接MySQL数据库的JDBC驱动程序。可以到MySQL的官方网站下载相应的JDBC驱动程序，网址为：<a href="https://dev.mysql.com/downloads/connector/j/">MySQL :: Download Connector/J</a>，下载流程如下列图示，本文下载的是mysql-connector-java-8.0.26.zip。</p><p><img src="https://silenthty.gitee.io/photo/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/JDBC%E9%85%8D%E7%BD%AE1.png" alt="" /></p><center>图1</center><p><img src="https://silenthty.gitee.io/photo/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/JDBC%E9%85%8D%E7%BD%AE2.png" alt="" /></p><center>图2</center><p><img src="https://silenthty.gitee.io/photo/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/JDBC%E9%85%8D%E7%BD%AE3.png" alt="" /></p><center>图3</center><blockquote><p>提示：在图 3 页面中，有两个 JDBC 文件，一个是 mysql-connector-java-5.1.22.tar.gz， 一个是 mysql-connector-java-5.1.22.zip。前者用于 Linux 操作系统，而后者用于 Windows 操作系统。这些文件中都含有驱动程序的源代码、文档和 jar 文件，源代码可以由用于自己编译，jar 文件名为 mysql-connector-java-5.1.22-bin.jar。</p></blockquote><p>​下载完成后，需要对其进行配置，才能建立连接。现在假定将MySQL数据库的JDBC驱动程序保存到C:\Program Files\MySQL\MySQL Server 5.7\mysql-connector-java-8.0.26.jar 路径中（这里的路径并不唯一，可以任意存放，这里为了方便放在MySQL的文件夹下，但需明确存放的路径），再将该路径配置到CLASSPATH中（可以参考win10的环境配置），如下图所示。</p><p><img src="https://silenthty.gitee.io/photo/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/JDBC%E9%85%8D%E7%BD%AE4.png" alt="" /></p><center>图4</center><h3 id="jdbc连接数据库步骤"><a class="markdownIt-Anchor" href="#jdbc连接数据库步骤"></a> JDBC连接数据库步骤</h3><p>​MySQL数据库的驱动程序配置完成后，即可按照以下的步骤进行MySQL数据库的连接和操作。</p><p>（1）加载JDBC驱动程序</p><p>​可以使用以下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;org.git.mm.mysql.Driver&quot;</span>);</span><br></pre></td></tr></table></figure><blockquote><p>提示：org.gjt.mm.mysql.Driver 是 MySQL 数据库早期的驱动名称，后来改为了 com.mysql.cj.jdbc.Driver，推荐使用后者。在新的版本中，为了兼容前期的版本， 仍然保留在 org.gjt.mm.mysql.Driver，实际上没有功能上的差异。另网上可以经常看到驱动的名称为com.mysql.jdbc.Driver，这也是早期的驱动名称，现已废弃。</p></blockquote><p>（2）建立连接</p><p>​加载了驱动程序后，就可以建立连接了。这需要使用java.sql包中的Connection类来声明一个对象，再使用类DriverManager的静态方法getConnection()创建连接对象。方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection conn=DriverManager.getConnection(url,userName,passWord);</span><br></pre></td></tr></table></figure><p>​其中，url指定要连接的数据库名，一般形式为&quot;jdbc:mysql://数据库主机名/数据库名&quot;；userName表示数据库用户名；passWord表示与用户名相对应的密码。</p><blockquote><p>提示：此处的数据库可以是本地数据库，也可以是远程数据库。</p></blockquote><p>（3）使用SQL语句进行数据库操作。</p><p>​数据库的操作主要分为数据更新和数据查询。</p><p>（4）释放资源</p><p>​数据库操作完成后，还需要关闭数据库连接以释放资源。方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conn.close();</span><br></pre></td></tr></table></figure><p>​一般将释放资源的操作放在finally语句块中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Connection conn=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);<span class="comment">//加载JDBC驱动</span></span><br><span class="line">            System.out.println(<span class="string">&quot;JDBC加载成功！！！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;MySQL数据库的JDBC加载失败！！！！&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            conn=DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/javatest&quot;</span>,<span class="string">&quot;root&quot;</span>,<span class="string">&quot;123456&quot;</span>);<span class="comment">//创建与数据库的连接</span></span><br><span class="line">            System.out.println(<span class="string">&quot;MySQL数据库连接成功！！！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;MySQL数据库连接失败！！！！&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">                System.out.println(<span class="string">&quot;MySQL数据库关闭成功！！！&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;MySQL数据库关闭失败！！！！&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如图1所示</p><p><img src="https://silenthty.gitee.io/photo/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/JDBC2.png" alt="" /></p><center>图5</center><p>若运行结果如图2所示，则说明配置CLASSPATH没有成功。</p><p><img src="https://silenthty.gitee.io/photo/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/JDBC3.png" alt="" /></p><center>图6</center><p>参考书目：</p><p><a href="http://product.dangdang.com/23248198.html?ref=book-35530-3032_5-231497-4">《Java编程手记——从实践中学习Java（配光盘）》(欧二强　等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;配置mysql数据库的驱动程序&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#配置mysql数据库的驱动程序&quot;&gt;&lt;/a&gt; 配置MySQL数据库的驱动程序&lt;/h3&gt;
&lt;p&gt;​		在连接之前首先需要下载连接MySQL数据库的JDBC驱动程序</summary>
      
    
    
    
    <category term="java" scheme="https://silenthly.github.io/categories/java/"/>
    
    
    <category term="笔记" scheme="https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>JDBC编程</title>
    <link href="https://silenthly.github.io/2021/09/28/JDBC%E5%B8%B8%E8%A7%81%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%B1%BB/"/>
    <id>https://silenthly.github.io/2021/09/28/JDBC%E5%B8%B8%E8%A7%81%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%B1%BB/</id>
    <published>2021-09-28T14:14:23.000Z</published>
    <updated>2021-10-18T16:47:39.102Z</updated>
    
    <content type="html"><![CDATA[<p>​无论是哪一个程序设计语言，想要操作数据库，第一件事就是连接数据库。java语言提供了多种方式连接数据库，都是通过JDBC来进行连接的。本文将介绍JDBC的基本知识。</p><h3 id="认识jdbc"><a class="markdownIt-Anchor" href="#认识jdbc"></a> 认识JDBC</h3><p>​JDBC是java Database Connectivity的缩写，其中文含义是<strong>java数据库连接</strong>。<strong>JDBC提供了一组与平台无关性，可用于连接数据库及执行SQL语句的API</strong>。JDBC允许用户从java程序访问任何支持SQL语言的关系型数据库，它由一组用java编程语言编写的类和接口组成。</p><p>​在程序设计中可以直接使用JDBC进行各个关系数据库的连接和操作，可以向数据库发送SQL语句。就是说，开发人员不需要为访问不同的数据库而编写不同的程序。JDBC中含有一套标准的接口，为许多不同的数据库连接模块的前端提供统一的接口。java语言编写的程序可以在支持java的平台上运行，而JDBC就是使用java语言编写的。因此，java与JDBC的结合，可以让程序实现 Write Once，Run Anywhere。java程序、JDBC和各个数据库之间的关系如图所示：</p><p><img src="https://silenthty.gitee.io/photo/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/JDBC1.png" alt="" /></p><p>​大部分的数据库系统都有自己的JDBC驱动程序，如 Oracle、MySQL 和 Sybase 等。但某些特定的数据库，还需要相应的数据库驱动，如 Access 数据需要的是 JDBC-ODBC 桥进行数据库的连接。目前比较常见的 JDBC 驱动程序主要有以下 4 类。</p><ul><li>**JDBC-ODBC 桥：JDBC-ODBC桥驱动程序使用ODBC驱动程序来连接数据库。JDBC-ODBC桥驱动程序将JDBC方法调用转换为ODBC函数调用。**这种方式利用ODBC驱动程序提供JDBC访问数据库，即允许JDBC驱动程序被用于ODBC的驱动程序。必须将ODBC二进制加载到使用到驱动程序的每一个客户机上。但这种方式操作性能低，不推荐使用。</li><li>**本地API部分java驱动程序：本地API驱动程序使用数据库提供的客户端库。驱动程序将JDBC方法调用转换为数据库API的本机调用。它不是完全用Java编写的。**这类的驱动程序把客户机API的JDBC转换为Oracle、DB2、Sybase、Informix 或其他 DBMS（数据库管理系统）的调用。这种类型要求驱动程序与应用程序一起驻留在客户机上，并直接与数据库服务器进行通信。这种驱动连接方式不能应用在 Internet 上且只能应用在特定的数据库上，会丧失可移植性。</li><li>**JDBC网络纯java驱动程序：网络协议驱动程序使用中间件（应用程序服务器），该中间件将JDBC调用直接或间接转换为供应商特定的数据库协议。它是完全用Java编写的。**这种驱动程序将JDBC转换为DBMS无关的网络协议，之后再被某个服务器转换为一种DBMS协议。它是一种利用java语言编写的JDBC驱动程序，也是目前最灵活的JDBC驱动程序。所有这种解决方案的提供者，都提供了适合于Internet用户的产品。为了使这些产品支持internet，它们必须处理Web所提出的安全性、通过防火墙的访问等额外要求。</li><li>**本地协议纯java驱动程序：本地协议驱动将JDBC调用直接转换为供应商特定的数据库协议。这就是为什么它被称为本地协议驱动。它完全用Java语言编写。**这种类型的驱动程序将JDBC调用直接转换为BDMS所使用的网络协议，这将允许从客户机上直接调用DBMS服务器，是Internet访问的一个实用的解决方法。此方式的执行效率非常高，不需要在客户端装载任何的软件或驱动程序，这种驱动程序可以被动态下载，但是对于不同的数据库需要下载不同的驱动程序。</li></ul><h3 id="jdbc常见接口和类"><a class="markdownIt-Anchor" href="#jdbc常见接口和类"></a> JDBC常见接口和类</h3><p>​JDBC提供了独立于数据库的统一API，让用户能够创建数据库连接、执行SQL语句、查询结果集等操作。要操作数据库，一般需要通过下面的类及接口来实现。</p><h4 id="dirvermanager类"><a class="markdownIt-Anchor" href="#dirvermanager类"></a> DirverManager类</h4><p>​**DriverManager类用来管理数据库中所有的驱动程序，作用于用户和驱动程序之间。**DirverManger类用于跟踪可用的驱动程序，并在数据库和相应驱动程序之间建立连接。**DriverManger类也可以处理驱动程序登录时间限制，及登录和跟踪信息的显示等事务。**DriverManger类常用方法如下表所示。</p><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">方法</th><th style="text-align:center">类型</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">public static Connection getConnection(String url)throws SQLException</td><td style="text-align:center">静态</td><td style="text-align:center">通过给定的数据库URL尝试与数据库建立连接</td></tr><tr><td style="text-align:center"><strong>2</strong></td><td style="text-align:center"><strong>public static Connection getConnecion(String url,String user,String password)throws SQLException</strong></td><td style="text-align:center"><strong>静态</strong></td><td style="text-align:center"><strong>通过给定的数据库URL尝试与数据库建立连接</strong></td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">public static int getLoginTimeout()</td><td style="text-align:center">静态</td><td style="text-align:center">获取驱动程序在尝试登录到某一数据库时可以等待的最长时间，以秒为单位</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">public static PrintWriter getLogWriter()</td><td style="text-align:center">静态</td><td style="text-align:center">检索日志编写器</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">public static void println(String message)</td><td style="text-align:center">静态</td><td style="text-align:center">将一条信息打印到当前JDBC日志流中</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">public static void registerDriver(Driver driber)</td><td style="text-align:center">静态</td><td style="text-align:center">使用给定的驱动程序</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">public static void setLoginTimeout(int seconds)</td><td style="text-align:center">静态</td><td style="text-align:center">设置驱动程序连接到某一数据库时将等待的最长时间，以秒为单位</td></tr></tbody></table><h4 id="connection接口"><a class="markdownIt-Anchor" href="#connection接口"></a> Connection接口</h4><p>​**Connection接口用于建立与特定的数据库连接，连接过程包括了所有执行SQL语句和在连接上所返回的结果。**一个连接就是一个会话，一个java程序可以存在一个连接或多个连接，还可以与多个数据库连接。Connection接口中常用方法如下表所示。</p><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">方法</th><th style="text-align:center">类型</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><strong>1</strong></td><td style="text-align:center"><strong>public void close() throws SQLException</strong></td><td style="text-align:center"><strong>普通</strong></td><td style="text-align:center"><strong>关闭数据库连接，并立即释放与此连接有关的数据库和JDBC资源，而不是等待它们被自动释放</strong></td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">public void commit() throws SQLException</td><td style="text-align:center">普通</td><td style="text-align:center">提交与事务有关的操作，并释放此Connection对象当前持有的所有数据库锁</td></tr><tr><td style="text-align:center"><strong>3</strong></td><td style="text-align:center"><strong>public Statement createStatement() throws SQLException</strong></td><td style="text-align:center"><strong>普通</strong></td><td style="text-align:center"><strong>创建一个Statement对象将SQL语句发送到数据</strong></td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">public Statement createStatement(int resultSetTyp,int resultSetConcurrency)</td><td style="text-align:center">普通</td><td style="text-align:center">创建一个Statement对象，该对象将生成具有给定类型和并发性的ResultSet对象</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">public Statement createStatement(int resultSetType,int resultSetConcurrency,int resultSetHoldability) throws SQLException</td><td style="text-align:center">普通</td><td style="text-align:center">创建一个Statement对象，该对象将生成具有给定类型、并发性和保存性的ResultSet对象</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">public boolean getAutoCommit() throws SQLException</td><td style="text-align:center">普通</td><td style="text-align:center">判断此Connection对象释放为自动提交模式，该操作与事务无关</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">public DatabaseMateData getMetaData()throws SQLException</td><td style="text-align:center">普通</td><td style="text-align:center">获取数据库的元数据</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">public boolean isClosed()throws SQLException</td><td style="text-align:center">普通</td><td style="text-align:center">判断此Connection对象释放已经被关闭。若已被关闭，则返回true，否则返回false</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">public boolean isReadOnly()throws SQLException</td><td style="text-align:center">普通</td><td style="text-align:center">判断此Connection对象是否处于只读模式。若为只读的，则返回true，否则返回false</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">public boolean isValid(int timeout)throws SQLException</td><td style="text-align:center">普通</td><td style="text-align:center">判断此连接尚未关闭并且仍然有效。若连接有效，则返回true，否则返回false</td></tr><tr><td style="text-align:center">*11</td><td style="text-align:center">public String nativeSQL(String sql)throws SQLException</td><td style="text-align:center">普通</td><td style="text-align:center">将给定的SQL语句转换成系统本机SQL语法</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">public CallableStatement prepareCall(String sql)throws SQLException</td><td style="text-align:center">普通</td><td style="text-align:center">创建一个CallableStatement对象来调用数据库存储过程</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">public CallableStatement prepareCall(String sql,int resultSetType,int resultSetConcurrency)throws SQLException</td><td style="text-align:center">普通</td><td style="text-align:center">创建一个 CallableStatement 对象，该对象将生成具有给定类型和并发性的 ResultSet 对 象</td></tr><tr><td style="text-align:center">14</td><td style="text-align:center">public CallableStatement prepareCall(String sql,int resultSetType,int resultSetConcurrency,int resultSetHoldability)throws SQLException</td><td style="text-align:center">普通</td><td style="text-align:center">创建一个 CallableStatement 对象，该对象将生成具有给定类型和并发性的 ResultSet 对象</td></tr><tr><td style="text-align:center">15</td><td style="text-align:center">public void rollback()throws SQLException</td><td style="text-align:center">普通</td><td style="text-align:center">取消在当前食物中进行的所有更改，实现回滚功能，并释放此Connection对象当前持有的所有数据库锁。此操作与事务无关</td></tr><tr><td style="text-align:center">16</td><td style="text-align:center">public void rollback(Savepoint savepoint)throws SQLException</td><td style="text-align:center">普通</td><td style="text-align:center">数据库回滚到指定的保存点</td></tr><tr><td style="text-align:center">17</td><td style="text-align:center">public void setAutoCommit(boolean autoCommit)throws SQLException</td><td style="text-align:center">普通</td><td style="text-align:center">将此连接的自动提交模式设置为指定状态</td></tr><tr><td style="text-align:center">18</td><td style="text-align:center">public void setReadOnly(boolean readOnly)throws SQLException</td><td style="text-align:center">普通</td><td style="text-align:center">将此连接设置为只读模式，作为驱动程序启用数据库优化的提示</td></tr><tr><td style="text-align:center">19</td><td style="text-align:center">public Savepoint setSavepoint()throws SQLException</td><td style="text-align:center">普通</td><td style="text-align:center">设置数据库事务的保存点</td></tr></tbody></table><h4 id="statement接口"><a class="markdownIt-Anchor" href="#statement接口"></a> Statement接口</h4><p>​<strong>Statement 接口用于在建立连接的基础上向数据库发送静态的 SQL 语句，并返回执行结果。</strong> Statement 接口的对象可以执行 DDL、DCL 语句，还可以执行 DML 语句，主要用于 SQL 查询。例如，对于 INSERT、UPDATE和DELETE 语句，可以调用 executeUpdate() 方法；而执行 SELECT 语句时调用 executeQuery() 方法，并返回一个不能为null的 ResultSet 实例。Statement接口常用的方法如下表所示。</p><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">方法</th><th style="text-align:center">类型</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">public void addBatch(String sql)throws SQLException</td><td style="text-align:center">普通</td><td style="text-align:center">将给定的SQL命令添加到此Statement对象的命令列表中</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">public void cancel()throws SQLException</td><td style="text-align:center">普通</td><td style="text-align:center">如果BMS和驱动程序都支持终止SQL语句，则取消此Statement对象</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">public void clearBatch()throws SQLException</td><td style="text-align:center">普通</td><td style="text-align:center">清空此Statement对象的当前SQL命令列表</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">public void clearWarnings()throws SQLException</td><td style="text-align:center">普通</td><td style="text-align:center">清除此Statement对象上报告的所有警告</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">public void close()throws SQLException</td><td style="text-align:center">普通</td><td style="text-align:center">立即释放此Statement对象的数据库和JDBC资源</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">public boolean execute(String sql)throws SQLException</td><td style="text-align:center">普通</td><td style="text-align:center">执行给定的SQl语句，该语句可能返回多个结果</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">public int[] executeBatch()throws SQLException</td><td style="text-align:center">普通</td><td style="text-align:center">将一批命令提交到数据库以供执行，如果所有命令成功执行，则返回一组更新计数。</td></tr><tr><td style="text-align:center"><strong>8</strong></td><td style="text-align:center"><strong>public ResultSet executeQuery(String sql)throws SQLException</strong></td><td style="text-align:center"><strong>普通</strong></td><td style="text-align:center"><strong>执行给定的SQL查询语句，该语句返回单个ResultSet对象</strong></td></tr><tr><td style="text-align:center"><strong>9</strong></td><td style="text-align:center"><strong>public int executeUpdate(String sql)throws SQLException</strong></td><td style="text-align:center"><strong>普通</strong></td><td style="text-align:center"><strong>执行给定的INSERT、UPDATE和DELETE的SQL语句，返回更新记录数</strong></td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">public Connection getConnection()throws SQLException</td><td style="text-align:center">普通</td><td style="text-align:center">返回生成此Statement对象的Connection对象</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">public int getMaxRows()throws SQLException</td><td style="text-align:center">普通</td><td style="text-align:center">获取由此Statement对象生成的ResultSet对象可以包含的最大行数</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">public int getQueryTimeout()throws SQLException</td><td style="text-align:center">普通</td><td style="text-align:center">获取驱动程序等待Statement对象执行的秒数</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">public ResultSet getResultSet()throws SQLException</td><td style="text-align:center">普通</td><td style="text-align:center">以ResultSet对象的形式获取当前结果</td></tr><tr><td style="text-align:center">14</td><td style="text-align:center">public boolean isClosed()throws SQLException</td><td style="text-align:center">普通</td><td style="text-align:center">判断是否已关闭了此Statement对象，若已关闭，则返回true，否则返回false</td></tr><tr><td style="text-align:center">15</td><td style="text-align:center">public void setQueryTimeout(int seconds)throws SQLException</td><td style="text-align:center">普通</td><td style="text-align:center">设置等待Statement对象实现的秒数</td></tr></tbody></table><h4 id="resultset接口"><a class="markdownIt-Anchor" href="#resultset接口"></a> ResultSet接口</h4><p>​<strong>ResultSet 接口用于接收SQL语句执行的结果集，类似一张临时的数据表，用来暂时存放数据库查询操作后所获得的结果集，可以通过next()方法将指针下移</strong>。ResultSet接口的常用方法如下表所示。</p><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">方法</th><th style="text-align:center">类型</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">public boolean absolute(int row)throws SQLException</td><td style="text-align:center">普通</td><td style="text-align:center">将指针移动带此ResultSet对象指定编号的行</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">public void afterLast()throws SQLException</td><td style="text-align:center">普通</td><td style="text-align:center">将指针移动到此ResultSet对象的末尾，即最后一行的位置</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">public void beforeFirest()throws SQLException</td><td style="text-align:center">普通</td><td style="text-align:center">将指针移动到此ResultSet对象的开头，即第一行的位置</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">public void cancelRowUpdates()throws SQLException</td><td style="text-align:center">普通</td><td style="text-align:center">取消对ResultSet对象中的当前行所作的更新</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">public clearWarnings()throws SQLException</td><td style="text-align:center">普通</td><td style="text-align:center">取消此ResultSet对象上报告的所有警告</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">public void close()throws SQLException</td><td style="text-align:center">普通</td><td style="text-align:center">立即释放ResultSet对象的数据库和JDBC资源</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">public void deleteRwow()throws SQLException</td><td style="text-align:center">普通</td><td style="text-align:center">从此ResultSet都系和数据库中删除当前行</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">public boolean first()throws SQLException</td><td style="text-align:center">普通</td><td style="text-align:center">将指针移动到此ResultSet对象的第一行</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">public boolean getBoolean(int col)throws SQLException</td><td style="text-align:center">普通</td><td style="text-align:center">以boolean的形式获取此ResultSet对象的当前列的值。若为NULL，则返回false</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">public byte getByte(int col)throws SQLException</td><td style="text-align:center">普通</td><td style="text-align:center">以byte的形式获取此ResultSet对象的当前行中指定列的值。若为NULL，则返回0，可重写为double,float,int,long,short类型</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">public Date getDate(int col)throws SQLException</td><td style="text-align:center">普通</td><td style="text-align:center">以java.sql.Date对象的形式获取此ResultSet对象的当前行指定列的值。若为NULL，则返回null</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">public ResultSetMetaDate getMetaDate()throws SQLException</td><td style="text-align:center">普通</td><td style="text-align:center">获取ResultSet对象的列的编号、类型和属性</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">public Object getObject(int col)throws SQLException</td><td style="text-align:center">普通</td><td style="text-align:center">以Object的形式获取此ResultSet对象的当前行中指定列的值。若为NULL，则返回值为null</td></tr><tr><td style="text-align:center">14</td><td style="text-align:center">public int getRow()throws SQLException</td><td style="text-align:center">普通</td><td style="text-align:center">获取当前行编号</td></tr><tr><td style="text-align:center">15</td><td style="text-align:center">public Statement getStatement()throws SQLException</td><td style="text-align:center">普通</td><td style="text-align:center">返回生成此ResultSet对象的Statement对象</td></tr><tr><td style="text-align:center">16</td><td style="text-align:center">public String getString(int col)throws SQLException</td><td style="text-align:center">普通</td><td style="text-align:center">以String的形式获取此ResultSet对象的当前行中指定列的值。若为NULL，则返回null</td></tr><tr><td style="text-align:center">17</td><td style="text-align:center">public Time getTime(int col)throws SQLException</td><td style="text-align:center">普通</td><td style="text-align:center">以java.sql.Time对象的形式获取此ResultSet对象的当前行指定列的值。若为NULL，则返回null</td></tr><tr><td style="text-align:center">18</td><td style="text-align:center">public int getType()throws SQLException</td><td style="text-align:center">普通</td><td style="text-align:center">获取此ResultSet对象的类型</td></tr><tr><td style="text-align:center">19</td><td style="text-align:center">public void insertRow()throws SQLException</td><td style="text-align:center">普通</td><td style="text-align:center">将插入行的内容插入到此ResultSet对象和数据库中</td></tr><tr><td style="text-align:center">20</td><td style="text-align:center">public boolean isAfterLast()throws SQLException</td><td style="text-align:center">普通</td><td style="text-align:center">判断指针是否位于此ResultSet对象的最后一行之后</td></tr><tr><td style="text-align:center">21</td><td style="text-align:center">public boolean beforeFirst()throws SQLException</td><td style="text-align:center">普通</td><td style="text-align:center">判断指针是否位于此ResultSet对象的第一行之前</td></tr><tr><td style="text-align:center">22</td><td style="text-align:center">public boolean isClosed()throws SQLException</td><td style="text-align:center">普通</td><td style="text-align:center">判断此ResultSet对象是否已关闭</td></tr><tr><td style="text-align:center">23</td><td style="text-align:center">public boolean isFirst()throws SQLException</td><td style="text-align:center">普通</td><td style="text-align:center">判断此指针是否位于此ResultSet对象的第一行</td></tr><tr><td style="text-align:center">24</td><td style="text-align:center">public boolean isLast()throws SQLException</td><td style="text-align:center">普通</td><td style="text-align:center">判断此指针是否位于此ResultSet对象的最后一行</td></tr><tr><td style="text-align:center">25</td><td style="text-align:center">public boolean last()throws SQLException</td><td style="text-align:center">普通</td><td style="text-align:center">将指针移动到此ResultSet对象的最后一行</td></tr><tr><td style="text-align:center"><strong>26</strong></td><td style="text-align:center"><strong>public boolean next()throws SQLException</strong></td><td style="text-align:center"><strong>普通</strong></td><td style="text-align:center"><strong>将指针向下移动一行</strong></td></tr><tr><td style="text-align:center">27</td><td style="text-align:center">public boolean previous()throws SQLException</td><td style="text-align:center">普通</td><td style="text-align:center">将指针向上移动一行</td></tr><tr><td style="text-align:center">28</td><td style="text-align:center">public boolean rowDelete()throws SQLException</td><td style="text-align:center">普通</td><td style="text-align:center">判断是否已删除某行</td></tr><tr><td style="text-align:center">29</td><td style="text-align:center">public booelan rowIntsert()throws SQLException</td><td style="text-align:center">普通</td><td style="text-align:center">判断当前行是否已有插入</td></tr><tr><td style="text-align:center">30</td><td style="text-align:center">public boolean rowUpdate()throws SQLException</td><td style="text-align:center">普通</td><td style="text-align:center">判断是否已更新当前行</td></tr><tr><td style="text-align:center">31</td><td style="text-align:center">public void setFetchSize(int rows)throws SQLException</td><td style="text-align:center">普通</td><td style="text-align:center">为JDBC驱动程序设置此ResultSet对象需要更多行时应该从数据库获取行数</td></tr><tr><td style="text-align:center">32</td><td style="text-align:center">public void updateBoolean(int col,boolean x)throws SQLException</td><td style="text-align:center">普通</td><td style="text-align:center">用指定的boolean值更新指定列，可重写为byte,Date,double,float,int,long，Object,short,String.Time</td></tr><tr><td style="text-align:center">33</td><td style="text-align:center">public void updateLong(String columnLabel,long x)throws SQLException</td><td style="text-align:center">普通</td><td style="text-align:center">用指定的long更新指定列</td></tr><tr><td style="text-align:center">34</td><td style="text-align:center">public void updateNull(int col)throws SQLException</td><td style="text-align:center">普通</td><td style="text-align:center">用null值更新指定列</td></tr><tr><td style="text-align:center">35</td><td style="text-align:center">public void updateRow()throws SQLException</td><td style="text-align:center">普通</td><td style="text-align:center">将当前行的内容更新到数据表中</td></tr><tr><td style="text-align:center">36</td><td style="text-align:center">public boolean wasNull()throws SQLException</td><td style="text-align:center">普通</td><td style="text-align:center">报告最后一个读取的列是否为NULL</td></tr></tbody></table><p>​JDBC API中除了上面的类和接口之外，还含有多个其他的类和接口。开发人员可以直接使用这些类库来开发数据库应用程序，其他类和接口如下。</p><ul><li>CallableStatement 接口：用于执行 SQL 存储过程的接口。</li><li>DatabaseMetaData 接口：此接口由驱动程序供应商实现，让用户了解 DBMS 在与驱动程序相结合时的能力，与 ResultSetMetaData 一同用于访问数据库的元信息。</li><li>Driver 接口：是数据库驱动程序的接口，每个驱动程序都应该提供一个实现 Driver 接口的类。</li><li>PreparedStatement 接口：表示预编译的 SQL 语句的对象。SQL 语句被预编译并存储在 PreparedStatement 对象中，然后可以使用此对象多次高效地执行该语句。</li><li>Date 类：该类是 java.util.Date 的子类，为了与 SQL DATE 的定义一致，但日期不包括时间。</li><li>Time 类：该类是 java.util.Date 的子类，用于表示时、分、秒。</li><li>Timestamp 类：该类是 java.util.Date 的子类，扩展了 java.util.Date 类，用于表示 SQL 时间戳，还可以表示纳秒的时间域</li><li>Types 类：定义用于标识一般 SQL 类型的常量的类。</li><li>SQLException 类：该类是异常类，提供关于数据库访问错误或其他错误信息的异常。</li><li>SQLWarning 类：该类是异常类，提供关于数据库访问警告信息的异常，这些警告直接链接到导致报告警告的方法所在的对象。</li></ul><p>参考链接：<a href="https://my.oschina.net/u/3038200/blog/3189221">详解JDBC的四种驱动类型 - ericxu1116的个人空间 - OSCHINA - 中文开源技术交流社区</a></p><p>参考书目：</p><p><a href="http://product.dangdang.com/23248198.html?ref=book-35530-3032_5-231497-4">《Java编程手记——从实践中学习Java（配光盘）》(欧二强　等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​	无论是哪一个程序设计语言，想要操作数据库，第一件事就是连接数据库。java语言提供了多种方式连接数据库，都是通过JDBC来进行连接的。本文将介绍JDBC的基本知识。&lt;/p&gt;
&lt;h3 id=&quot;认识jdbc&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; hre</summary>
      
    
    
    
    <category term="java" scheme="https://silenthly.github.io/categories/java/"/>
    
    
    <category term="笔记" scheme="https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>图文详解Java对象内存布局</title>
    <link href="https://silenthly.github.io/2021/09/07/%E6%B7%B1%E5%85%A5java/%E5%9B%BE%E6%96%87%E8%AF%A6%E8%A7%A3Java%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/"/>
    <id>https://silenthly.github.io/2021/09/07/%E6%B7%B1%E5%85%A5java/%E5%9B%BE%E6%96%87%E8%AF%A6%E8%A7%A3Java%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/</id>
    <published>2021-09-07T08:15:43.000Z</published>
    <updated>2021-09-25T11:12:59.444Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>转自：<a href="https://mp.weixin.qq.com/s/9O-8Rs-LAUrdXSLOpUFTyQ">图文详解Java对象内存布局 (qq.com)</a></p><p>作者：Dr Hydra</p></blockquote><p>作为一名Java程序员，我们在日常工作中使用这款面向对象的编程语言时，做的最频繁的操作大概就是去创建一个个的对象了。对象的创建方式虽然有很多，可以通过<code>new</code>、反射、<code>clone</code>、反序列化等不同方式来创建，但最终使用时对象都要被放到内存中，那么你知道在内存中的java对象是由哪些部分组成、又是怎么存储的吗？</p><p>本文将基于代码进行实例测试，详细探讨对象在内存中的组成结构。全文目录结构如下：</p><ul><li>1、对象内存结构概述</li><li>2、JOL 工具简介</li><li>3、对象头</li><li>4、实例数据</li><li>5、对齐填充字节</li><li>6、总结</li></ul><blockquote><p>文中代码基于 JDK 1.8.0_261，64-Bit HotSpot 运行</p></blockquote><h3 id="1-对象内存结构概述"><a class="markdownIt-Anchor" href="#1-对象内存结构概述"></a> <strong>1、对象内存结构概述</strong></h3><p>在介绍对象在内存中的组成结构前，我们先简要回顾一个对象的创建过程：</p><p><strong>1、jvm将对象所在的<code>class</code>文件加载到方法区中</strong></p><p><strong>2、jvm读取<code>main</code>方法入口，将<code>main</code>方法入栈，执行创建对象代码</strong></p><p><strong>3、在<code>main</code>方法的栈内存中分配对象的引用，在堆中分配内存放入创建的对象，并将栈中的引用指向堆中的对象</strong></p><p>所以当对象在实例化完成之后，是被存放在堆内存中的，这里的对象由3部分组成，如下图所示：</p><p><img src="https://silenthty.gitee.io/photo/java%E6%B7%B1%E5%85%A5/%E5%AF%B9%E8%B1%A1v1.jpg" alt="" /></p><p>对各个组成部分的功能简要进行说明：</p><ul><li>对象头：对象头存储的是对象在运行时状态的相关信息、指向该对象所属类的元数据的指针，如果对象是数组对象那么还会额外存储对象的数组长度</li><li>实例数据：实例数据存储的是对象的真正有效数据，也就是各个属性字段的值，如果在拥有父类的情况下，还会包含父类的字段。字段的存储顺序会受到数据类型长度、以及虚拟机的分配策略的影响</li><li>对齐填充字节：在java对象中，需要对齐填充字节的原因是，64位的jvm中对象的大小被要求向8字节对齐，因此当对象的长度不足8字节的整数倍时，需要在对象中进行填充操作。注意图中对齐填充部分使用了虚线，这是因为填充字节并不是固定存在的部分，这点在后面计算对象大小时具体进行说明</li></ul><h3 id="2-jol-工具简介"><a class="markdownIt-Anchor" href="#2-jol-工具简介"></a> <strong>2、JOL 工具简介</strong></h3><p>在具体开始研究对象的内存结构之前，先介绍一下我们要用到的工具，<code>openjdk</code>官网提供了查看对象内存布局的工具<code>jol (java object layout)</code>，可在<code>maven</code>中引入坐标：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.openjdk.jol&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;jol-core&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;<span class="number">0.14</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>在代码中使用jol提供的方法查看jvm信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(VM.current().details());</span><br></pre></td></tr></table></figure><p><img src="https://silenthty.gitee.io/photo/java%E6%B7%B1%E5%85%A5/%E5%AF%B9%E8%B1%A1v2.jpg" alt="" /></p><p>通过打印出来的信息，可以看到我们使用的是64位 jvm，并开启了指针压缩，对象默认使用8字节对齐方式。通过<code>jol</code>查看对象内存布局的方法，将在后面的例子中具体展示，下面开始对象内存布局的正式学习。</p><h3 id="3-对象头"><a class="markdownIt-Anchor" href="#3-对象头"></a> <strong>3、对象头</strong></h3><p>首先看一下对象头（<code>Object header</code>）的组成部分，根据普通对象和数组对象的不同，结构将会有所不同。只有当对象是数组对象才会有数组长度部分，普通对象没有该部分，如下图所示：</p><p><img src="https://silenthty.gitee.io/photo/java%E6%B7%B1%E5%85%A5/%E5%AF%B9%E8%B1%A1v3.jpg" alt="" /></p><p>**在对象头中<code>mark word</code> 占8字节，默认开启指针压缩的情况下<code>klass pointer</code> 占4字节，数组对象的数组长度占4字节。**在了解了对象头的基础结构后，现在以一个不包含任何属性的空对象为例，查看一下它的内存布局，创建<code>User</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>jol</code>查看对象头的内存布局：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  User user=<span class="keyword">new</span> User();</span><br><span class="line">  <span class="comment">//查看对象的内存布局</span></span><br><span class="line">  System.out.println(ClassLayout.parseInstance(user).toPrintable());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行代码，查看打印信息：</p><p><img src="https://silenthty.gitee.io/photo/java%E6%B7%B1%E5%85%A5/%E5%AF%B9%E8%B1%A1v4.jpg" alt="" /></p><ul><li><code>OFFSET</code>：偏移地址，单位为字节</li><li><code>SIZE</code>：占用内存大小，单位为字节</li><li><code>TYPE</code>：<code>Class</code>中定义的类型</li><li><code>DESCRIPTION</code>：类型描述，<code>Obejct header</code> 表示对象头，<code>alignment</code>表示对齐填充</li><li><code>VALUE</code>：对应内存中存储的值</li></ul><p>当前对象共占用16字节，因为8字节标记字加4字节的类型指针，不满足向8字节对齐，因此需要填充4个字节：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8B (mark word) + 4B (klass pointer) + 0B (instance data) + 4B (padding)</span><br></pre></td></tr></table></figure><p>这样我们就通过直观的方式，了解了一个不包含属性的最简单的空对象，在内存中的基本组成是怎样的。在此基础上，我们来深入学习对象头中各个组成部分。</p><h4 id="31-mark-word-标记字"><a class="markdownIt-Anchor" href="#31-mark-word-标记字"></a> <strong>3.1 Mark Word 标记字</strong></h4><p>在对象头中，<code>mark word</code> 一共有64个bit，用于存储对象自身的运行时数据，标记对象处于以下5种状态中的某一种：</p><p><img src="https://silenthty.gitee.io/photo/java%E6%B7%B1%E5%85%A5/%E5%AF%B9%E8%B1%A1v5.jpg" alt="" /></p><h4 id="311-基于mark-word的锁升级"><a class="markdownIt-Anchor" href="#311-基于mark-word的锁升级"></a> <strong>3.1.1 基于mark word的锁升级</strong></h4><p>在jdk6 之前，通过<code>synchronized</code>关键字加锁时使用无差别的的重量级锁，重量级锁会造成线程的串行执行，并且使cpu在用户态和核心态之间频繁切换。随着对<code>synchronized</code>的不断优化，提出了锁升级的概念，并引入了偏向锁、轻量级锁、重量级锁。在<code>mark word</code>中，锁（<code>lock</code>）标志位占用2个bit，结合1个bit偏向锁（<code>biased_lock</code>）标志位，<strong>这样通过倒数的3位，就能用来标识当前对象持有的锁的状态，并判断出其余位存储的是什么信息。</strong></p><p>基于<code>mark word</code>的锁升级的流程如下：</p><p>1、**锁对象刚创建时，没有任何线程竞争，对象处于无锁状态。**在上面打印的空对象的内存布局中，根据大小端，得到最后8位是<code>00000001</code>，表示处于无锁态，并且处于不可偏向状态。这是因为在jdk中偏向锁存在延迟4秒启动，也就是说在jvm启动后4秒后创建的对象才会开启偏向锁，我们通过jvm参数取消这个延迟时间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:BiasedLockingStartupDelay=<span class="number">0</span></span><br></pre></td></tr></table></figure><p><img src="https://silenthty.gitee.io/photo/java%E6%B7%B1%E5%85%A5/%E5%AF%B9%E8%B1%A1v6.jpg" alt="" /></p><p>这时最后3位为<code>101</code>，表示当前对象的锁没有被持有，并且处于可被偏向状态。</p><p>2、在没有线程竞争的条件下，第一个获取锁的线程通过<code>CAS</code>将自己的<code>threadId</code>写入到该对象的<code>mark word</code>中，若后续该线程再次获取锁，需要比较当前线程<code>threadId</code>和对象<code>mark word</code>中的<code>threadId</code>是否一致，如果一致那么可以直接获取，并且锁对象始终保持对该线程的偏向，也就是说偏向锁不会主动释放。</p><p>使用代码进行测试同一个线程重复获取锁的过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  User user=<span class="keyword">new</span> User();</span><br><span class="line">  <span class="keyword">synchronized</span> (user)&#123;</span><br><span class="line">    System.out.println(ClassLayout.parseInstance(user).toPrintable());</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(ClassLayout.parseInstance(user).toPrintable());</span><br><span class="line">  <span class="keyword">synchronized</span> (user)&#123;</span><br><span class="line">    System.out.println(ClassLayout.parseInstance(user).toPrintable());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="https://silenthty.gitee.io/photo/java%E6%B7%B1%E5%85%A5/%E5%AF%B9%E8%B1%A1v7.jpg" alt="" /></p><p><strong>可以看到一个线程对一个对象加锁、解锁、重新获取对象的锁时，<code>mark word</code>都没有发生变化，偏向锁中的当前线程指针始终指向同一个线程。</strong></p><p>3、**当两个或以上线程交替获取锁，但并没有在对象上并发的获取锁时，偏向锁升级为轻量级锁。**在此阶段，线程采取CAS的自旋方式尝试获取锁，**避免阻塞线程造成的cpu在用户态和内核态间转换的消耗。**测试代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  User user=<span class="keyword">new</span> User();</span><br><span class="line">  <span class="keyword">synchronized</span> (user)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;--MAIN--:&quot;</span>+ClassLayout.parseInstance(user).toPrintable());</span><br><span class="line">  &#125;</span><br><span class="line">  Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (user) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;--THREAD--:&quot;</span>+ClassLayout.parseInstance(user).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  thread.start();</span><br><span class="line">  thread.join();</span><br><span class="line">  System.out.println(<span class="string">&quot;--END--:&quot;</span>+ClassLayout.parseInstance(user).toPrintable());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先直接看一下结果：</p><p><img src="https://silenthty.gitee.io/photo/java%E6%B7%B1%E5%85%A5/%E5%AF%B9%E8%B1%A1v8.jpg" alt="" /></p><p>整个加锁状态的变化流程如下：</p><ul><li>主线程首先对user对象加锁，首次加锁为<code>101</code>偏向锁</li><li>子线程等待主线程释放锁后，对user对象加锁，这时将偏向锁升级为<code>00</code>轻量级锁</li><li>轻量级锁解锁后，user对象无线程竞争，恢复为<code>001</code>无锁态，并且处于不可偏向状态。如果之后有线程再尝试获取user对象的锁，会直接加轻量级锁，而不是偏向锁。</li></ul><p>4、**当两个或以上线程并发的在同一个对象上进行同步时，为了避免无用自旋消耗cpu，轻量级锁会升级成重量级锁。**这时<code>mark word</code>中的指针指向的是<code>monitor</code>对象（也被称为管程或监视器锁）的起始地址。测试代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  User user = <span class="keyword">new</span> User();</span><br><span class="line">  <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (user) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;--THREAD1--:&quot;</span> + ClassLayout.parseInstance(user).toPrintable());</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;).start();</span><br><span class="line">  <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (user) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;--THREAD2--:&quot;</span> + ClassLayout.parseInstance(user).toPrintable());</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看结果：</p><p><img src="https://silenthty.gitee.io/photo/java%E6%B7%B1%E5%85%A5/%E5%AF%B9%E8%B1%A1v9.jpg" alt="" /></p><p>可以看到，在两个线程同时竞争user对象的锁时，会升级为<code>10</code>重量级锁。</p><h4 id="312-其他信息"><a class="markdownIt-Anchor" href="#312-其他信息"></a> <strong>3.1.2 其他信息</strong></h4><p>对<code>mark word</code> 中其他重要信息进行说明：</p><p><code>hashcode</code>：无锁态下的<code>hashcode</code>采用了延迟加载技术，**在第一次调用<code>hashCode()</code>方法时才会计算写入。**对这一过程进行验证：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  User user=<span class="keyword">new</span> User();</span><br><span class="line">  <span class="comment">//打印内存布局</span></span><br><span class="line">  System.out.println(ClassLayout.parseInstance(user).toPrintable());</span><br><span class="line">  <span class="comment">//计算hashCode</span></span><br><span class="line">  System.out.println(user.hashCode());</span><br><span class="line">  <span class="comment">//再次打印内存布局</span></span><br><span class="line">  System.out.println(ClassLayout.parseInstance(user).toPrintable());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://silenthty.gitee.io/photo/java%E6%B7%B1%E5%85%A5/%E5%AF%B9%E8%B1%A1v10.jpg" alt="" /></p><p>可以看到，在没有调用<code>hashCode()</code>方法前，31位的哈希值不存在，全部填充为0。在调用方法后，根据大小端，被填充的数据为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1011001001101100011010010101101</span></span><br></pre></td></tr></table></figure><p>将2进制转换为10进制，对应哈希值<code>1496724653</code>。需要注意，只有在调用<strong>没有被重写</strong>的<code>Object.hashCode()</code>方法或<code>System.identityHashCode(Object)</code>方法才会写入<code>mark word</code>，执行用户自定义的<code>hashCode()</code>方法不会被写入。</p><p>大家可能会注意到，当对象被加锁后，<code>mark word</code>中就没有足够空间来保存<code>hashCode</code>了，这时<code>hashcode</code>会被移动到重量级锁的<code>Object Monitor</code>中。</p><ul><li><code>epoch</code>：偏向锁的时间戳</li><li>分代年龄（<code>age</code>）：在<code>jvm</code>的垃圾回收过程中，每当对象经过一次<code>Young GC</code>，年龄都会加1，这里4位来表示分代年龄最大值为15，这也就是为什么对象的年龄超过15后会被移到老年代的原因。在启动时可以通过添加参数来改变年龄阈值：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:MaxTenuringThreshold</span><br></pre></td></tr></table></figure><p>当设置的阈值超过15时，启动时会报错：</p><p><img src="https://silenthty.gitee.io/photo/java%E6%B7%B1%E5%85%A5/%E5%AF%B9%E8%B1%A1v11.jpg" alt="" /></p><p><strong>3.2 Klass Pointer 类型指针</strong></p><p><code>Klass Pointer</code>是一个指向方法区中<code>Class</code>信息的指针，<strong>虚拟机通过这个指针确定该对象属于哪个类的实例</strong>。在64位的JVM中，支持指针压缩功能，根据是否开启指针压缩，<code>Klass Pointer</code>占用的大小将会不同：</p><ul><li>未开启指针压缩时，类型指针占用8B (64bit)</li><li>开启指针压缩情况下，类型指针占用4B (32bit)</li></ul><p>在<code>jdk6</code>之后的版本中，指针压缩是被默认开启的，可通过启动参数开启或关闭该功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#开启指针压缩：</span><br><span class="line">-XX:+UseCompressedOops</span><br><span class="line">#关闭指针压缩：</span><br><span class="line">-XX:-UseCompressedOops</span><br></pre></td></tr></table></figure><p>还是以刚才的<code>User</code>类为例，关闭指针压缩后再次查看对象的内存布局：</p><p><img src="https://silenthty.gitee.io/photo/java%E6%B7%B1%E5%85%A5/%E5%AF%B9%E8%B1%A1v12.jpg" alt="" /></p><p>对象大小虽然还是16字节，但是组成发生了改变，8字节标记字加8字节类型指针，已经能满足对齐条件，因此不需要填充。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8B (mark word) + 8B (klass pointer) + 0B (instance data) + 0B (padding)</span><br></pre></td></tr></table></figure><p><strong>3.2.1 指针压缩原理</strong></p><p>在了解了指针压缩的作用后，我们来看一下指针压缩是如何实现的。首先在不开启指针压缩的情况下，一个对象的内存地址使用64位表示，这时能描述的内存地址范围是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> ~ <span class="number">2</span>^<span class="number">64</span>-<span class="number">1</span></span><br></pre></td></tr></table></figure><p>在开启指针压缩后，使用4个字节也就是32位，可以表示<code>2^32</code> 个内存地址，如果这个地址是真实地址的话，由于CPU寻址的最小单位是<code>Byte</code>，那么就是4GB内存。这对于我们来说是远远不够的，但是之前我们说过，java中对象默认使用了8字节对齐，也就是说1个对象占用的空间必须是8字节的整数倍，这样就创造了一个条件，使jvm在定位一个对象时不需要使用真正的内存地址，而是定位到由java进行了8字节映射后的地址（可以说是一个映射地址的编号）。</p><p>映射过程也非常简单，由于使用了8字节对齐后每个对象的地址偏移量后3位必定为0，所以在存储的时候可以将后3位0抹除（转化为<code>bit</code>是抹除了最后24位），在此基础上再去掉最高位，就完成了指针从8字节到4字节的压缩。而在实际使用时，在压缩后的指针后加3位0，就能够实现向真实地址的映射。</p><p><img src="https://silenthty.gitee.io/photo/java%E6%B7%B1%E5%85%A5/%E5%AF%B9%E8%B1%A1v13.jpg" alt="" /></p><p>完成压缩后，现在指针的32位中的每一个<code>bit</code>，都可以代表8个字节，这样就相当于使原有的内存地址得到了8倍的扩容。所以在8字节对齐的情况下，32位最大能表示<code>2^32*8=32GB</code>内存，内存地址范围是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> ~ (<span class="number">2</span>^<span class="number">32</span>-<span class="number">1</span>)*<span class="number">8</span></span><br></pre></td></tr></table></figure><p>由于能够表示的最大内存是32GB，所以如果配置的最大的堆内存超过这个数值时，那么指针压缩将会失效。配置jvm启动参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xmx32g</span><br></pre></td></tr></table></figure><p>查看对象内存布局：</p><p><img src="https://silenthty.gitee.io/photo/java%E6%B7%B1%E5%85%A5/%E5%AF%B9%E8%B1%A1v14.jpg" alt="" /></p><p>此时，指针压缩失效，指针长度恢复到8字节。那么如果业务场景内存超过32GB怎么办呢，可以通过修改默认对齐长度进行再次扩展，我们将对齐长度修改为16字节：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:ObjectAlignmentInBytes=<span class="number">16</span> -Xmx32g</span><br></pre></td></tr></table></figure><p><img src="https://silenthty.gitee.io/photo/java%E6%B7%B1%E5%85%A5/%E5%AF%B9%E8%B1%A1v15.jpg" alt="" /></p><p>可以看到指针压缩后占4字节，同时对象向16字节进行了填充对齐，按照上面的计算，这时配置最大堆内存为64GB时指针压缩才会失效。</p><p>对指针压缩做一下简单总结：</p><ul><li>通过指针压缩，利用对齐填充的特性，通过映射方式达到了内存地址扩展的效果</li><li>指针压缩能够节省内存空间，同时提高了程序的寻址效率</li><li>堆内存设置时最好不要超过32GB，这时指针压缩将会失效，造成空间的浪费</li><li>此外，指针压缩不仅可以作用于对象头的类型指针，还可以作用于引用类型的字段指针，以及引用类型数组指针</li></ul><p><strong>3.3 数组长度</strong></p><p>如果当对象是一个数组对象时，那么在对象头中有一个保存数组长度的空间，占用4字节（32bit）空间。通过下面代码进行测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  User[] user=<span class="keyword">new</span> User[<span class="number">2</span>];</span><br><span class="line">  <span class="comment">//查看对象的内存布局</span></span><br><span class="line">  System.out.println(ClassLayout.parseInstance(user).toPrintable());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行代码，结果如下：</p><p><img src="https://silenthty.gitee.io/photo/java%E6%B7%B1%E5%85%A5/%E5%AF%B9%E8%B1%A1v16.jpg" alt="" /></p><p>内存结构从上到下分别为：</p><ul><li>8字节<code>mark word</code></li><li>4字节<code>klass pointer</code></li><li>4字节数组长度，值为2，表示数组中有两个元素</li><li>开启指针压缩后每个引用类型占4字节，数组中两个元素共占8字节</li></ul><p>需要注意的是，在未开启指针压缩的情况下，在数组长度后会有一段对齐填充字节：</p><p><img src="https://silenthty.gitee.io/photo/java%E6%B7%B1%E5%85%A5/%E5%AF%B9%E8%B1%A1v17.jpg" alt="" /></p><p>通过计算：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8B (mark word) + 8B (klass pointer) + 4B (array length) + 16B (instance data)=36B</span><br></pre></td></tr></table></figure><p>需要向8字节进行对齐，这里选择将对齐的4字节添加在了数组长度和实例数据之间。</p><h3 id="4-实例数据"><a class="markdownIt-Anchor" href="#4-实例数据"></a> <strong>4、实例数据</strong></h3><p>实例数据（<code>Instance Data</code>）保存的是对象真正存储的有效信息，保存了代码中定义的各种数据类型的字段内容，并且如果有继承关系存在，子类还会包含从父类继承过来的字段。</p><ul><li>基本数据类型：</li></ul><table><thead><tr><th><strong>Type</strong></th><th><strong>Bytes</strong></th></tr></thead><tbody><tr><td>byte，boolean</td><td>1</td></tr><tr><td>char，short</td><td>2</td></tr><tr><td>int，float</td><td>4</td></tr><tr><td>long，double</td><td>8</td></tr></tbody></table><ul><li>引用数据类型：</li></ul><p>开启指针压缩情况下占8字节，开启指针压缩后占4字节。</p><h4 id="41-字段重排序"><a class="markdownIt-Anchor" href="#41-字段重排序"></a> <strong>4.1 字段重排序</strong></h4><p>给User类添加基本数据类型的属性字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> id,age,weight;</span><br><span class="line">  <span class="keyword">byte</span> sex;</span><br><span class="line">  <span class="keyword">long</span> phone;</span><br><span class="line">  <span class="keyword">char</span> local;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看内存布局：</p><p><img src="https://silenthty.gitee.io/photo/java%E6%B7%B1%E5%85%A5/%E5%AF%B9%E8%B1%A1v18.jpg" alt="" /></p><p>可以看到，在内存中，属性的排列顺序与在类中定义的顺序不同，这是因为jvm会采用<strong>字段重排序</strong>技术，对原始类型进行重新排序，以达到内存对齐的目的。具体规则遵循如下：</p><ul><li>按照数据类型的长度大小，从大到小排列</li><li>具有相同长度的字段，会被分配在相邻位置</li><li>如果一个字段的长度是L个字节，那么这个字段的偏移量（<code>OFFSET</code>）需要对齐至<code>nL</code>（n为整数）</li></ul><p>上面的前两条规则相对容易理解，这里通过举例对第3条进行解释：</p><p>因为<code>long</code>类型占8字节，所以它的偏移量必定是8n，再加上前面对象头占12字节，所以<code>long</code>类型变量的最小偏移量是16。通过打印对象内存布局可以发现，当对象头不是8字节的整数倍时（只存在<code>8n+4</code>字节情况），会按从大到小的顺序，使用4、2、1字节长度的属性进行补位。为了和对齐填充进行区分，可以称其为前置补位，如果在补位后仍然不满足8字节整数倍，会进行对齐填充。在存在前置补位的情况下，字段的排序会打破上面的第一条规则。</p><p>因此在上面的内存布局中，先使用4字节的<code>int</code>进行前置补位，再按第一条规则从大到小顺序进行排列。如果我们删除3个int类型的字段，再查看内存布局：</p><p><img src="https://silenthty.gitee.io/photo/java%E6%B7%B1%E5%85%A5/%E5%AF%B9%E8%B1%A1v19.jpg" alt="" /></p><p><code>char</code>和<code>byte</code>类型的变量被提到前面进行前置补位，并在<code>long</code>类型前进行了1字节的对齐填充。</p><h4 id="42-拥有父类情况"><a class="markdownIt-Anchor" href="#42-拥有父类情况"></a> <strong>4.2 拥有父类情况</strong></h4><p>当一个类拥有父类时，整体遵循在父类中定义的变量出现在子类中定义的变量之前的原则</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i1,i2;</span><br><span class="line">  <span class="keyword">long</span> l1,l2;</span><br><span class="line">  <span class="keyword">char</span> c1,c2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> b1;</span><br><span class="line">  <span class="keyword">double</span> d1,d2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看内存结构：</p><p><img src="https://silenthty.gitee.io/photo/java%E6%B7%B1%E5%85%A5/%E5%AF%B9%E8%B1%A1v20.jpg" alt="" /></p><ul><li>如果父类需要后置补位的情况，可能会将子类中类型长度较短的变量提前，但是整体还是遵循子类在父类之后的原则</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i1,i2;</span><br><span class="line">  <span class="keyword">long</span> l1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i1,i2;</span><br><span class="line">  <span class="keyword">long</span> l1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看内存结构：</p><p><img src="https://silenthty.gitee.io/photo/java%E6%B7%B1%E5%85%A5/%E5%AF%B9%E8%B1%A1v21.jpg" alt="" /></p><p>可以看到，子类中较短长度的变量被提前到父类后进行了后置补位。</p><ul><li>父类的前置对齐填充会被子类继承</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">  <span class="keyword">long</span> l2;</span><br><span class="line">  <span class="keyword">int</span> i1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看内存结构：</p><p><img src="https://silenthty.gitee.io/photo/java%E6%B7%B1%E5%85%A5/%E5%AF%B9%E8%B1%A1v22.jpg" alt="" /></p><p>当B类没有继承A类时，正好满足8字节对齐，不需要进行对齐填充。当B类继承A类后，会继承A类的前置补位填充，因此在B类的末尾也需要对齐填充。</p><h4 id="43-引用数据类型"><a class="markdownIt-Anchor" href="#43-引用数据类型"></a> <strong>4.3 引用数据类型</strong></h4><p>在上面的例子中，仅探讨了基本数据类型的排序情况，那么如果存在引用数据类型时，排序情况是怎样的呢？在<code>User</code>类中添加引用类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> id;</span><br><span class="line">   String firstName;</span><br><span class="line">   String lastName;</span><br><span class="line">   <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看内存布局：</p><p><img src="https://silenthty.gitee.io/photo/java%E6%B7%B1%E5%85%A5/%E5%AF%B9%E8%B1%A1v23.jpg" alt="" /></p><p>可以看到默认情况下，基本数据类型的变量排在引用数据类型前。这个顺序可以在<code>jvm</code>启动参数中进行修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:FieldsAllocationStyle=<span class="number">0</span></span><br></pre></td></tr></table></figure><p>重新运行，可以看到引用数据类型的排列顺序被放在了前面：</p><p><img src="https://silenthty.gitee.io/photo/java%E6%B7%B1%E5%85%A5/%E5%AF%B9%E8%B1%A1v24.jpg" alt="" /></p><p>对<code>FieldsAllocationStyle</code>的不同取值简要说明：</p><ul><li>0：先放入普通对象的引用指针，再放入基本数据类型变量</li><li>1：默认情况，表示先放入基本数据类型变量，再放入普通对象的引用指针</li></ul><h4 id="44-静态变量"><a class="markdownIt-Anchor" href="#44-静态变量"></a> <strong>4.4 静态变量</strong></h4><p>在上面的基础上，在类中加入静态变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> id;</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">byte</span> local;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看内存布局：</p><p><img src="https://silenthty.gitee.io/photo/java%E6%B7%B1%E5%85%A5/%E5%AF%B9%E8%B1%A1v25.jpg" alt="" /></p><p>通过结果可以看到，静态变量并不在对象的内存布局中，它的大小是不计算在对象中的，因为静态变量属于类而不是属于某一个对象的。</p><h3 id="5-对齐填充字节"><a class="markdownIt-Anchor" href="#5-对齐填充字节"></a> <strong>5、对齐填充字节</strong></h3><p>在<code>Hotspot</code>的自动内存管理系统中，要求对象的起始地址必须是8字节的整数倍，也就是说对象的大小必须满足8字节的整数倍。因此如果实例数据没有对齐，那么需要进行对齐补全空缺，补全的<code>bit</code>位仅起占位符作用，不具有特殊含义。</p><p>在前面的例子中，我们已经对对齐填充有了充分的认识，下面再做一些补充：</p><ul><li>在开启指针压缩的情况下，如果类中有<code>long/double</code>类型的变量时，会在对象头和实例数据间形成间隙（<code>gap</code>），为了节省空间，会默认把较短长度的变量放在前边，这一功能可以通过jvm参数进行开启或关闭：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 开启</span><br><span class="line">-XX:+CompactFields</span><br><span class="line"># 关闭</span><br><span class="line">-XX:-CompactFields</span><br></pre></td></tr></table></figure><p>测试关闭情况，可以看到较短长度的变量没有前移填充：</p><p><img src="https://silenthty.gitee.io/photo/java%E6%B7%B1%E5%85%A5/%E5%AF%B9%E8%B1%A1v27.jpg" alt="" /></p><ul><li>在前面指针压缩中，我们提到了可以改变对齐宽度，这也是通过修改下面的jvm参数配置实现的：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:ObjectAlignmentInBytes</span><br></pre></td></tr></table></figure><p>默认情况下对齐宽度为8，这个值可以修改为2~256以内2的整数幂，一般情况下都以8字节对齐或16字节对齐。测试修改为16字节对齐：</p><p><img src="https://silenthty.gitee.io/photo/java%E6%B7%B1%E5%85%A5/%E5%AF%B9%E8%B1%A1v26.jpg" alt="" /></p><p>上面的例子中，在调整为16字节对齐的情况下，最后一行的属性字段只占了6字节，因此会添加10字节进行对齐填充。当然普通情况下不建议修改对齐长度参数，如果对齐宽度过长，可能会导致内存空间的浪费。</p><h3 id="6-总结"><a class="markdownIt-Anchor" href="#6-总结"></a> <strong>6、总结</strong></h3><p>本文通过使用<code>jol</code> 对java对象的结构进行调试，学习了对象内存布局的基本知识。通过学习，能够帮助我们：</p><ul><li>掌握对象内存布局，基于此基础进行jvm参数调优</li><li>了解对象头在<code>synchronize</code> 的锁升级过程中的作用</li><li>熟悉 jvm 中对象的寻址过程</li><li>通过计算对象大小，可以在评估业务量的基础上在项目上线前预估需要使用多少内存，防止服务器频繁gc</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;转自：&lt;a href=&quot;https://mp.weixin.qq.com/s/9O-8Rs-LAUrdXSLOpUFTyQ&quot;&gt;图文详解Java对象内存布局 (qq.com)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者：Dr Hydra&lt;/p&gt;
&lt;/blockquo</summary>
      
    
    
    
    <category term="java" scheme="https://silenthly.github.io/categories/java/"/>
    
    
    <category term="笔记" scheme="https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>数据库的基本操作语句</title>
    <link href="https://silenthly.github.io/2021/09/07/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E8%AF%AD%E5%8F%A5/"/>
    <id>https://silenthly.github.io/2021/09/07/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E8%AF%AD%E5%8F%A5/</id>
    <published>2021-09-07T04:23:43.000Z</published>
    <updated>2021-10-20T03:59:26.778Z</updated>
    
    <content type="html"><![CDATA[<p>​SQL（Structured Query Langue，结构化查询语言）是关系数据库的标准语言，也是一种数据库查询和程序设计语言，用于存取数据及查询、更新和管理关系数据库系统。</p><h3 id="sql语句的分类"><a class="markdownIt-Anchor" href="#sql语句的分类"></a> SQL语句的分类</h3><p>​SQL按其规则可以分为3种，即核心SQL，标准SQL和扩展SQL，其中前者是后者的子集。各个数据库厂商在支持标准的SQL语法的同时，在功能上都做了相应的扩充，在实现上略有不同。</p><p>​SQL语言包含三个部分：</p><ul><li><strong>数据定义语言（Data Definition Language，DDL）</strong>：用于建立数据库、表、视图、索引和触发器等，其中，<ol><li>CREATE语句主要用于创建数据库、创建表和创建视图等。</li><li>ALTER语句主要用于修改表的定义和视图的定义等。</li><li>DBOR语句主要是用于删除数据库、删除表和删除视图等。</li></ol></li><li><strong>数据操作语言（Data Manipulation Language，DML）</strong>：用于插入数据、查询数据、更新数据和删除数据等，其中：<ol><li>INSERT语句用于插入数据。</li><li>SELECT语句用于更新数据。</li><li>DELETE语句用于删除数据。</li></ol></li><li><strong>数据控制语言（Data Controlling Language，DCL）</strong>： 用于控制数据库组件的存取允许、存取权限等，其中：<ol><li>GRANT语句用于给用户增加权限。</li><li>REVOKE语句用于回收用户的权限。</li></ol></li></ul><blockquote><p>提示：还有事务控制语言（Transaction Control Language），主要有COMMIT和 ROLLBACK语句。</p></blockquote><h3 id="create-建表语句"><a class="markdownIt-Anchor" href="#create-建表语句"></a> CREATE 建表语句</h3><h4 id="创建数据库"><a class="markdownIt-Anchor" href="#创建数据库"></a> 创建数据库</h4><p>​创建数据库是指在数据库系统中划分一块空间，用来存储相应的数据。在MySQL中可以通过CREATE DATABASE实现，其语法格式如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE 数据库名称；</span><br></pre></td></tr></table></figure><p>​其中，“数据库名称”表示要创建的数据库名。</p><blockquote><p>提示：若想知道系统中存在哪些数据库，可以使用SHOW DATABASES查看。数据库命令不区分大小写，SQL推荐使用大写，但是使用小写也可以。</p></blockquote><p>代码示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE javaTest;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Query OK, 1 row affected (0.00 sec)</span><br></pre></td></tr></table></figure><p>​以上SQL语句创建了一个名为javaTest的数据库，如果在安装时没有更改过安装路径的话，数据库的存放路径在C:\ProgramData\MySQL\MySQL Server 5.7\Data里。</p><h4 id="创建数据表"><a class="markdownIt-Anchor" href="#创建数据表"></a> 创建数据表</h4><p>​在MySQL中还可以利用CREATE TABLE创建数据表，其语法格式如下所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名</span><br><span class="line">&#123;</span><br><span class="line">    属性名1 数据类型 [完整性约束条件],</span><br><span class="line">    属性名2 数据类型 [完整性约束条件],</span><br><span class="line">    ...</span><br><span class="line">    属性名n 数据类型 [完整性约束条件],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​其中，&quot;表名&quot;的是要创建的数据表的名称，&quot;属性名&quot;表示数据表的字段名称，&quot;数据类型&quot;表示该字段的数据类型，“完整性约束条件&quot;表示该字段需要满足某些约束条件。在创建表前，需要先使用”<code>USE 数据库名;</code>&quot;进入数据库。</p><blockquote><p>注意：在使用CREATE TABLE创建数据表时，有以下需要注意。</p><ul><li>在使用CREATE TABLE数据表前，要执行“USE 数据库名”选择数据库，因为创建表需要在已存在的数据库中建立数据表。若没有选择数据库，则会出现“ERROR 1046（3D000）:NO database selected”错误。</li><li>在创建数据表的数据库内，不能存在两个名称相同的数据表，所以创建数据表前可以执行SHOW TABLES查看数据库内的数据表有哪些。</li><li>各个属性之间用英文逗号（,）隔开，最后一个不需要逗号。</li></ul></blockquote><p>代码示例：(创建数据表)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 学生(</span><br><span class="line">学号 INT(10) NOT NULL,</span><br><span class="line">姓名 VARCHAR(16) DEFAULT NULL,</span><br><span class="line">性别 VARCHAR(4) DEFAULT NULL,</span><br><span class="line">籍贯 VARCHAR(16) DEFAULT NULL,</span><br><span class="line">生日 DATE DEFAULT NULL,</span><br><span class="line">院系 VARCHAR(16) DEFAULT NULL</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></table></figure><p>​以上SQL语句创建了一个名为&quot;学生&quot;的数据表，包括&quot;学号&quot;、“姓名”、“性别”、“籍贯”、&quot;生日&quot;和&quot;院系&quot;字段，其中&quot;学号&quot;是主键。MySQL中完整性约束条件如下表所示。</p><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">约束条件</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">PRIMARY KEY</td><td style="text-align:center">主键</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">FOREIGN KEY</td><td style="text-align:center">外键</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">NOT NULL</td><td style="text-align:center">不能为空</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">UNIQUE</td><td style="text-align:center">唯一索引</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">AUTO_INCREMENT</td><td style="text-align:center">自动增加</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">DEFAULT</td><td style="text-align:center">默认值</td></tr></tbody></table><h4 id="insert插入语句"><a class="markdownIt-Anchor" href="#insert插入语句"></a> INSERT插入语句</h4><p>​此时已经创建好了一个数据表，可以向表中增加记录。增加记录是数据库操作中最常使用的操作之一。可以有两种形式：一种是一条一条的增加，就是一次添加一条记录；另一种是批量添加，就是一次添加多条记录。</p><p>​MySQL支持多种增加记录的格式，其语法格式分别如下所示。</p><p>格式一：INSERT语句中不指定具体的字段名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO 表名 VALUES (值1,值2...);</span><br></pre></td></tr></table></figure><p>格式二：INSERT语句中列出所有字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO 表名 (属性1,属性2...) VALUES (值1,值2...)</span><br></pre></td></tr></table></figure><p>格式三：为表的指定字段插入数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO 表名 (属性1,属性2...) VALUES (值1,值2...)</span><br></pre></td></tr></table></figure><p>格式四：批量插入数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO 表名 (属性1,属性2...) VALUES</span><br><span class="line">(值1,值2...),</span><br><span class="line">(值1,值2...),</span><br><span class="line">...</span><br><span class="line">(值1,值2...);</span><br></pre></td></tr></table></figure><p>​其中，&quot;表名&quot;表示增加的记录插入到哪个表中，&quot;属性&quot;表示表中的字段，&quot;值&quot;表示表中字段的值，这些值与相应的属性相对应。</p><p>代码示例：(一次增加多条记录)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO 学生 (学号,姓名,性别,籍贯,生日,院系) VALUES</span><br><span class="line">(&#x27;01&#x27;,&#x27;小强&#x27;,&#x27;男&#x27;,&#x27;广东&#x27;,&#x27;2000-01-01&#x27;,&#x27;计算机科学与技术学院&#x27;),</span><br><span class="line">(&#x27;10&#x27;,&#x27;小明&#x27;,&#x27;男&#x27;,&#x27;海南&#x27;,&#x27;2001-09-02&#x27;,&#x27;艺术学院&#x27;),</span><br><span class="line">(&#x27;13&#x27;,&#x27;小红&#x27;,&#x27;女&#x27;,&#x27;湖北&#x27;,&#x27;2001-10-21&#x27;,&#x27;数学学院&#x27;),</span><br><span class="line">(&#x27;98&#x27;,&#x27;小晨&#x27;,&#x27;女&#x27;,&#x27;重庆&#x27;,&#x27;2002-12-14&#x27;,&#x27;外语学院&#x27;);</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Query OK, 4 rows affected (0.05 sec)</span><br><span class="line">Records: 4  Duplicates: 0  Warnings: 0</span><br></pre></td></tr></table></figure><p>​以上程序，可能因为字符编码问题而造成“<code>ERROR 1366 (HY000): Incorrect string value: '\xE5\xB0\x8F\xE5\xBC\xBA' for column '姓名' at row 1</code>”问题，这时就需要修改表属性的编码，可以执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 CHARACTER SET utf8;//修改表的编码</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 CHANGE 属性名 属性名 数据类型 CHARACTER SET utf8 完整性约束条件;//修改属性字段的编码</span><br></pre></td></tr></table></figure><p>​上面的命令只能修改一个属性，若属性很多，一条一条地更改则操作过于繁杂，可以使用下面命令一次性修改完表中所有属性的编码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 CONVERT TO CHARACTER SET utf8;//修改表中所有属性字段的编码</span><br></pre></td></tr></table></figure><h3 id="select-查询语句"><a class="markdownIt-Anchor" href="#select-查询语句"></a> SELECT 查询语句</h3><p>​查询语句可以从一个或多个表汇总检索信息。查询语句是SQL语句中最常使用的、最重要，同时也是最难用好的命令，其语法格式如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT 属性列表</span><br><span class="line">FROM 表名</span><br><span class="line">[WHERE 条件表达式1]</span><br><span class="line">[GROUP BY 属性名1 [HAVING 条件表达式2]]</span><br><span class="line">[ORDER BY 属性名2[ASC|DESC]]</span><br></pre></td></tr></table></figure><p>​其中，SELECT是查询语句的关键字，&quot;属性列表&quot;表示需要查询的字段，FROM表示从指定的表中查询，WHERE表示查询条件，ASC表示升序排序，默认为升序排序，DESC表示降序排序。</p><p>代码示例：(查询信息)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT 学号,姓名,性别,籍贯,生日,院系</span><br><span class="line">FROM 学生;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+--------+--------+--------+--------+------------+--------------------------------+</span><br><span class="line">| 学号   | 姓名   | 性别   | 籍贯   | 生日       | 院系                           |</span><br><span class="line">+--------+--------+--------+--------+------------+--------------------------------+</span><br><span class="line">|     01 | 小强   | 男     | 广东   | 2000-01-01 | 计算机科学与技术学院           |</span><br><span class="line">|     10 | 小明   | 男     | 海南   | 2001-09-02 | 艺术学院                       |</span><br><span class="line">|     13 | 小红   | 女     | 湖北   | 2001-10-21 | 数学学院                       |</span><br><span class="line">|     98 | 小晨   | 女     | 重庆   | 2002-12-14 | 外语学院                       |</span><br><span class="line">+--------+--------+--------+--------+------------+--------------------------------+</span><br><span class="line">4 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>​以上的SQL语句查询中，还可以通过&quot;SELECT  * FROM 学生&quot;表示查询表中所有的字段信息。</p><p>代码示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT 学号,姓名,性别,籍贯,生日,院系</span><br><span class="line">FROM 学生</span><br><span class="line">WHERE 学号=13;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+--------+--------+--------+--------+------------+--------------+</span><br><span class="line">| 学号   | 姓名   | 性别   | 籍贯   | 生日       | 院系         |</span><br><span class="line">+--------+--------+--------+--------+------------+--------------+</span><br><span class="line">|     13 | 小红   | 女     | 湖北   | 2001-10-21 | 数学学院     |</span><br><span class="line">+--------+--------+--------+--------+------------+--------------+</span><br><span class="line">1 row in set (0.04 sec)</span><br></pre></td></tr></table></figure><h3 id="delete-删除语句"><a class="markdownIt-Anchor" href="#delete-删除语句"></a> DELETE 删除语句</h3><p>​使用DELETE语句可以删除数据表中已经存在的记录，DELETE语句的语法格式如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM 表名 [WHERE 条件表达式];</span><br></pre></td></tr></table></figure><p>​其中，&quot;表名&quot;表示从哪个包中删除数据，WHERE表示删除满足条件的数据，若没有该条件，将删除表中所有的数据。</p><p>代码示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM 学生 WHERE 院系=&#x27;外语学院&#x27;;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Query OK, 1 row affected (0.03 sec)</span><br></pre></td></tr></table></figure><p>​执行上述的DELETE语句后，再次查询学生表中的数据如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select 学号,姓名,性别,籍贯,生日,院系 from 学生;</span><br><span class="line">+------+------+------+------+------------+----------------------+</span><br><span class="line">| 学号 | 姓名 | 性别 | 籍贯 | 生日       | 院系                 |</span><br><span class="line">+------+------+------+------+------------+----------------------+</span><br><span class="line">|   01 | 小强 | 男   | 广东 | 2000-01-01 | 计算机科学与技术学院 |</span><br><span class="line">|   10 | 小明 | 男   | 海南 | 2001-09-02 | 艺术学院             |</span><br><span class="line">|   13 | 小红 | 女   | 湖北 | 2001-10-21 | 数学学院             |</span><br><span class="line">+------+------+------+------+------------+----------------------+</span><br><span class="line">3 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><h3 id="update-更新语句"><a class="markdownIt-Anchor" href="#update-更新语句"></a> UPDATE 更新语句</h3><p>​使用UPDATE语句可以更新数据库中已存在的记录，其语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UPDATE 表名</span><br><span class="line">SET 属性1=值1,属性2=值2,</span><br><span class="line">...</span><br><span class="line">属性n=值n</span><br><span class="line">WHERE 条件表达式;</span><br></pre></td></tr></table></figure><p>​其中，&quot;属性&quot;表示表中需要更新的字段，&quot;值&quot;表示字段更改的新值。</p><p>代码示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE 学生</span><br><span class="line">SET 姓名=&#x27;王小明&#x27;,籍贯=&#x27;浙江&#x27;;</span><br><span class="line">WHERE 学号=&#x27;10&#x27;;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Query OK, 3 rows affected (0.00 sec)</span><br><span class="line">Rows matched: 3  Changed: 3  Warnings: 0</span><br></pre></td></tr></table></figure><p>​执行上述的UPDATE语句后，再次查询学生表中的数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from 学生;</span><br><span class="line">+------+--------+------+------+------------+----------------------+</span><br><span class="line">| 学号 | 姓名   | 性别 | 籍贯 | 生日       | 院系                 |</span><br><span class="line">+------+--------+------+------+------------+----------------------+</span><br><span class="line">|    1 | 小强   | 男   | 广东 | 2000-01-01 | 计算机科学与技术学院 |</span><br><span class="line">|   10 | 王小明 | 男   | 浙江 | 2001-09-02 | 艺术学院             |</span><br><span class="line">|   13 | 小红   | 女   | 湖北 | 2001-10-21 | 数学学院             |</span><br><span class="line">+------+--------+------+------+------------+----------------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>​可以发现数据表中学号为&quot;10&quot;的记录已经发生改变。</p><h3 id="alter-修改表语句"><a class="markdownIt-Anchor" href="#alter-修改表语句"></a> ALTER 修改表语句</h3><p>​使用ALTER语句可以修改已存在的表而不需要将表删除后再创建，也不会影响正在进行的服务。ALTER语句可以修改表名、表中的字段名和表中字段的排序等，其语法格式如下。</p><p>格式一：修改表名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 旧表名 RENAME [TO] 新表名;</span><br></pre></td></tr></table></figure><p>格式二：修改字段的数据类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 MODIFY 属性名 数据类型;</span><br></pre></td></tr></table></figure><p>格式三：增加表中的字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD 属性1 数据类型 [完整性约束条件] [FIRST|AFTER 属性名2];</span><br></pre></td></tr></table></figure><p>格式四：删除表中的字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 DROP 属性名;</span><br></pre></td></tr></table></figure><p>格式五：修改表中的字段名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 CHANGE 旧属性名 新属性名 新数据类型;</span><br></pre></td></tr></table></figure><p>代码示例：(修改表中的字段名)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 学生 CHANGE 院系 学院 VARCHAR(16);</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br></pre></td></tr></table></figure><p>​执行上述ALTER语句后，再次查询学生表中的数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from 学生;</span><br><span class="line">+------+--------+------+------+------------+----------------------+</span><br><span class="line">| 学号 | 姓名   | 性别 | 籍贯 | 生日       | 学院                 |</span><br><span class="line">+------+--------+------+------+------------+----------------------+</span><br><span class="line">|    1 | 小强   | 男   | 广东 | 2000-01-01 | 计算机科学与技术学院 |</span><br><span class="line">|   10 | 王小明 | 男   | 浙江 | 2001-09-02 | 艺术学院             |</span><br><span class="line">|   13 | 小红   | 女   | 湖北 | 2001-10-21 | 数学学院             |</span><br><span class="line">+------+--------+------+------+------------+----------------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>​可以发现数据表中&quot;院系&quot;被改成了&quot;学院&quot;。</p><h3 id="drop-删除表语句"><a class="markdownIt-Anchor" href="#drop-删除表语句"></a> DROP 删除表语句</h3><p>​在MySQL中可以通过DROP TABLE语句删除已存在的数据表，在删除表的同时也会删除表中的所有数据，其语法格式如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE 表名;</span><br></pre></td></tr></table></figure><p>​其中，&quot;表名&quot;表示需要删除的表。注意，此方法仅能删除没有被其他表关联的普通表。</p><p>代码示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE 学生;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></table></figure><p>​执行上述的DROP TABLE语句后，再次查询javaTest数据库中的表，结果如下所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show tables;</span><br><span class="line">Empty set (0.01 sec)</span><br></pre></td></tr></table></figure><p>​可以发现javaTest数据库为空，不存在数据表，说明学生表被删除成功。</p><h3 id="mysql-中的数据类型"><a class="markdownIt-Anchor" href="#mysql-中的数据类型"></a> MySQL 中的数据类型</h3><p>​MySQL数据库提供了多种数据类，其中包括整数类型、浮点类型、定点数类型、日期时间类型、字符串类型和二进制类型。每一行数据类型都有各自的特性，其取值范围、存储的方式都不同。MysQL数据库数据类型如下表所示。</p><table>    <tr>        <td><center>序号</center></td>        <td><center>类别</center></td>        <td><center>数据类型</center></td>        <td><center>长度(字节数)</center></td>        <td><center>说明</center></td>    </tr>    <tr>        <td><center>1</center></td>        <td rowspan="6"><center>整数类型</center></td>        <td><center>TINYINT</center></td>        <td><center>1</center></td>        <td><center>如果为无符号数，其取值范围为 0～225；若为符号数，则取值范围为-128～127</center></td>    </tr>    <tr>        <td><center>2</center></td>        <td><center>SMALLINT</center></td>        <td><center>2</center></td>        <td><center>如果为无符号数，其取值范围为 0～65535；若为符号数，则取值范围为-32768~32767 </center></td>    </tr>    <tr>        <td><center>3</center></td>        <td><center>MEDIUMINT</center></td>        <td><center>3</center></td>        <td><center>如果为无符号数，其取值范围为 0～16777215；若为符号数，则取值范围为-8388638～8388637 </center></td>    </tr>    <tr>        <td><center>4</center></td>        <td><center>INT</center></td>        <td><center>4</center></td>        <td><center>如果为无符号数，其取值范围为 0～4294967295；若为符号数，则取值范围为-2147483648～2147483647 </td>    </tr>    <tr>        <td><center>5</center></td>        <td><center>INTEGER</center></td>        <td><center>4</center></td>        <td><center>如果为无符号数，其取值范围为 0～4294967295；若为符号数，则取值范围为-2147483648～2147483647 </center></td>    </tr>    <tr>        <td><center>6</center></td>        <td><center>BIGINT</center></td>        <td><center>8</center></td>        <td><center>如果为无符号数，其取值范围为 0 ～18446744073709551615；若为符号数，则取值范围为-9223372036854775808～9223372036854775807 </center></td>    </tr>    <tr>        <td><center>7</center></td>        <td rowspan="3"><center>浮点型和定点型</center></td>        <td><center>FOLAT</center></td>        <td><center>4</center></td>        <td><center>4 如果为负数，其取值范围为-3.402823466E+38～-1.175494351E-38；若为非负数，则取值范围 0 和1.175494351E-38～3.402823466E+38 </center></td>    </tr>    <tr>        <td><center>8</center></td>        <td><center>DOUBLE</center></td>        <td><center>8</center></td>        <td><center>如果为负数，其取值范围为-1.7976931348623157E+308～-2.2250738585072014E-308；若为非负数，则取值范围为0和2.2250738585072014E-308～1.7976931348623157E+308</center></td>    </tr>    <tr>        <td><center>9</center></td>        <td><center>MECIMAL(M,D)或DEC(M,D)</center></td>        <td><center>M+2</center></td>        <td><center>如果为负数，其取值范围为-1.7976931348623157E+ 308～-2.2250738585072014E-308；若为非负数，则取值范围为 0 和 2.2250738585072014E-308 ～1.7976931348623157E+308</center></td>    </tr>    <tr>        <td><center>10</center></td>        <td rowspan="5"><center>日期与时间类型</center></td>        <td><center>YEAR</center></td>        <td><center>1</center></td>        <td><center>其取值范围为 1901～2155，0 值为 0000 </center></td>    </tr>    <tr>        <td><center>11</center></td>        <td><center>DATE</center></td>        <td><center>4</center></td>        <td><center>其取值范围为 1000-01-01 ～ 9999-12-31 ， 0 值为0000:00:00 </center></td>    </tr>    <tr>        <td><center>12</center></td>        <td><center>TIME</center></td>        <td><center>3</center></td>        <td><center>其取值范围为-838:59:59～838:59:59，0 值为 00:00:00</center></td>    </tr>    <tr>        <td><center>13</center></td>        <td><center>DATETIME</center></td>        <td><center>8</center></td>        <td><center>其取值范围为 1000-01-01 00:00:00 ～ 9999-12-31 23:59:59，0 值为 0000-00-00 00:00:00 </center></td>    </tr>    <tr>        <td><center>14</center></td>        <td><center>TIMESTAMP</center></td>        <td><center>4</center></td>        <td><center>其取值范围为 19700101080001～20380119111407，0值为 00000000000000 </center></td>    </tr>    <tr>        <td><center>15</center></td>        <td rowspan="2"><center>字符串类型</center></td>        <td><center>char(M)</center></td>        <td><center>M</center></td>        <td><center>定长字符串</center></td>    </tr>    <tr>        <td><center>16</center></td>        <td><center>varchar(M)</center></td>        <td><center>最大为M</center></td>        <td><center>变长字符串</center></td>    </tr>    <tr>        <td><center>17</center></td>        <td rowspan="4"><center>TEXT(文本)类型</center></td>        <td><center>TINYTEXT</center></td>        <td><center>最大255</center></td>        <td><center> 允许的长度为 0～255 字节，存储空间为：值的长度+2 个字节</center></td>    </tr>    <tr>        <td><center>18</center></td>        <td><center>TEXT</center></td>        <td><center>最大为64KB</center></td>        <td><center>允许的长度为 0～65535 字节，存储空间为：值的长度+2 个字节</center></td>    </tr>    <tr>        <td><center>19</center></td>        <td><center>MEDIUMTEXT</center></td>        <td><center>最大为16MB</center></td>        <td><center>允许的长度为 0～167772150 字节，存储空间为：值的长度+3 个字节</center></td>    </tr>    <tr>        <td><center>20</center></td>        <td><center>LONGTEXT</center></td>        <td><center>最大为4GB</center></td>        <td><center>允许的长度为 0～42949667295 字节，存储空间为：值的长度+4 个字节</center></td>    </tr>    <tr>        <td><center>21</center></td>        <td><center>ENUM(枚举)类型</center></td>        <td><center>ENUM</center></td>        <td><center>1或2</center></td>        <td><center>最多可以取 65535 个值</center></td>    </tr>    <tr>        <td><center>22</center></td>        <td><center>SET类型</center></td>        <td><center>SET</center></td>        <td><center>8</center></td>        <td><center>最大可为64个不同的值</center></td>    </tr>    <tr>        <td><center>23</center></td>        <td rowspan="8"><center>二进制类型</center></td>        <td><center>BINARY(M)</center></td>        <td><center>最大为M</center></td>        <td><center> 定长二进制，字节数为 M，允许长度为 0～M </center></td>    </tr>    <tr>        <td><center>24</center></td>        <td><center>VARBINARY(M)</center></td>        <td><center>最大为M</center></td>        <td><center> 可变二进制，允许长度为 0～M，字节数为值的长度加 1 </center></td>    </tr>    <tr>        <td><center>25</center></td>        <td><center>BIT(M)</center></td>        <td><center>最大为M</center></td>        <td><center> M 最大为 64 </center></td>    </tr>    <tr>        <td><center>26</center></td>        <td><center>TINYBLOB</center></td>        <td><center>最多为225</center></td>        <td><center>TINYBLOB 为大小写敏感，为可变二进制</center></td>    </tr>    <tr>        <td><center>27</center></td>        <td><center>BLOB</center></td>        <td><center>最大为64K</center></td>        <td><center>BLOB 为大小写敏感，为可变二进制</center></td>    </tr>    <tr>        <td><center>28</center></td>        <td><center>MEDIUMBLOB</center></td>        <td><center>最大为16MB</center></td>        <td><center>MEDIUMBLOB 为大小写敏感，为可变二进制</center></td>    </tr>    <tr>        <td><center>29</center></td>        <td><center>LONGBLOB</center></td>        <td><center>最大为4GB</center></td>        <td><center>LONGBLOB 为大小写敏感，为可变二进制</center></td>    </tr></table><p>​读者可以根据自身的需求选择合适的数据类型，一般常用的数据类型有 INT、FLOAT、VARCHAR(M)、TEXT、DATE、TIME 和 BLOB。</p><p>参考书目：</p><p><a href="http://product.dangdang.com/23248198.html?ref=book-35530-3032_5-231497-4">《Java编程手记——从实践中学习Java（配光盘）》(欧二强　等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​		SQL（Structured Query Langue，结构化查询语言）是关系数据库的标准语言，也是一种数据库查询和程序设计语言，用于存取数据及查询、更新和管理关系数据库系统。&lt;/p&gt;
&lt;h3 id=&quot;sql语句的分类&quot;&gt;&lt;a class=&quot;markdownIt-An</summary>
      
    
    
    
    <category term="java" scheme="https://silenthly.github.io/categories/java/"/>
    
    
    <category term="笔记" scheme="https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>数据库概念</title>
    <link href="https://silenthly.github.io/2021/09/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E5%BF%B5/"/>
    <id>https://silenthly.github.io/2021/09/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E5%BF%B5/</id>
    <published>2021-09-06T06:23:54.000Z</published>
    <updated>2021-09-06T13:22:47.256Z</updated>
    
    <content type="html"><![CDATA[<p>​数据库在程序开发中占有非常重要的地位，现在常用的数据库有Oracle、SQL Server和MySQL等，这些数据库主要是关系数据库。</p><p>​目前关于数据库的概念，还没有一个明确的定义，主要原因是数据库是一门新兴的学科，它的概念、原理和方法都在不断的变化中发展。数据库的设计领域非常广泛，不同的学科给出了不同的定义。最为通用的定义为：数据库是指在计算机的存储设备上合理存放相关联、有结构的数据集合。</p><p>​以上的定义有如下定义：</p><p>（1）数据库是在计算机上存放并运行的，属于计算机领域。</p><p>（2）数据库是一个数据集合。</p><p>（3）数据集合是有一定的结构的、相关联的数据集合。</p><p>（4）数据集合需要合理存放，也就是数据库的规范和优化。</p><p>​数据库系统是一个比较复杂的系统，包括计算机的软件、硬件环境，以及数据库、数据库管理系统和数据库管理员等相互关联的多个部分。</p><blockquote><p>注意：数据库不是数据库系统。</p></blockquote><h3 id="数据库系统的特点"><a class="markdownIt-Anchor" href="#数据库系统的特点"></a> 数据库系统的特点</h3><p>​自 20 世纪 60 年代后期以来，为了克服文件系统存在的问题，同时适应数据的处理需求，数据库技术因此应运而生。经过多年的发展，数据库系统一般具有以下主要的特点。</p><p>（1）数据结构化。</p><p>​<strong>数据结构化是数据库系统与文件系统的根本区别。</strong></p><p>​在文件系统中整体上不存在结构化，并且数据的存放只有开发人员了解数据的含义和存放位置等。数据库系统中的数据是<strong>按照一定的数据模型来组织、描述和存储的</strong>，这个数据模型能够正确描述现实世界中各种数据组织和数据间的联系。</p><p>（2）数据冗余度小，共享性高，避免数据的不一致。</p><p>​<strong>相同的数据在数据库中只会被存储一次</strong>，并被多个应用共享，所以大大降低了数据的冗余度，提高了共享性。如果一个数据多个地方存放，若需要修改，则必须修改所有地方的数据。一旦漏掉了一个地方，就会导致数据的不一致。</p><p>（3）具有较高的数据独立性。</p><p>​数据的独立性是指数据库中的数据与应用程序的无关性。一般数据独立性可以分为数据的逻辑独立性和物理独立性。</p><p>​<strong>逻辑独立性是指数据的全局逻辑与局部逻辑结构之间的相互独立性</strong>。当全局逻辑结构改变时，可以改变全局逻辑结构与局部逻辑结构之间的映射关系。而与某个具体的应用相关的逻辑结构不需要改变，因而应用程序也不需要改变。</p><p>​<strong>物理独立性是指数据的存储结构与全局逻辑结构之间的相互独立性</strong>。当改变数据库中的存储结构时，不影响全局逻辑结构，只要不改变全局逻辑结构就不改变应用程序。</p><p>（4）数据由数据库管理系统（DBMS）统一管理和控制。</p><p>​数据库管理系统提供了如下几种数据控制功能。</p><ul><li>安全性控制，以防止数据的丢失、错误更新和越权使用等问题，而造成的数据泄密和破坏。</li><li>完整性控制，是将数据控制在一个有效的范围内或使数据满足一定的关系，以保证数据的正确性、有效性和相容性。</li><li>并发控制，使在同一时间周期内，允许对数据实现多路存取，又可以防止用户之间的不正常交互作用。</li><li>数据库的故障、发现和恢复。</li></ul><h3 id="数据库的分类"><a class="markdownIt-Anchor" href="#数据库的分类"></a> 数据库的分类</h3><p>​数据库中常用的数据类型有4种，分别是层次模型、网状模型、关系模型和面向对象模型。</p><h4 id="层次模型"><a class="markdownIt-Anchor" href="#层次模型"></a> 层次模型</h4><p>​层次模型是按照层次结构表示实体集与实体集之间的联系模型。层次模型中用结点表示实体集，结点之间联系基本方式是1：n，如下图所示。</p><p><img src="https://silenthty.gitee.io/photo/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E6%95%B0%E6%8D%AE%E5%BA%931.png" alt="" /></p><p>​层次模型一般满足以下条件：</p><ul><li>有且只有一个结点没有双亲结点（即根结点）。</li><li>根结点以外的其他结点有且只有一个双亲结点。</li></ul><p>​层次模型的特点是<strong>结点之间的联系通过指针来实现</strong>，一般的常用方法有邻接法和链表法。由于采用指针实现记录间的联系，所以层次模型具有查询效率高、结构简单、层次分明和便于在计算机实现的优点。</p><p>​但层次模型也是有缺点的，一是层次数据模式缺乏直接表达现实世界中非层次模型结构的复杂联系；二是层次顺序的严格限制，使得对插入或删除操作也带来了较多的限制， 并且查询子结点只能通过双亲结点。</p><h4 id="网状结构"><a class="markdownIt-Anchor" href="#网状结构"></a> 网状结构</h4><p>​网状模型基本上消除了层次模型的限制，它不但允许一个以上的结点无双亲，而且允许一个结点有多个的双亲。在网状模型中是采用网络结构表示实体类型、实体间联系的数据模型，可以实现多对多的联系，如图所示。</p><p><img src="https://silenthty.gitee.io/photo/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E6%95%B0%E6%8D%AE%E5%BA%932.png" alt="" /></p><p>​网状模型的优点是可以直接描述和记录现实世界，记录之间的联系也是通过指针来实现的，查询效率高；缺点是结构和编程复杂，难掌握，不易使用。</p><h4 id="关系模型"><a class="markdownIt-Anchor" href="#关系模型"></a> 关系模型</h4><p>​关系数据模型最重要的特征就是<strong>使用二维表表示现实世界实体之间的联系</strong>。关系型数据库也是当前最为流行的数据库模型。</p><h4 id="面向对象模型"><a class="markdownIt-Anchor" href="#面向对象模型"></a> 面向对象模型</h4><p>​面向对象数据模型是面向对象程序设计方法与数据库技术结合的产物。它的目标是以更为接近人类思维的方式，来描述和记录现实世界实体及实体之间的联系。</p><p>参考书目：</p><p><a href="http://product.dangdang.com/23248198.html?ref=book-35530-3032_5-231497-4">《Java编程手记——从实践中学习Java（配光盘）》(欧二强　等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​		数据库在程序开发中占有非常重要的地位，现在常用的数据库有Oracle、SQL Server和MySQL等，这些数据库主要是关系数据库。&lt;/p&gt;
&lt;p&gt;​		目前关于数据库的概念，还没有一个明确的定义，主要原因是数据库是一门新兴的学科，它的概念、原理和方法都在不断的变化</summary>
      
    
    
    
    <category term="java" scheme="https://silenthly.github.io/categories/java/"/>
    
    
    <category term="笔记" scheme="https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>UDP程序设计</title>
    <link href="https://silenthly.github.io/2021/08/29/UDP%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <id>https://silenthly.github.io/2021/08/29/UDP%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</id>
    <published>2021-08-29T13:14:23.000Z</published>
    <updated>2021-08-31T14:06:37.662Z</updated>
    
    <content type="html"><![CDATA[<p>​在 TCP/IP 协议的传输层中，除了前面介绍过的 TCP 协议以外，还可以使用 UDP 协议。 UDP 是一种无连接的客户/服务器（C/S）通信协议，用于不可靠的点对点通信，适合对通信性能要求高但通信可靠性要求低的应用，还支持广播和多播通信方式。</p><h3 id="udp-简介"><a class="markdownIt-Anchor" href="#udp-简介"></a> UDP 简介</h3><p>​前面学习的 TCP 是所有操作都必须建立可靠的连接，这样肯定会浪费大量的系统资源。为了减小花销还可以使用另外一种传输协议——UDP。UDP 协议是一种面向非连接的协议，<strong>面向非连接指的是在正式通信前不必与对方先建立连接，不管对方状态就直接发送</strong>。 至于对方是否可以接收到这些数据内容，则 UDP 协议是无法控制的，因此说 UDP 协议是 一种不可靠的协议。<strong>UDP 适用于一次只传送少量数据、对可靠性要求不高的应用环境</strong>。</p><p>​使用 UDP 发送的信息，对方不一定会接收到，所有的信息使用数据报的形式发送出 去对于基于 UDP 协议的通信双方而言，没有明显的客户端和服务器端的概念。在 Java 中使用 DatagramPacket 类和 DatagramSocket 类完成 UDP 程序的开发。</p><h3 id="datagrampacket-类"><a class="markdownIt-Anchor" href="#datagrampacket-类"></a> DatagramPacket 类</h3><p>​<a href="http://java.net">java.net</a> 包中的 DatagramPacket 类用来表示数据包。DatagramPacket 类的常用方法如下表所示。</p><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">方法</th><th style="text-align:center">类型</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><strong>1</strong></td><td style="text-align:center"><strong>public DatagramPacket(byte[] buf,int length)</strong></td><td style="text-align:center"><strong>构造</strong></td><td style="text-align:center">构造DatagramPacket对象，用来<strong>接收</strong>长度为length的数据包</td></tr><tr><td style="text-align:center"><strong>2</strong></td><td style="text-align:center"><strong>public DatagramPacket(byte[] bug,int length,InetAddress address,int port)</strong></td><td style="text-align:center"><strong>构造</strong></td><td style="text-align:center"><strong>构造DatagramPacket对象，用来将长度为length的包发送到指定主机上的指定端口</strong></td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">public DatagramPacket(byte[] buf,int offset,int length)</td><td style="text-align:center">构造</td><td style="text-align:center">构造DatagramPacket对象，用来<strong>接收</strong>长度为length的包，在缓冲区中指定了偏移量</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">public DatagramPacket(byte[] buf,int offset,int length,InetAddress address,int port)</td><td style="text-align:center">构造</td><td style="text-align:center">构造DatagramPacket对象，用来发送长度为length偏移量为offset的包，发送到指定主机上的指定端口号</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">public DatagramPacket(byte[] buf,int offset,int length,SocketAddress address)throws SocketException</td><td style="text-align:center">构造</td><td style="text-align:center">构造DatagramPacket对象，用来发送长度为length偏移量为offset的包，发送到指定主机上的指定端口号</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">public DatagramPacket(byte[] bug,int length,SocketAddress address)throws SocketException</td><td style="text-align:center">构造</td><td style="text-align:center">构造DatagramPacket对象，用来将长度为 length 的包 发送到指定主机上的指定端口号</td></tr><tr><td style="text-align:center"><strong>7</strong></td><td style="text-align:center"><strong>public InetAddress getAddress()</strong></td><td style="text-align:center"><strong>普通</strong></td><td style="text-align:center"><strong>获取将要发往机器或从该机器接收到的IP地址</strong></td></tr><tr><td style="text-align:center"><strong>8</strong></td><td style="text-align:center"><strong>public byte[] getData()</strong></td><td style="text-align:center"><strong>普通</strong></td><td style="text-align:center"><strong>获取数据缓冲区信息</strong></td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">public int getLength()</td><td style="text-align:center">普通</td><td style="text-align:center">获取将要发送或接收到的数据长度</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">public int getOffset()</td><td style="text-align:center">普通</td><td style="text-align:center">获取将要发送或接收到的数据偏移量</td></tr><tr><td style="text-align:center"><strong>11</strong></td><td style="text-align:center"><strong>public int getPort()</strong></td><td style="text-align:center"><strong>普通</strong></td><td style="text-align:center"><strong>获取将要发往该主机或者是从该主机接收到的端口号</strong></td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">public SocketAddress getSocketAddress()</td><td style="text-align:center">普通</td><td style="text-align:center">获取要将此包发送到的或发出此数据报的远程主机的SocketAddress（通常为IP地址 + 端口号）</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">public void setAddress(InetAddress iaddr)</td><td style="text-align:center">普通</td><td style="text-align:center">设置接收数据包的远程主机的IP地址</td></tr><tr><td style="text-align:center">14</td><td style="text-align:center">public void setData(byte[] buf)</td><td style="text-align:center">普通</td><td style="text-align:center">为此包设置数据缓冲区</td></tr><tr><td style="text-align:center">15</td><td style="text-align:center">public void setData(byte[] buf, int offset, int  length)</td><td style="text-align:center">普通</td><td style="text-align:center">为此包设置数据缓冲区</td></tr><tr><td style="text-align:center">16</td><td style="text-align:center">public void setLength(int length)</td><td style="text-align:center">普通</td><td style="text-align:center">为此包设置长度</td></tr><tr><td style="text-align:center">17</td><td style="text-align:center">public void setPort(int iport)</td><td style="text-align:center">普通</td><td style="text-align:center">设置接收数据包的远程主机的端口号</td></tr><tr><td style="text-align:center">18</td><td style="text-align:center">public void setSocketAddress(SocketAddress  address)</td><td style="text-align:center">普通</td><td style="text-align:center">设置要将此数据报发往的远程主机的 SocketAddress（通常为 IP 地址+端口号）</td></tr></tbody></table><h3 id="datagramsocket-类"><a class="markdownIt-Anchor" href="#datagramsocket-类"></a> DatagramSocket 类</h3><p>​DatagramSocket 类用于创建接收或发数据报的 Socket 对象。在 C/S 程序中使用 UDP 协议时，实际上并没有明显的服务端与客户端的区别。因为通信双方都需要先建立一个 DatagramSocket 对象，用来接收或发送数据报，然后使用 DatagramPacket 对象作为传输数据的载体。DatagramSocket 类的常用方法如下表所示。</p><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">方法</th><th style="text-align:center">类型</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">public DatagramSocket() throws Socket  Exception</td><td style="text-align:center">构造</td><td style="text-align:center">创建一个 DatagramSocket 对象并将其绑定到本地主机上任何可用的端口</td></tr><tr><td style="text-align:center"><strong>2</strong></td><td style="text-align:center"><strong>public DatagramSocket(int port) throws  SocketException</strong></td><td style="text-align:center"><strong>构造</strong></td><td style="text-align:center"><strong>创建一个 DatagramSocket 对象并将其绑定到本地主机上的指定端口</strong></td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">public DatagramSocket(int port,InetAddress laddr)throws SocketException</td><td style="text-align:center">构造</td><td style="text-align:center">创建一个 DatagramSocket 对象，将其绑定到指定的本地地址</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">public DatagramSocket(SocketAddress  bindaddr) throws SocketException</td><td style="text-align:center">构造</td><td style="text-align:center">创建一个 DatagramSocket 对象，将其绑定到指定的本地套接字地址</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">public void bind(SocketAddress addr)  throws SocketException</td><td style="text-align:center">普通</td><td style="text-align:center">将此 DatagramSocket 绑定到特定的SocketAddress（通常为 IP 地址+端口号）</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">public void close()</td><td style="text-align:center">普通</td><td style="text-align:center">关闭此数据报套接字</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">public void connect(InetAddress address,  int port)</td><td style="text-align:center">普通</td><td style="text-align:center">将套接字连接到远程主机的地址和端口</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">public void connect(SocketAddress addr)  throws SocketException</td><td style="text-align:center">普通</td><td style="text-align:center">将此套接字连接到远程套接字地址（IP 地 址+端口号）</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">public void disconnect()</td><td style="text-align:center">普通</td><td style="text-align:center">断开套接字的连接</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">public InetAddress getInetAddress()</td><td style="text-align:center">普通</td><td style="text-align:center">获取 DatagramSocket 对象连接的地址</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">public InetAddress getLocalAddress()</td><td style="text-align:center">普通</td><td style="text-align:center">获取此 DatagramSocket 对象绑定的本地 地址</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">public int getLocalPort()</td><td style="text-align:center">普通</td><td style="text-align:center">获取此 DatagramSocket 对象绑定的本地 主机上的端口号</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">public int getPort()</td><td style="text-align:center">普通</td><td style="text-align:center">获取此 DatagramSocket 对象的端口</td></tr><tr><td style="text-align:center">14</td><td style="text-align:center">public int getTrafficClass() throws Socket  Exception</td><td style="text-align:center">普通</td><td style="text-align:center">为从此 DatagramSocket 上发送的包获取 IP 数据报头中的流量类别或服务类型</td></tr><tr><td style="text-align:center">15</td><td style="text-align:center">public boolean isBound()</td><td style="text-align:center">普通</td><td style="text-align:center">判断此 DatagramSocket 绑定状态。若成功地绑定到一个地址，则返回 true，否则返回 false</td></tr><tr><td style="text-align:center">16</td><td style="text-align:center">public boolean isClosed()</td><td style="text-align:center">普通</td><td style="text-align:center">判断此 DatagramSocket 是否已关闭。</td></tr><tr><td style="text-align:center">17</td><td style="text-align:center">public boolean isConnected()</td><td style="text-align:center">普通</td><td style="text-align:center">判断此 DatagramSocket 的连接状态。若成功地连接到服务器，则返回 true，否则返回 false</td></tr><tr><td style="text-align:center"><strong>18</strong></td><td style="text-align:center"><strong>public void receive(DatagramPacket p)  throws IOException</strong></td><td style="text-align:center"><strong>普通</strong></td><td style="text-align:center"><strong>从此 DatagramSocket 对象接收数据报包</strong></td></tr><tr><td style="text-align:center"><strong>19</strong></td><td style="text-align:center"><strong>public void send(DatagramPacket p)  throws IOException</strong></td><td style="text-align:center"><strong>普通</strong></td><td style="text-align:center"><strong>从此 DatagramSocket 对象发送数据报包</strong></td></tr></tbody></table><h4 id="udp-程序实现"><a class="markdownIt-Anchor" href="#udp-程序实现"></a> UDP 程序实现</h4><h5 id="客户端"><a class="markdownIt-Anchor" href="#客户端"></a> 客户端：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDPTest01</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        DatagramPacket dpack=<span class="keyword">null</span>;</span><br><span class="line">        DatagramSocket dsocket=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">byte</span> b[]=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">512</span>];<span class="comment">//定义接收数据的大小</span></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            dsocket=<span class="keyword">new</span> DatagramSocket(<span class="number">8000</span>);<span class="comment">//绑定本地端口</span></span><br><span class="line">            dpack=<span class="keyword">new</span> DatagramPacket(b,<span class="number">512</span>);<span class="comment">//创建数据包</span></span><br><span class="line">            System.out.println(<span class="string">&quot;等待数据......&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dsocket.receive(dpack);<span class="comment">//接收数据包</span></span><br><span class="line">                String msg=<span class="keyword">new</span> String(dpack.getData(),<span class="number">0</span>,dpack.getLength());</span><br><span class="line">                System.out.println(<span class="string">&quot;远程计算机的IP地址：&quot;</span>+dpack.getAddress().getHostAddress());<span class="comment">//获取发送数据包的主机IP</span></span><br><span class="line">                System.out.println(<span class="string">&quot;远程计算机的端口：&quot;</span>+dpack.getPort());</span><br><span class="line">                System.out.println(<span class="string">&quot;接收到的信息：&quot;</span>+msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)</span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​以上程序运行之后，客户端就会打开指定的端口进行监听，等待服务端发送来的数据。下面再编写服务端程序。</p><h5 id="服务端"><a class="markdownIt-Anchor" href="#服务端"></a> 服务端：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDPTest02</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        DatagramSocket dsocket=<span class="keyword">null</span>;</span><br><span class="line">        DatagramPacket dpack=<span class="keyword">null</span>;</span><br><span class="line">        Scanner scan=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            InetAddress local=InetAddress.getLocalHost();<span class="comment">//获取本地IP地址</span></span><br><span class="line">            dsocket=<span class="keyword">new</span> DatagramSocket(<span class="number">8001</span>);<span class="comment">//绑定本地端口</span></span><br><span class="line">            String mag=<span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">byte</span> b[]=<span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;发送消息：&quot;</span>);</span><br><span class="line">                mag=scan.next();</span><br><span class="line">                b=mag.getBytes();</span><br><span class="line">                dpack=<span class="keyword">new</span> DatagramPacket(b,b.length,local,<span class="number">8000</span>);</span><br><span class="line">                <span class="comment">/*创建发送数据包*/</span></span><br><span class="line">                dsocket.send(dpack);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​服务端运行后可以向客户端发送消息，客户端接收到消息后将其显示，运行结果如下：</p><p><img src="https://silenthty.gitee.io/photo/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/UDP%E9%80%9A%E4%BF%A1.png" alt="" /></p><p>参考链接：</p><p><a href="https://blog.csdn.net/weixin_45836865/article/details/105368653">UDP接受数据时候缺失_weixin_45836865的博客-CSDN博客</a></p><p>参考书目：</p><p><a href="http://product.dangdang.com/23248198.html?ref=book-35530-3032_5-231497-4">《Java编程手记——从实践中学习Java（配光盘）》(欧二强　等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​		在 TCP/IP 协议的传输层中，除了前面介绍过的 TCP 协议以外，还可以使用 UDP 协议。 UDP 是一种无连接的客户/服务器（C/S）通信协议，用于不可靠的点对点通信，适合对通信性能要求高但通信可靠性要求低的应用，还支持广播和多播通信方式。&lt;/p&gt;
&lt;h3 i</summary>
      
    
    
    
    <category term="java" scheme="https://silenthly.github.io/categories/java/"/>
    
    
    <category term="笔记" scheme="https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>TCP 程序设计</title>
    <link href="https://silenthly.github.io/2021/08/28/TCP-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <id>https://silenthly.github.io/2021/08/28/TCP-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</id>
    <published>2021-08-28T04:54:31.000Z</published>
    <updated>2021-08-30T17:47:11.760Z</updated>
    
    <content type="html"><![CDATA[<p>​TCP/IP 协议是一种可靠的网络协议，它在通信的两端分别建立一个 Socket，从而在通信的两端形成网路虚拟链路。只有虚拟的网络链路建立了，双方才可以进行通信。进行 TCP 网络编程需要使用两个类，一个是服务器套接字 ServerSocket 类，另一个是客户端套接字 Socket 类。</p><h3 id="serversocket-类"><a class="markdownIt-Anchor" href="#serversocket-类"></a> ServerSocket 类</h3><p>​ServerSocket 类用来为服务端建立套接字，它的主要功能是等到来自网络中其他客户端的请求。ServerSocket 类可以指定端口等待连接的套接字，服务器的套接字一次只能与一个客户端套接字相连。</p><p>​如果多态客户端同时请求连接，服务器会将请求连接的客户端放入队列中，然后从中取出一个套接字与服务器的套接字相连。若请求数大于最大的容纳数，则多余出来的请求就会被拒绝，最大容纳数默认为 50。ServerSocket 类的常用方法如下表所示。</p><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">方法</th><th style="text-align:center">类型</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">public ServeSocket()throws IOException</td><td style="text-align:center">构造</td><td style="text-align:center">创建非绑定服务器套接字</td></tr><tr><td style="text-align:center"><strong>2</strong></td><td style="text-align:center"><strong>public ServeSocket(int port)throws IOException</strong></td><td style="text-align:center"><strong>构造</strong></td><td style="text-align:center"><strong>创建绑定到特定端口的服务器套接字</strong></td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">public ServeSocket(int port,int backing)throws IOException</td><td style="text-align:center">构造</td><td style="text-align:center">利用指定的 backlog 创建服务器套接字并 将其绑定到指定的本地端口号</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">public ServeSocket(int port,int backing,InetAddress bindAddr)throws IOException</td><td style="text-align:center">构造</td><td style="text-align:center">使用指定的端口、侦听backlog和要绑定到的本地IP地址创建服务器。这个情况适应于计算机上存在多个网卡多个IP地址的时候，使用该构造方法可以明确规定ServerSocket在哪块网卡或哪个IP地址等待连接请求</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">public void bind(SocketAddress endpoint)throws IOException</td><td style="text-align:center">普通</td><td style="text-align:center">将ServerSocket绑定到特定地址（IP地址和端口号）</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">public void bind(SocketAddress endpoint,int bocklog)throws IOException</td><td style="text-align:center">普通</td><td style="text-align:center">将ServerSocket绑定到特定地址（IP地址和端口号）</td></tr><tr><td style="text-align:center"><strong>7</strong></td><td style="text-align:center"><strong>public void close()throws IOException</strong></td><td style="text-align:center"><strong>普通</strong></td><td style="text-align:center"><strong>关闭此套接字</strong></td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">public ServerSocketChannel getChannel()</td><td style="text-align:center">普通</td><td style="text-align:center">返回与此套接字关联的唯一 ServerSocketChannel 对象</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">public InetAddress getInetAddress()</td><td style="text-align:center">普通</td><td style="text-align:center">返回此服务器套接字的本地地址</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">public int getLocalPort()</td><td style="text-align:center">普通</td><td style="text-align:center">返回此套接字上侦听的端口</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">public SocketAddress getLocalSocketAddress()</td><td style="text-align:center">普通</td><td style="text-align:center">返回此套接字绑定的端点地址，如果尚未绑定，则返回 null</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">public boolean isBound()</td><td style="text-align:center">普通</td><td style="text-align:center">返回 ServerSocket 的绑定状态</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">public boolean isClosed()</td><td style="text-align:center">普通</td><td style="text-align:center">判断 ServerSocket 是否关闭；若已经关闭了套接字，则返回 true，否则返回 false</td></tr><tr><td style="text-align:center">14</td><td style="text-align:center">public static void setSocketFactory(Socket  ImplFactory fac)</td><td style="text-align:center">静态</td><td style="text-align:center">设置应用程序的服务端套接字实现工厂</td></tr><tr><td style="text-align:center"><strong>15</strong></td><td style="text-align:center"><strong>public Socket accept() throws IOException</strong></td><td style="text-align:center"><strong>普通</strong></td><td style="text-align:center"><strong>侦听并接受客户端的连接。若连接成功， 则创建一个套接字</strong></td></tr><tr><td style="text-align:center">16</td><td style="text-align:center">public String toString()</td><td style="text-align:center">普通</td><td style="text-align:center">作为 String 返回此套接字的实现地址和实现端口</td></tr></tbody></table><p>​当 ServerSocket 类的对象创建后，调用 accept()方法接收客户端发来的连接请求。accept() 方法采用的是“阻塞”方式监听，直到客户端连接之后程序才可以向下继续执行并返回一个与客户端 Socket 对象相连的 Socket 对象。服务器端的 Socket 对象使用 getOutputStream() 方法获得的输出流，将指向客户端Socket对象使用getInputStream()方法获得的那个输入流。 同样地，服务器端的 Socket 对象使用 getInputStream()方法获得的输入流，将指向客户端 Socket 对象使用 getOutputStream()方法获得的那个输出流。</p><h3 id="socket-类"><a class="markdownIt-Anchor" href="#socket-类"></a> Socket 类</h3><p>​在 Java 中，有专门的 Socket 类来处理用户的请求和响应。利用 Socket 类的方法，就可以实现两台计算机之间的通信。客户端创建 Socket 对象之后，会向指定的 IP 地址即端口尝试连接。服务端的 Socket 接到连接请求后创建新的 Socket 与客户端的 Socket 进行连接。若服务端 Socket 与客户端 Socket 连接成功之后，就可以获取 Socket 中的输入/输出流。 Socket 类的常用方法如下表所示。</p><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">方法</th><th style="text-align:center">类型</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">public Socket()</td><td style="text-align:center">构造</td><td style="text-align:center">创建非绑定服务器套接字</td></tr><tr><td style="text-align:center"><strong>2</strong></td><td style="text-align:center"><strong>public Socket(InetAddress address,int port)throws IOException</strong></td><td style="text-align:center">构造</td><td style="text-align:center">创建一个<strong>流套接</strong>字并将其连接到指定 <strong>IP 地址</strong>的指定端口号</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">public Socket(InetAddress address,int port,InetAddress localAddr,int localport)throws IOException</td><td style="text-align:center">构造</td><td style="text-align:center">创建一个套接字并将其连接到指定<strong>远程地址</strong>上的指定远程端口</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">public Socket(Porxy proxy)</td><td style="text-align:center">构造</td><td style="text-align:center">创建一个未连接的套接字并指定代理类型（如果有），该代理不管其他设置如何都应被使用</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">public Socket(String host, int port) throws  UnknownHostException,IOException</td><td style="text-align:center">构造</td><td style="text-align:center">创建一个<strong>流套接字</strong>并将其连接到指定<strong>主机</strong>上的指定端口号</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">public Socket(String host, int port, InetAddress  localAddr, int localPort) throws IOException</td><td style="text-align:center">构造</td><td style="text-align:center">创建一个套接字并将其连接到指定<strong>远程主机</strong>上的指定远程端口</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">public void bind(SocketAddress bindpoint)throws IOException</td><td style="text-align:center">普通</td><td style="text-align:center">将套接字绑定到本地地址</td></tr><tr><td style="text-align:center"><strong>8</strong></td><td style="text-align:center"><strong>public void close() throws IOException</strong></td><td style="text-align:center"><strong>普通</strong></td><td style="text-align:center"><strong>关闭此套接字</strong></td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">public void connect(SocketAddress  endpoint)throws IOException</td><td style="text-align:center">普通</td><td style="text-align:center">将此套接字连接到服务器</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">public void connect(SocketAddress endpoint, int timeout) throws IOException</td><td style="text-align:center">普通</td><td style="text-align:center">将此套接字连接到服务器，并指定一个超时值</td></tr><tr><td style="text-align:center"><strong>11</strong></td><td style="text-align:center"><strong>public InetAddress getInetAddress()</strong></td><td style="text-align:center"><strong>普通</strong></td><td style="text-align:center">返回套接字<strong>连接的</strong>地址</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">public InetAddress getLocalAddress()</td><td style="text-align:center">普通</td><td style="text-align:center">获取套接字<strong>绑定的</strong>本地地址</td></tr><tr><td style="text-align:center"><strong>13</strong></td><td style="text-align:center"><strong>public InputStream getInputStream() throws  IOException</strong></td><td style="text-align:center"><strong>普通</strong></td><td style="text-align:center"><strong>返回此套接字的输入流</strong></td></tr><tr><td style="text-align:center"><strong>14</strong></td><td style="text-align:center"><strong>public OutputStream getOutputStream() throws  IOException</strong></td><td style="text-align:center"><strong>普通</strong></td><td style="text-align:center"><strong>返回此套接字的输出流</strong></td></tr><tr><td style="text-align:center">15</td><td style="text-align:center">public int getLocalPort()</td><td style="text-align:center">普通</td><td style="text-align:center">返回此套接字<strong>绑定到的</strong>本地端口</td></tr><tr><td style="text-align:center">16</td><td style="text-align:center">public SocketAddress getLocalSocketAddress()</td><td style="text-align:center">普通</td><td style="text-align:center">返回此套接字<strong>绑定的</strong>端点地址，如果尚未绑定则返回 null</td></tr><tr><td style="text-align:center">17</td><td style="text-align:center">public int getPort()</td><td style="text-align:center">普通</td><td style="text-align:center">返回此套接字<strong>连接到的</strong>远程端口</td></tr><tr><td style="text-align:center">18</td><td style="text-align:center">public SocketAddress getRemoteSocketAddress()</td><td style="text-align:center">普通</td><td style="text-align:center">返回此套接字<strong>连接的</strong>端点地址，如果未连接则返回 null</td></tr><tr><td style="text-align:center">19</td><td style="text-align:center">public int getTrafficClass() throws Socket  Exception</td><td style="text-align:center">普通</td><td style="text-align:center">为从此 Socket 上发送的包获取 IP 头中的流量类别或服务类型</td></tr><tr><td style="text-align:center">20</td><td style="text-align:center">public boolean isBound()</td><td style="text-align:center">普通</td><td style="text-align:center">判断套接字是否绑定，若套接字成功地绑定到一个地址，则返回 true，否则返回 false</td></tr><tr><td style="text-align:center">21</td><td style="text-align:center">public boolean isClosed()</td><td style="text-align:center">普通</td><td style="text-align:center">判断 Socket 是否关闭，若已经关闭了套接字，则返回 true，否则返回 false</td></tr><tr><td style="text-align:center">22</td><td style="text-align:center">public boolean isConnected()</td><td style="text-align:center">普通</td><td style="text-align:center">判断套接字是否连接上服务器，若套接字成功地连接到服务器，则为 true，否则返回 false</td></tr><tr><td style="text-align:center">23</td><td style="text-align:center">public void sendUrgentData(int data) throws  IOException</td><td style="text-align:center">普通</td><td style="text-align:center">在套接字上发送一个紧急数据字节</td></tr><tr><td style="text-align:center">24</td><td style="text-align:center">public static void setSocketImplFactory  (SocketImplFactory fac) throws IOException</td><td style="text-align:center">普通</td><td style="text-align:center">设置应用程序的客服端套接字实现工厂</td></tr><tr><td style="text-align:center">25</td><td style="text-align:center">public void shutdownInput() throws IOException</td><td style="text-align:center">普通</td><td style="text-align:center">此套接字的输入流置于“流的末尾”</td></tr><tr><td style="text-align:center">26</td><td style="text-align:center">public void shutdownOutput() throws IOException</td><td style="text-align:center">普通</td><td style="text-align:center">禁用此套接字的输出流</td></tr><tr><td style="text-align:center">27</td><td style="text-align:center">public String toString()</td><td style="text-align:center">普通</td><td style="text-align:center">将此套接字转换为 String</td></tr></tbody></table><p>​在 Socket 类中的诸多方法中，最常用的是 getInputStream()和 getOutputStream()方法，这两个是实际通信中必须使用的方法。</p><h4 id="socket-通信过程一对一的-tcp-程序"><a class="markdownIt-Anchor" href="#socket-通信过程一对一的-tcp-程序"></a> Socket 通信过程：一对一的 TCP 程序</h4><p>​下面使用 ServerSocket 类和 Socket 类来完成一个服务端的程序开发，代码如下。</p><h5 id="服务端程序"><a class="markdownIt-Anchor" href="#服务端程序"></a> 服务端程序：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ServerSocket server=<span class="keyword">null</span>;</span><br><span class="line">        Socket socket=<span class="keyword">null</span>;</span><br><span class="line">        DataInputStream din=<span class="keyword">null</span>;</span><br><span class="line">        DataOutputStream dout=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            server=<span class="keyword">new</span> ServerSocket(<span class="number">8000</span>);<span class="comment">//创建一个绑定8000端口的服务套接字</span></span><br><span class="line">            System.out.println(<span class="string">&quot;等待客服连接上......&quot;</span>);</span><br><span class="line">            socket=server.accept();<span class="comment">//阻塞等待客服端的连接</span></span><br><span class="line">            System.out.println(<span class="string">&quot;客户端连接上......\n客户端来自：&quot;</span>+socket.getInetAddress().getHostAddress());<span class="comment">//获取客户端的IP地址</span></span><br><span class="line">            din=<span class="keyword">new</span> DataInputStream(socket.getInputStream());<span class="comment">//获取客户端的输入流</span></span><br><span class="line">            dout=<span class="keyword">new</span> DataOutputStream(socket.getOutputStream());<span class="comment">//获取客户端的输出流</span></span><br><span class="line">            String strMassage=<span class="keyword">null</span>;</span><br><span class="line">            Scanner scan=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">            <span class="keyword">boolean</span> flag=<span class="keyword">true</span>;<span class="comment">//标记位</span></span><br><span class="line">            <span class="keyword">while</span>(flag)</span><br><span class="line">            &#123;</span><br><span class="line">                strMassage=din.readUTF();<span class="comment">//读取客户端发送的信息</span></span><br><span class="line">                <span class="keyword">if</span>(!strMassage.equals(<span class="string">&quot;bye&quot;</span>))<span class="comment">//若消息为bye则退出，否则继续</span></span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;客户端消息：\n&quot;</span>+strMassage);</span><br><span class="line">                    System.out.println(<span class="string">&quot;回复客户端：&quot;</span>);</span><br><span class="line">                    strMassage=scan.next();<span class="comment">//输入信息</span></span><br><span class="line">                    dout.writeUTF(strMassage);<span class="comment">//向客户端发送消息</span></span><br><span class="line">                    dout.flush();</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    din.close();</span><br><span class="line">                    dout.close();</span><br><span class="line">                    flag=<span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            server.close();<span class="comment">//关闭服务端</span></span><br><span class="line">            System.out.println(<span class="string">&quot;服务器退出......&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​在以上程序中服务端运行之后要等待客户端的连 接，采用的是阻塞方式。下面编写客户端的程序，代码如下。</p><h5 id="客户端"><a class="markdownIt-Anchor" href="#客户端"></a> 客户端：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClientTest</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Socket socket=<span class="keyword">null</span>;</span><br><span class="line">        DataInputStream din=<span class="keyword">null</span>;</span><br><span class="line">        DataOutputStream dout=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;尝试连接服务器......&quot;</span>);</span><br><span class="line">            socket=<span class="keyword">new</span> Socket(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">8000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;连接服务器成功......&quot;</span>);</span><br><span class="line">            din=<span class="keyword">new</span> DataInputStream(socket.getInputStream());</span><br><span class="line">            dout=<span class="keyword">new</span> DataOutputStream(socket.getOutputStream());</span><br><span class="line">            String strMassage=<span class="keyword">null</span>;</span><br><span class="line">            Scanner scan=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">            <span class="keyword">boolean</span> flag=<span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">while</span>(flag)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;发送消息：&quot;</span>);</span><br><span class="line">                strMassage=scan.next();</span><br><span class="line">                dout.writeUTF(strMassage);<span class="comment">//向服务端发送消息</span></span><br><span class="line">                dout.flush();</span><br><span class="line">                strMassage=din.readUTF();<span class="comment">//读取服务器消息</span></span><br><span class="line">                <span class="keyword">if</span>(!strMassage.equals(<span class="string">&quot;bye&quot;</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;接收信息：\n&quot;</span>+strMassage);</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    din.close();</span><br><span class="line">                    dout.close();</span><br><span class="line">                    flag=<span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            socket.close();<span class="comment">//关闭客户端</span></span><br><span class="line">            System.out.println(<span class="string">&quot;服务器退出......&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端运行并连接上服务端后，可以向服务端发送消息，服务端接收到消息后也可以向客户端发送消息。运行结果如图所示：</p><p><img src="https://silenthty.gitee.io/photo/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/TCP%E9%80%9A%E4%BF%A1.png" alt="" /></p><p>​可以看到，先输入&quot;bye&quot;结束对话的一端，会因为另一端的结束而抛出异常。在以上程序中存在一个很大的缺点，就是服务端一次只能与一个客户端相连，因为该程序属于单线程的处理机制。为了让服务端可以同时连接多个客户端，可以加入多线程处理机制。</p><h4 id="socket-通信过程一对多的-tcp-程序"><a class="markdownIt-Anchor" href="#socket-通信过程一对多的-tcp-程序"></a> Socket 通信过程：一对多的 TCP 程序</h4><p>​在服务端加入多线程之后，当每一个客户端连接上服务端时，就启动一个新的线程。这样的好处是每一个 Socket 对象执行完成之后，只有包含该 Socket 对象的线程终止，而不会对其他的线程产生影响。开启多线程也会消耗更多的计算机资源，因为服务端可以连接的客户端数量是有限的。下面编写一个 ServerThread 类专门处理多线程操作，代码如下。</p><p>处理多线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServerThread</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServerThread</span><span class="params">(Socket socket)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.socket=socket;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        DataInputStream din=<span class="keyword">null</span>;</span><br><span class="line">        DataOutputStream dout=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;客户端连接上......\n客户端来自：&quot;</span>+socket.getInetAddress().getHostAddress());</span><br><span class="line">            din=<span class="keyword">new</span> DataInputStream(socket.getInputStream());</span><br><span class="line">            dout=<span class="keyword">new</span> DataOutputStream(socket.getOutputStream());</span><br><span class="line">            String strMassage=<span class="keyword">null</span>;</span><br><span class="line">            Scanner scan=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">            <span class="keyword">boolean</span> flag=<span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">while</span>(flag)</span><br><span class="line">            &#123;</span><br><span class="line">                strMassage=din.readUTF();<span class="comment">//读取客户端发送的消息</span></span><br><span class="line">                <span class="keyword">if</span>(!strMassage.equals(<span class="string">&quot;bye&quot;</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;客户端信息：&quot;</span>+strMassage);</span><br><span class="line">                System.out.println(<span class="string">&quot;回复客户端：&quot;</span>);</span><br><span class="line">                strMassage=scan.next();</span><br><span class="line">                dout.writeUTF(strMassage);</span><br><span class="line">                dout.flush();</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    din.close();</span><br><span class="line">                    dout.close();</span><br><span class="line">                    flag=<span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            socket.close();<span class="comment">//关闭服务器</span></span><br><span class="line">            System.out.println(<span class="string">&quot;服务器退出......&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再编写一个主类来使用 ServerThread 类，范例如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerTest01</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ServerSocket server=<span class="keyword">null</span>;</span><br><span class="line">        Socket socket=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            server=<span class="keyword">new</span> ServerSocket(<span class="number">8000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;等待客户端连接......&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                socket=server.accept();</span><br><span class="line">                <span class="keyword">new</span> Thread(<span class="keyword">new</span> ServerThread(socket)).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​客户端就是前面的范例，无须任何修改.在 ServerTest01 运行时，可以同时与多个客户端进行通信，每一个客户端的 Socket 都会以一个线程的方式运行。运行结果如下：</p><p><img src="https://silenthty.gitee.io/photo/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/TCP%E9%80%9A%E4%BF%A11.png" alt="" /></p><p>​从程序运行结果发现，服务端的确可以连接多个客户端，但如果多个客户端同时发送消息时，需要按照客户端消息发送顺序回复。</p><h3 id="牛刀小试"><a class="markdownIt-Anchor" href="#牛刀小试"></a> 牛刀小试</h3><p>请编写一个简单的端口扫描程序。要求：</p><ul><li>可以指定扫描的 IP。</li><li>可以指定扫描的 IP。</li></ul><p>​通过 Socket 类尝试与指定主机的指定端口建立连接，以检查该主机的某些端口是否活动。如果在建立与一个端口的连接时未抛出任何异常，则表明该端口是活动的，代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Scanner scan=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入IP地址：&quot;</span>);</span><br><span class="line">        String ip=scan.next();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入起始端口号：&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> from=scan.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入终止端口号：&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> end=scan.nextInt();</span><br><span class="line">        Socket socket=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> port=<span class="number">0</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;扫描中......&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(port=from;port&lt;=end;port++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                socket=<span class="keyword">new</span> Socket(ip,port);</span><br><span class="line">                System.out.println(<span class="string">&quot;活动端口：&quot;</span>+port);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(ConnectException e)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(port+<span class="string">&quot;端口关闭&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(socket!=<span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;扫描结束......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">请输入IP地址：</span><br><span class="line"><span class="number">14.215</span><span class="number">.177</span><span class="number">.38</span></span><br><span class="line">请输入起始端口号：</span><br><span class="line"><span class="number">78</span></span><br><span class="line">请输入终止端口号：</span><br><span class="line"><span class="number">84</span></span><br><span class="line">扫描中......</span><br><span class="line"><span class="number">78</span>端口关闭</span><br><span class="line"><span class="number">79</span>端口关闭</span><br><span class="line">活动端口：<span class="number">80</span></span><br><span class="line"><span class="number">81</span>端口关闭</span><br><span class="line"><span class="number">82</span>端口关闭</span><br><span class="line"><span class="number">83</span>端口关闭</span><br><span class="line"><span class="number">84</span>端口关闭</span><br><span class="line">扫描结束......</span><br></pre></td></tr></table></figure><p>​以上用于测试的IP地址为百度的IP地址。</p><p>参考书目：</p><p><a href="http://product.dangdang.com/23248198.html?ref=book-35530-3032_5-231497-4">《Java编程手记——从实践中学习Java（配光盘）》(欧二强　等编著)【简介_书评_在线阅读】 - 当当图书 (dangdang.com)</a></p><p>相关链接：</p><p><a href="https://segmentfault.com/a/1190000019252960">backlog参数对TCP连接建立的影响 - SegmentFault 思否</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​		TCP/IP 协议是一种可靠的网络协议，它在通信的两端分别建立一个 Socket，从而在通信的两端形成网路虚拟链路。只有虚拟的网络链路建立了，双方才可以进行通信。进行 TCP 网络编程需要使用两个类，一个是服务器套接字 ServerSocket 类，另一个是客户端套接</summary>
      
    
    
    
    <category term="java" scheme="https://silenthly.github.io/categories/java/"/>
    
    
    <category term="笔记" scheme="https://silenthly.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
